{
  "Date": {
    "doc": "The Date class provides a basic structure for date and time related\ninformation. Date instances can be created by\n\n- `new Date()` for a specific date,\n- `Date.now()` to obtain information about the current time,\n- `Date.fromTime()` with a given timestamp or\n- `Date.fromString()` by parsing from a String.\n\nThere are some extra functions available in the `DateTools` class.\n\nIn the context of Haxe dates, a timestamp is defined as the number of\nmilliseconds elapsed since 1st January 1970 UTC.\n\n## Supported range\n\nDue to platform limitations, only dates in the range 1970 through 2038 are\nsupported consistently. Some targets may support dates outside this range,\ndepending on the OS at runtime. The `Date.fromTime` method will not work with\ntimestamps outside the range on any target.",
    "path": "haxe\\std\\Date.hx",
    "functions": {
      "getTime": "Returns the timestamp (in milliseconds) of `this` date.\n\tOn cpp and neko, this function only has a second resolution, so the\n\tresult will always be a multiple of `1000.0`, e.g. `1454698271000.0`.\n\tTo obtain the current timestamp with better precision on cpp and neko,\n\tsee the `Sys.time` API.\n\n\tFor measuring time differences with millisecond accuracy on\n\tall platforms, see `haxe.Timer.stamp`.",
      "getHours": "Returns the hours of `this` Date (0-23 range) in the local timezone.",
      "getMinutes": "Returns the minutes of `this` Date (0-59 range) in the local timezone.",
      "getSeconds": "Returns the seconds of `this` Date (0-59 range) in the local timezone.",
      "getFullYear": "Returns the full year of `this` Date (4 digits) in the local timezone.",
      "getMonth": "Returns the month of `this` Date (0-11 range) in the local timezone.\n\tNote that the month number is zero-based.",
      "getDate": "Returns the day of `this` Date (1-31 range) in the local timezone.",
      "getDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\n\tin the local timezone.",
      "getUTCHours": "Returns the hours of `this` Date (0-23 range) in UTC.",
      "getUTCMinutes": "Returns the minutes of `this` Date (0-59 range) in UTC.",
      "getUTCSeconds": "Returns the seconds of `this` Date (0-59 range) in UTC.",
      "getUTCFullYear": "Returns the full year of `this` Date (4 digits) in UTC.",
      "getUTCMonth": "Returns the month of `this` Date (0-11 range) in UTC.\n\tNote that the month number is zero-based.",
      "getUTCDate": "Returns the day of `this` Date (1-31 range) in UTC.",
      "getUTCDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\n\tin UTC.",
      "getTimezoneOffset": "Returns the time zone difference of `this` Date in the current locale\n\tto UTC, in minutes.\n\n\tAssuming the function is executed on a machine in a UTC+2 timezone,\n\t`Date.now().getTimezoneOffset()` will return `-120`.",
      "toString": "Returns a string representation of `this` Date in the local timezone\n\tusing the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for\n\tother formatting rules.",
      "now": "Returns a Date representing the current local time.",
      "fromTime": "Creates a Date from the timestamp (in milliseconds) `t`.",
      "fromString": "Creates a Date from the formatted string `s`. The following formats are\n\taccepted by the function:\n\n\t- `\"YYYY-MM-DD hh:mm:ss\"`\n\t- `\"YYYY-MM-DD\"`\n\t- `\"hh:mm:ss\"`\n\n\tThe first two formats expressed a date in local time. The third is a time\n\trelative to the UTC epoch.\n\n\tIf `s` does not match these formats, the result is unspecified."
    },
    "fields": {}
  },
  "DateTools": {
    "doc": "The DateTools class contains some extra functionalities for handling `Date`\ninstances and timestamps.\n\nIn the context of Haxe dates, a timestamp is defined as the number of\nmilliseconds elapsed since 1st January 1970.",
    "path": "haxe\\std\\DateTools.hx",
    "functions": {
      "delta": "Returns the result of adding timestamp `t` to Date `d`.\n\n\tThis is a convenience function for calling\n\t`Date.fromTime(d.getTime() + t)`.",
      "getMonthDays": "Returns the number of days in the month of Date `d`.\n\n\tThis method handles leap years.",
      "seconds": "Converts a number of seconds to a timestamp.",
      "minutes": "Converts a number of minutes to a timestamp.",
      "hours": "Converts a number of hours to a timestamp.",
      "days": "Converts a number of days to a timestamp.",
      "parse": "Separate a date-time into several components",
      "make": "Build a date-time from several components"
    },
    "fields": {}
  },
  "EReg": {
    "doc": "The EReg class represents regular expressions.\n\nWhile basic usage and patterns consistently work across platforms, some more\ncomplex operations may yield different results. This is a necessary trade-\noff to retain a certain level of performance.\n\nEReg instances can be created by calling the constructor, or with the\nspecial syntax `~/pattern/modifier`\n\nEReg instances maintain an internal state, which is affected by several of\nits methods.\n\nA detailed explanation of the supported operations is available at\n<https://haxe.org/manual/std-regex.html>",
    "path": "haxe\\std\\EReg.hx",
    "functions": {
      "match": "Tells if `this` regular expression matches String `s`.\n\n\tThis method modifies the internal state.\n\n\tIf `s` is `null`, the result is unspecified.",
      "matched": "Returns the matched sub-group `n` of `this` EReg.\n\n\tThis method should only be called after `this.match` or\n\t`this.matchSub`, and then operates on the String of that operation.\n\n\tThe index `n` corresponds to the n-th set of parentheses in the pattern\n\tof `this` EReg. If no such sub-group exists, the result is unspecified.\n\n\tIf `n` equals 0, the whole matched substring is returned.",
      "matchedLeft": "Returns the part to the left of the last matched substring.\n\n\tIf the most recent call to `this.match` or `this.matchSub` did not\n\tmatch anything, the result is unspecified.\n\n\tIf the global g modifier was in place for the matching, only the\n\tsubstring to the left of the leftmost match is returned.\n\n\tThe result does not include the matched part.",
      "matchedRight": "Returns the part to the right of the last matched substring.\n\n\tIf the most recent call to `this.match` or `this.matchSub` did not\n\tmatch anything, the result is unspecified.\n\n\tIf the global g modifier was in place for the matching, only the\n\tsubstring to the right of the leftmost match is returned.\n\n\tThe result does not include the matched part.",
      "matchedPos": "Returns the position and length of the last matched substring, within\n\tthe String which was last used as argument to `this.match` or\n\t`this.matchSub`.\n\n\tIf the most recent call to `this.match` or `this.matchSub` did not\n\tmatch anything, the result is unspecified.\n\n\tIf the global g modifier was in place for the matching, the position and\n\tlength of the leftmost substring is returned.",
      "matchSub": "Tells if `this` regular expression matches a substring of String `s`.\n\n\tThis function expects `pos` and `len` to describe a valid substring of\n\t`s`, or else the result is unspecified. To get more robust behavior,\n\t`this.match(s.substr(pos,len))` can be used instead.\n\n\tThis method modifies the internal state.\n\n\tIf `s` is null, the result is unspecified.",
      "matchedNum": "Returns the total number of groups captures by the last matched substring.\n\n\tTo stay consistent with `this.matched`, the matched substring is also\n\tcounted as a group.\n\n\tReturns `0` if no substring has been matched.",
      "split": "Splits String `s` at all substrings `this` EReg matches.\n\n\tIf a match is found at the start of `s`, the result contains a leading\n\tempty String \"\" entry.\n\n\tIf a match is found at the end of `s`, the result contains a trailing\n\tempty String \"\" entry.\n\n\tIf two matching substrings appear next to each other, the result\n\tcontains the empty String `\"\"` between them.\n\n\tBy default, this method splits `s` into two parts at the first matched\n\tsubstring. If the global g modifier is in place, `s` is split at each\n\tmatched substring.\n\n\tIf `s` is null, the result is unspecified.",
      "replace": "Replaces the first substring of `s` which `this` EReg matches with `by`.\n\n\tIf `this` EReg does not match any substring, the result is `s`.\n\n\tBy default, this method replaces only the first matched substring. If\n\tthe global g modifier is in place, all matched substrings are replaced.\n\n\tIf `by` contains `$1` to `$9`, the digit corresponds to number of a\n\tmatched sub-group and its value is used instead. If no such sub-group\n\texists, the replacement is unspecified. The string `$$` becomes `$`.\n\n\tIf `s` or `by` are null, the result is unspecified.",
      "map": "Calls the function `f` for the substring of `s` which `this` EReg matches\n\tand replaces that substring with the result of `f` call.\n\n\tThe `f` function takes `this` EReg object as its first argument and should\n\treturn a replacement string for the substring matched.\n\n\tIf `this` EReg does not match any substring, the result is `s`.\n\n\tBy default, this method replaces only the first matched substring. If\n\tthe global g modifier is in place, all matched substrings are replaced.\n\n\tIf `s` or `f` are null, the result is unspecified.",
      "escape": "Escape the string `s` for use as a part of regular expression.\n\n\tIf `s` is null, the result is unspecified."
    },
    "fields": {}
  },
  "IntIterator": {
    "doc": "IntIterator is used for implementing interval iterations.\n\nIt is usually not used explicitly, but through its special syntax:\n`min...max`\n\nWhile it is possible to assign an instance of IntIterator to a variable or\nfield, it is worth noting that IntIterator does not reset after being used\nin a for-loop. Subsequent uses of the same instance will then have no\neffect.\n\n@see https://haxe.org/manual/lf-iterators.html",
    "path": "haxe\\std\\IntIterator.hx",
    "functions": {
      "hasNext": "Returns true if the iterator has other items, false otherwise.",
      "next": "Moves to the next item of the iterator.\n\n\tIf this is called while hasNext() is false, the result is unspecified."
    },
    "fields": {}
  },
  "Lambda": {
    "doc": "The `Lambda` class is a collection of methods to support functional\nprogramming. It is ideally used with `using Lambda` and then acts as an\nextension to Iterable types.\n\nOn static platforms, working with the Iterable structure might be slower\nthan performing the operations directly on known types, such as Array and\nList.\n\nIf the first argument to any of the methods is null, the result is\nunspecified.\n\n@see https://haxe.org/manual/std-Lambda.html",
    "path": "haxe\\std\\Lambda.hx",
    "functions": {
      "list": "Creates a List form Iterable `it`.\n\n\tIf `it` is a List, this function returns a copy of it.",
      "map": "Creates a new Array by applying function `f` to all elements of `it`.\n\tThe order of elements is preserved.\n\tIf `f` is null, the result is unspecified.",
      "mapi": "Similar to map, but also passes the index of each element to `f`.\n\tThe order of elements is preserved.\n\tIf `f` is null, the result is unspecified.",
      "flatten": "Concatenate a list of iterables.\n\tThe order of elements is preserved.",
      "flatMap": "A composition of map and flatten.\n\tThe order of elements is preserved.\n\tIf `f` is null, the result is unspecified.",
      "has": "Tells if `it` contains `elt`.\n\n\tThis function returns true as soon as an element is found which is equal\n\tto `elt` according to the `==` operator.\n\n\tIf no such element is found, the result is false.",
      "exists": "Tells if `it` contains an element for which `f` is true.\n\n\tThis function returns true as soon as an element is found for which a\n\tcall to `f` returns true.\n\n\tIf no such element is found, the result is false.\n\n\tIf `f` is null, the result is unspecified.",
      "foreach": "Tells if `f` is true for all elements of `it`.\n\n\tThis function returns false as soon as an element is found for which a\n\tcall to `f` returns false.\n\n\tIf no such element is found, the result is true.\n\n\tIn particular, this function always returns true if `it` is empty.\n\n\tIf `f` is null, the result is unspecified.",
      "iter": "Calls `f` on all elements of `it`, in order.\n\n\tIf `f` is null, the result is unspecified.",
      "filter": "Returns a Array containing those elements of `it` for which `f` returned\n\ttrue.\n\tIf `it` is empty, the result is the empty Array even if `f` is null.\n\tOtherwise if `f` is null, the result is unspecified.",
      "fold": "Functional fold on Iterable `it`, using function `f` with start argument\n\t`first`.\n\n\tIf `it` has no elements, the result is `first`.\n\n\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\tThe result of that call is then passed to `f` with the next element of\n\t`it`, and so on until `it` has no more elements.\n\n\tIf `it` or `f` are null, the result is unspecified.",
      "foldi": "Similar to fold, but also passes the index of each element to `f`.\n\n\tIf `it` or `f` are null, the result is unspecified.",
      "count": "Returns the number of elements in `it` for which `pred` is true, or the\n\ttotal number of elements in `it` if `pred` is null.\n\n\tThis function traverses all elements.",
      "empty": "Tells if Iterable `it` does not contain any element.",
      "indexOf": "Returns the index of the first element `v` within Iterable `it`.\n\n\tThis function uses operator `==` to check for equality.\n\n\tIf `v` does not exist in `it`, the result is -1.",
      "find": "Returns the first element of `it` for which `f` is true.\n\n\tThis function returns as soon as an element is found for which a call to\n\t`f` returns true.\n\n\tIf no such element is found, the result is null.\n\n\tIf `f` is null, the result is unspecified.",
      "findIndex": "Returns the index of the first element of `it` for which `f` is true.\n\n\tThis function returns as soon as an element is found for which a call to\n\t`f` returns true.\n\n\tIf no such element is found, the result is -1.\n\n\tIf `f` is null, the result is unspecified.",
      "concat": "Returns a new Array containing all elements of Iterable `a` followed by\n\tall elements of Iterable `b`.\n\n\tIf `a` or `b` are null, the result is unspecified."
    },
    "fields": {}
  },
  "Reflect": {
    "doc": "The Reflect API is a way to manipulate values dynamically through an\nabstract interface in an untyped manner. Use with care.\n\n@see https://haxe.org/manual/std-reflection.html",
    "path": "haxe\\std\\Reflect.hx",
    "functions": {
      "field": "Returns the value of the field named `field` on object `o`.\n\n\tIf `o` is not an object or has no field named `field`, the result is\n\tnull.\n\n\tIf the field is defined as a property, its accessors are ignored. Refer\n\tto `Reflect.getProperty` for a function supporting property accessors.\n\n\tIf `field` is null, the result is unspecified.",
      "setField": "Sets the field named `field` of object `o` to value `value`.\n\n\tIf `o` has no field named `field`, this function is only guaranteed to\n\twork for anonymous structures.\n\n\tIf `o` or `field` are null, the result is unspecified.",
      "getProperty": "Returns the value of the field named `field` on object `o`, taking\n\tproperty getter functions into account.\n\n\tIf the field is not a property, this function behaves like\n\t`Reflect.field`, but might be slower.\n\n\tIf `o` or `field` are null, the result is unspecified.",
      "setProperty": "Sets the field named `field` of object `o` to value `value`, taking\n\tproperty setter functions into account.\n\n\tIf the field is not a property, this function behaves like\n\t`Reflect.setField`, but might be slower.\n\n\tIf `field` is null, the result is unspecified.",
      "callMethod": "Call a method `func` with the given arguments `args`.\n\n\tThe object `o` is ignored in most cases. It serves as the `this`-context in the following\n\tsituations:\n\n(neko) Allows switching the context to `o` in all cases.\n(macro) Same as neko for Haxe 3. No context switching in Haxe 4.\n(js, lua) Require the `o` argument if `func` does not, but should have a context.\n\t\tThis can occur by accessing a function field natively, e.g. through `Reflect.field`\n\t\tor by using `(object : Dynamic).field`. However, if `func` has a context, `o` is\n\t\tignored like on other targets.",
      "fields": "Returns the fields of structure `o`.\n\n\tThis method is only guaranteed to work on anonymous structures. Refer to\n\t`Type.getInstanceFields` for a function supporting class instances.\n\n\tIf `o` is null, the result is unspecified.",
      "isFunction": "Returns true if `f` is a function, false otherwise.\n\n\tIf `f` is null, the result is false.",
      "compare": "Compares `a` and `b`.\n\n\tIf `a` is less than `b`, the result is negative. If `b` is less than\n\t`a`, the result is positive. If `a` and `b` are equal, the result is 0.\n\n\tThis function is only defined if `a` and `b` are of the same type.\n\n\tIf that type is a function, the result is unspecified and\n\t`Reflect.compareMethods` should be used instead.\n\n\tFor all other types, the result is 0 if `a` and `b` are equal. If they\n\tare not equal, the result depends on the type and is negative if:\n\n\t- Numeric types: a is less than b\n\t- String: a is lexicographically less than b\n\t- Other: unspecified\n\n\tIf `a` and `b` are null, the result is 0. If only one of them is null,\n\tthe result is unspecified.",
      "compareMethods": "Compares the functions `f1` and `f2`.\n\n\tIf `f1` or `f2` are null, the result is false.\n\tIf `f1` or `f2` are not functions, the result is unspecified.\n\n\tOtherwise the result is true if `f1` and the `f2` are physically equal,\n\tfalse otherwise.\n\n\tIf `f1` or `f2` are member method closures, the result is true if they\n\tare closures of the same method on the same object value, false otherwise.",
      "isObject": "Tells if `v` is an object.\n\n\tThe result is true if `v` is one of the following:\n\n\t- class instance\n\t- structure\n\t- `Class<T>`\n\t- `Enum<T>`\n\n\tOtherwise, including if `v` is null, the result is false.",
      "isEnumValue": "Tells if `v` is an enum value.\n\n\tThe result is true if `v` is of type EnumValue, i.e. an enum\n\tconstructor.\n\n\tOtherwise, including if `v` is null, the result is false.",
      "deleteField": "Removes the field named `field` from structure `o`.\n\n\tThis method is only guaranteed to work on anonymous structures.\n\n\tIf `o` or `field` are null, the result is unspecified.",
      "copy": "Copies the fields of structure `o`.\n\n\tThis is only guaranteed to work on anonymous structures.\n\n\tIf `o` is null, the result is `null`.",
      "makeVarArgs": "Transform a function taking an array of arguments into a function that can\n\tbe called with any number of arguments."
    },
    "fields": {}
  },
  "Std": {
    "doc": "The Std class provides standard methods for manipulating basic types.",
    "path": "haxe\\std\\Std.hx",
    "functions": {
      "isOfType": "Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.\n\n\tIf `t` is a class or interface with `@:generic` meta, the result is `false`.",
      "downcast": "Checks if object `value` is an instance of class or interface `c`.\n\n\tCompiles only if the type specified by `c` can be assigned to the type\n\tof `value`.\n\n\tThis method checks if a downcast is possible. That is, if the runtime\n\ttype of `value` is assignable to the type specified by `c`, `value` is\n\treturned. Otherwise null is returned.\n\n\tThis method is not guaranteed to work with core types such as `String`,\n\t`Array` and `Date`.\n\n\tIf `value` is null, the result is null. If `c` is null, the result is\n\tunspecified.",
      "string": "Converts any value to a String.\n\n\tIf `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.\n\n\tIf `s` is an instance of a class and that class or one of its parent classes has\n\ta `toString` method, that method is called. If no such method is present, the result\n\tis unspecified.\n\n\tIf `s` is an enum constructor without argument, the constructor's name is returned. If\n\targuments exists, the constructor's name followed by the String representations of\n\tthe arguments is returned.\n\n\tIf `s` is a structure, the field names along with their values are returned. The field order\n\tand the operator separating field names and values are unspecified.\n\n\tIf s is null, \"null\" is returned.",
      "int": "Converts a `Float` to an `Int`, rounded towards 0.\n\n\tIf `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.",
      "parseInt": "Converts a `String` to an `Int`.\n\n\tLeading whitespaces are ignored.\n\n\t`x` may optionally start with a + or - to denote a positive or negative value respectively.\n\n\tIf the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following\n\tdigits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.\n\n\tOtherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary\n\tnotations are not supported.\n\n\tParsing continues until an invalid character is detected, in which case the result up to\n\tthat point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.\n\n\tIf `x` is `null`, the result is `null`.\n\tIf `x` cannot be parsed as integer or is empty, the result is `null`.\n\n\tIf `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal\n\tdigit, the result is unspecified.",
      "parseFloat": "Converts a `String` to a `Float`.\n\n\tThe parsing rules for `parseInt` apply here as well, with the exception of invalid input\n\tresulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.\n\n\tAdditionally, decimal notation may contain a single `.` to denote the start of the fractions.\n\n\tIt may also end with `e` or `E` followed by optional minus or plus sign and a sequence of\n\tdigits (defines exponent to base 10).",
      "random": "Return a random integer between 0 included and `x` excluded.\n\n\tIf `x <= 1`, the result is always 0."
    },
    "fields": {}
  },
  "ArrayAccess": {
    "doc": "The standard `Void` type. Only `null` values can be of the type `Void`.\n\n@see https://haxe.org/manual/types-void.html\n*/\n#if jvm\n@:runtimeValue\n#end\n@:coreType abstract Void {}\n\n/**\nThe standard `Float` type, this is a double-precision IEEE 64bit float.\n\nOn static targets, `null` cannot be assigned to Float. If this is necessary,\n`Null<Float>` can be used instead.\n\n`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n`Std.parseFloat` converts a `String` to a `Float`.\n\n@see https://haxe.org/manual/types-basic-types.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0.0)\n@:coreType @:notNull @:runtimeValue abstract Float {}\n\n/**\nThe standard `Int` type. Its precision depends on the platform.\n\nOn static targets, `null` cannot be assigned to `Int`. If this is necessary,\n`Null<Int>` can be used instead.\n\n`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n`Std.parseInt` converts a `String` to an `Int`.\n\n@see https://haxe.org/manual/types-basic-types.html\n@see https://haxe.org/manual/std-math-integer-math.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0)\n@:coreType @:notNull @:runtimeValue abstract Int to Float {}\n\n#if (java || hl || cpp)\n/**\nSingle-precision IEEE 32bit float (4-byte).\n*/\n@:coreType @:notNull @:runtimeValue abstract Single to Float from Float {}\n#end\n\n/**\n`Null<T>` is a wrapper that can be used to make the basic types `Int`,\n`Float` and `Bool` nullable on static targets.\n\nIf null safety is enabled, only types wrapped in `Null<T>` are nullable.\n\nOtherwise, it has no effect on non-basic-types, but it can be useful as a way to document\nthat `null` is an acceptable value for a method argument, return value or variable.\n\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:forward\n@:coreType\nabstract Null<T> from T to T {}\n\n/**\nThe standard Boolean type, which can either be `true` or `false`.\n\nOn static targets, `null` cannot be assigned to `Bool`. If this is necessary,\n`Null<Bool>` can be used instead.\n\n@see https://haxe.org/manual/types-bool.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(false)\n@:coreType @:notNull @:runtimeValue abstract Bool {}\n\n/**\n`Dynamic` is a special type which is compatible with all other types.\n\nUse of `Dynamic` should be minimized as it prevents several compiler\nchecks and optimizations. See `Any` type for a safer alternative for\nrepresenting values of any type.\n\n@see https://haxe.org/manual/types-dynamic.html\n*/\n@:coreType @:runtimeValue abstract Dynamic<T> {}\n\n/**\nAn `Iterator` is a structure that permits iteration over elements of type `T`.\n\nAny class with matching `hasNext()` and `next()` fields is considered an `Iterator`\nand can then be used e.g. in `for`-loops. This makes it easy to implement\ncustom iterators.\n\n@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterator<T> = {\n/**\n\tReturns `false` if the iteration is complete, `true` otherwise.\n\n\tUsually iteration is considered to be complete if all elements of the\n\tunderlying data structure were handled through calls to `next()`. However,\n\tin custom iterators any logic may be used to determine the completion\n\tstate.\n*/\nfunction hasNext():Bool;\n\n/**\n\tReturns the current item of the `Iterator` and advances to the next one.\n\n\tThis method is not required to check `hasNext()` first. A call to this\n\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\tOn the other hand, iterators should not require a call to `hasNext()`\n\tbefore the first call to `next()` if an element is available.\n*/\nfunction next():T;\n}\n\n/**\nAn `Iterable` is a data structure which has an `iterator()` method.\nSee `Lambda` for generic functions on iterable structures.\n\n@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterable<T> = {\nfunction iterator():Iterator<T>;\n}\n\n/**\nA `KeyValueIterator` is an `Iterator` that has a key and a value.\n*/\ntypedef KeyValueIterator<K, V> = Iterator<{key:K, value:V}>;\n\n/**\nA `KeyValueIterable` is a data structure which has a `keyValueIterator()`\nmethod to iterate over key-value-pairs.\n*/\ntypedef KeyValueIterable<K, V> = {\nfunction keyValueIterator():KeyValueIterator<K, V>;\n}\n\n/**\n`ArrayAccess` is used to indicate a class that can be accessed using brackets.\nThe type parameter represents the type of the elements stored.\n\nThis interface should be used for externs only. Haxe does not support custom\narray access on classes. However, array access can be implemented for\nabstract types.\n\n@see https://haxe.org/manual/types-abstract-array-access.html",
    "path": "haxe\\std\\StdTypes.hx",
    "functions": {
      "next": "Returns the current item of the `Iterator` and advances to the next one.\n\n\tThis method is not required to check `hasNext()` first. A call to this\n\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\tOn the other hand, iterators should not require a call to `hasNext()`\n\tbefore the first call to `next()` if an element is available."
    },
    "fields": {}
  },
  "String": {
    "doc": "The basic String class.\n\nA Haxe String is immutable, it is not possible to modify individual\ncharacters. No method of this class changes the state of `this` String.\n\nStrings can be constructed using the String literal syntax `\"string value\"`.\n\nString can be concatenated by using the `+` operator. If an operand is not a\nString, it is passed through `Std.string()` first.\n\n@see https://haxe.org/manual/std-String.html",
    "path": "haxe\\std\\String.hx",
    "functions": {
      "toUpperCase": "Returns a String where all characters of `this` String are upper case.",
      "toLowerCase": "Returns a String where all characters of `this` String are lower case.",
      "charAt": "Returns the character at position `index` of `this` String.\n\n\tIf `index` is negative or exceeds `this.length`, the empty String `\"\"`\n\tis returned.",
      "charCodeAt": "Returns the character code at position `index` of `this` String.\n\n\tIf `index` is negative or exceeds `this.length`, `null` is returned.\n\n\tTo obtain the character code of a single character, `\"x\".code` can be\n\tused instead to inline the character code at compile time. Note that\n\tthis only works on String literals of length 1.",
      "indexOf": "Returns the position of the leftmost occurrence of `str` within `this` String.\n\n\tIf `str` is the empty String `\"\"`, then:\nIf `startIndex` is not specified or < 0, 0 is returned.\nIf `startIndex >= this.length`, `this.length` is returned.\nOtherwise, `startIndex` is returned,\n\n\tOtherwise, if `startIndex` is not specified or < 0, it is treated as 0.\n\n\tIf `startIndex >= this.length`, -1 is returned.\n\n\tOtherwise the search is performed within the substring of `this` String starting\n\tat `startIndex`. If `str` is found, the position of its first character in `this`\n\tString relative to position 0 is returned.\n\n\tIf `str` cannot be found, -1 is returned.",
      "lastIndexOf": "Returns the position of the rightmost occurrence of `str` within `this`\n\tString.\n\n\tIf `startIndex` is given, the search is performed within the substring\n\tof `this` String from 0 to `startIndex + str.length`. Otherwise the search\n\tis performed within `this` String. In either case, the returned position\n\tis relative to the beginning of `this` String.\n\n\tIf `startIndex` is negative, the result is unspecified.\n\n\tIf `str` cannot be found, -1 is returned.",
      "split": "Splits `this` String at each occurrence of `delimiter`.\n\n\tIf `this` String is the empty String `\"\"`, the result is not consistent\n\tacross targets and may either be `[]` (on Js, Cpp) or `[\"\"]`.\n\n\tIf `delimiter` is the empty String `\"\"`, `this` String is split into an\n\tArray of `this.length` elements, where the elements correspond to the\n\tcharacters of `this` String.\n\n\tIf `delimiter` is not found within `this` String, the result is an Array\n\twith one element, which equals `this` String.\n\n\tIf `delimiter` is null, the result is unspecified.\n\n\tOtherwise, `this` String is split into parts at each occurrence of\n\t`delimiter`. If `this` String starts (or ends) with `delimiter`, the\n\tresult `Array` contains a leading (or trailing) empty String `\"\"` element.\n\tTwo subsequent delimiters also result in an empty String `\"\"` element.",
      "substr": "Returns `len` characters of `this` String, starting at position `pos`.\n\n\tIf `len` is omitted, all characters from position `pos` to the end of\n\t`this` String are included.\n\n\tIf `pos` is negative, its value is calculated from the end of `this`\n\tString by `this.length + pos`. If this yields a negative value, 0 is\n\tused instead.\n\n\tIf the calculated position + `len` exceeds `this.length`, the characters\n\tfrom that position to the end of `this` String are returned.\n\n\tIf `len` is negative, the result is unspecified.",
      "substring": "Returns the part of `this` String from `startIndex` to but not including `endIndex`.\n\n\tIf `startIndex` or `endIndex` are negative, 0 is used instead.\n\n\tIf `startIndex` exceeds `endIndex`, they are swapped.\n\n\tIf the (possibly swapped) `endIndex` is omitted or exceeds\n\t`this.length`, `this.length` is used instead.\n\n\tIf the (possibly swapped) `startIndex` exceeds `this.length`, the empty\n\tString `\"\"` is returned.",
      "toString": "Returns the String itself."
    },
    "fields": {}
  },
  "StringBuf": {
    "doc": "A String buffer is an efficient way to build a big string by appending small\nelements together.\n\nUnlike String, an instance of StringBuf is not immutable in the sense that\nit can be passed as argument to functions which modify it by appending more\nvalues.",
    "path": "haxe\\std\\StringBuf.hx",
    "functions": {
      "add": "Appends the representation of `x` to `this` StringBuf.\n\n\tThe exact representation of `x` may vary per platform. To get more\n\tconsistent behavior, this function should be called with\n\tStd.string(x).\n\n\tIf `x` is null, the String \"null\" is appended.",
      "addChar": "Appends the character identified by `c` to `this` StringBuf.\n\n\tIf `c` is negative or has another invalid value, the result is\n\tunspecified.",
      "addSub": "Appends a substring of `s` to `this` StringBuf.\n\n\tThis function expects `pos` and `len` to describe a valid substring of\n\t`s`, or else the result is unspecified. To get more robust behavior,\n\t`this.add(s.substr(pos,len))` can be used instead.\n\n\tIf `s` or `pos` are null, the result is unspecified.\n\n\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\tof `s`.",
      "clear": "Removes all characters from `this` StringBuf, making it possible to reuse it.",
      "toString": "Returns the content of `this` StringBuf as String.\n\n\tThe buffer is not emptied by this operation."
    },
    "fields": {}
  },
  "StringTools": {
    "doc": "This class provides advanced methods on Strings. It is ideally used with\n`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\nto the `String` class.\n\nIf the first argument to any of the methods is null, the result is\nunspecified.",
    "path": "haxe\\std\\StringTools.hx",
    "functions": {
      "htmlUnescape": "Unescapes HTML special characters of the string `s`.\n\n\tThis is the inverse operation to htmlEscape, i.e. the following always\n\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\tThe replacements follow:\n\n\t- `&amp;` becomes `&`\n\t- `&lt;` becomes `<`\n\t- `&gt;` becomes `>`\n\t- `&quot;` becomes `\"`\n\t- `&#039;` becomes `'`",
      "contains": "Returns `true` if `s` contains `value` and  `false` otherwise.\n\n\tWhen `value` is `null`, the result is unspecified.",
      "isSpace": "Tells if the string `s` starts with the string `start`.\n\n\tIf `start` is `null`, the result is unspecified.\n\n\tIf `start` is the empty String `\"\"`, the result is true.\n*/\npublic static #if (java || python || (js && js_es >= 6)) inline #end function startsWith(s:String, start:String):Bool {\n\t#if java\n\treturn (cast s : java.NativeString).startsWith(start);\n\t#elseif hl\n\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n\t#elseif python\n\treturn python.NativeStringTools.startswith(s, start);\n\t#elseif (js && js_es >= 6)\n\treturn (cast s).startsWith(start);\n\t#elseif lua\n\treturn untyped __lua__(\"{0}:sub(1, #{1}) == {1}\", s, start);\n\t#else\n\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n\t#end\n}\n\n/**\n\tTells if the string `s` ends with the string `end`.\n\n\tIf `end` is `null`, the result is unspecified.\n\n\tIf `end` is the empty String `\"\"`, the result is true.\n*/\npublic static #if (java || python || (js && js_es >= 6)) inline #end function endsWith(s:String, end:String):Bool {\n\t#if java\n\treturn (cast s : java.NativeString).endsWith(end);\n\t#elseif hl\n\tvar elen = end.length;\n\tvar slen = s.length;\n\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t#elseif python\n\treturn python.NativeStringTools.endswith(s, end);\n\t#elseif (js && js_es >= 6)\n\treturn (cast s).endsWith(end);\n\t#elseif lua\n\treturn end == \"\" || untyped __lua__(\"{0}:sub(-#{1}) == {1}\", s, end);\n\t#else\n\tvar elen = end.length;\n\tvar slen = s.length;\n\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n\t#end\n}\n\n/**\n\tTells if the character in the string `s` at position `pos` is a space.\n\n\tA character is considered to be a space character if its character code\n\tis 9,10,11,12,13 or 32.\n\n\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t`s`, the result is false.",
      "ltrim": "Removes leading space characters of `s`.\n\n\tThis function internally calls `isSpace()` to decide which characters to\n\tremove.\n\n\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\tresult is the empty String `\"\"`.",
      "rtrim": "Removes trailing space characters of `s`.\n\n\tThis function internally calls `isSpace()` to decide which characters to\n\tremove.\n\n\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\tresult is the empty String `\"\"`.",
      "lpad": "Removes leading and trailing space characters of `s`.\n\n\tThis is a convenience function for `ltrim(rtrim(s))`.\n*/\npublic #if java inline #end static function trim(s:String):String {\n\t#if java\n\treturn (cast s : java.NativeString).trim();\n\t#else\n\treturn ltrim(rtrim(s));\n\t#end\n}\n\n/**\n\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t`s` is returned unchanged.\n\n\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\tOtherwise the length may exceed `l`.\n\n\tIf `c` is null, the result is unspecified.",
      "rpad": "Appends `c` to `s` until `s.length` is at least `l`.\n\n\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t`s` is returned unchanged.\n\n\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\tOtherwise the length may exceed `l`.\n\n\tIf `c` is null, the result is unspecified.",
      "replace": "Replace all occurrences of the String `sub` in the String `s` by the\n\tString `by`.\n\n\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\tremains unchanged.\n\n\tIf `sub` or `by` are null, the result is unspecified.",
      "hex": "Encodes `n` into a hexadecimal representation.\n\n\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\tits `length` equals `digits`.",
      "iterator": "Returns the character code at position `index` of String `s`, or an\n\tend-of-file indicator at if `position` equals `s.length`.\n\n\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\tthe result is unspecified if `index` is negative or greater than\n\t`s.length`.\n\n\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\tthe returned value as argument.\n\n\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\tcharacter.\n*/\npublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n\t#if neko\n\treturn untyped __dollar__sget(s.__s, index);\n\t#elseif cpp\n\treturn untyped s.cca(index);\n\t#elseif flash\n\treturn untyped s.cca(index);\n\t#elseif java\n\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n\t#elseif js\n\treturn js.lib.NativeStringTools.charCodeAt(s, index);\n\t#elseif python\n\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t#elseif hl\n\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t#elseif lua\n\t#if lua_vanilla\n\treturn lua.NativeStringTools.byte(s, index + 1);\n\t#else\n\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t#end\n\t#else\n\treturn untyped s.cca(index);\n\t#end\n}\n\n/**\n\tReturns the character code at position `index` of String `s`, or an\n\tend-of-file indicator at if `position` equals `s.length`.\n\n\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\tthe result is unspecified if `index` is negative or greater than\n\t`s.length`.\n\n\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\tcharacter.\n*/\npublic static #if !eval inline #end function unsafeCodeAt(s:String, index:Int):Int {\n\t#if neko\n\treturn untyped __dollar__sget(s.__s, index);\n\t#elseif cpp\n\treturn untyped s.cca(index);\n\t#elseif flash\n\treturn untyped s.cca(index);\n\t#elseif java\n\treturn cast(_charAt(s, index), Int);\n\t#elseif js\n\treturn js.lib.NativeStringTools.charCodeAt(s, index);\n\t#elseif python\n\treturn python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t#elseif hl\n\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t#elseif lua\n\t#if lua_vanilla\n\treturn lua.NativeStringTools.byte(s, index + 1);\n\t#else\n\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t#end\n\t#else\n\treturn untyped s.cca(index);\n\t#end\n}\n\n/**\n\tReturns an iterator of the char codes.\n\n\tNote that char codes may differ across platforms because of different\n\tinternal encoding of strings in different runtimes.\n\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.",
      "keyValueIterator": "Returns an iterator of the char indexes and codes.\n\n\tNote that char codes may differ across platforms because of different\n\tinternal encoding of strings in different of runtimes.\n\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.",
      "quoteUnixArg": "Tells if `c` represents the end-of-file (EOF) character.\n*/\n@:noUsing public static inline function isEof(c:Int):Bool {\n\t#if (flash || cpp || hl)\n\treturn c == 0;\n\t#elseif js\n\treturn c != c; // fast NaN\n\t#elseif (neko || lua || eval)\n\treturn c == null;\n\t#elseif (java || python)\n\treturn c == -1;\n\t#else\n\treturn false;\n\t#end\n}\n\n/**\n\tReturns a String that can be used as a single command line argument\n\ton Unix.\n\tThe input will be quoted, or escaped if necessary.",
      "quoteWinArg": "Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n*/\n@:noCompletion\n@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\npublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n/**\n\tReturns a String that can be used as a single command line argument\n\ton Windows.\n\tThe input will be quoted, or escaped if necessary, such that the output\n\twill be parsed as a single argument using the rule specified in\n\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\tExamples:\n\t```haxe\n\tquoteWinArg(\"abc\") == \"abc\";\n\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t```"
    },
    "fields": {}
  },
  "Type": {
    "doc": "The Haxe Reflection API allows retrieval of type information at runtime.\n\nThis class complements the more lightweight Reflect class, with a focus on\nclass and enum instances.\n\n@see https://haxe.org/manual/types.html\n@see https://haxe.org/manual/std-reflection.html",
    "path": "haxe\\std\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "ValueType": {
    "doc": "Returns the class of `o`, if `o` is a class instance.\n\n\tIf `o` is null or of a different type, null is returned.\n\n\tIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getClass<T>(o:T):Null<Class<T>>;\n\n/**\n\tReturns the enum of enum instance `o`.\n\n\tAn enum instance is the result of using an enum constructor. Given an\n\t`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\n\tIf `o` is null, null is returned.\n\n\tIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getEnum(o:EnumValue):Null<Enum<Dynamic>>;\n\n/**\n\tReturns the super-class of class `c`.\n\n\tIf `c` has no super class, null is returned.\n\n\tIf `c` is null, the result is unspecified.\n\n\tIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getSuperClass(c:Class<Dynamic>):Null<Class<Dynamic>>;\n\n/**\n\tReturns the name of class `c`, including its path.\n\n\tIf `c` is inside a package, the package structure is returned dot-\n\tseparated, with another dot separating the class name:\n\t`pack1.pack2.(...).packN.ClassName`\n\tIf `c` is a sub-type of a Haxe module, that module is not part of the\n\tpackage structure.\n\n\tIf `c` has no package, the class name is returned.\n\n\tIf `c` is null, the result is unspecified.\n\n\tThe class name does not include any type parameters.\n*/\nstatic function getClassName(c:Class<Dynamic>):String;\n\n/**\n\tReturns the name of enum `e`, including its path.\n\n\tIf `e` is inside a package, the package structure is returned dot-\n\tseparated, with another dot separating the enum name:\n\t`pack1.pack2.(...).packN.EnumName`\n\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\tpackage structure.\n\n\tIf `e` has no package, the enum name is returned.\n\n\tIf `e` is null, the result is unspecified.\n\n\tThe enum name does not include any type parameters.\n*/\nstatic function getEnumName(e:Enum<Dynamic>):String;\n\n/**\n\tResolves a class by name.\n\n\tIf `name` is the path of an existing class, that class is returned.\n\n\tOtherwise null is returned.\n\n\tIf `name` is null or the path to a different type, the result is\n\tunspecified.\n\n\tThe class name must not include any type parameters.\n*/\nstatic function resolveClass(name:String):Null<Class<Dynamic>>;\n\n/**\n\tResolves an enum by name.\n\n\tIf `name` is the path of an existing enum, that enum is returned.\n\n\tOtherwise null is returned.\n\n\tIf `name` is null the result is unspecified.\n\n\tIf `name` is the path to a different type, null is returned.\n\n\tThe enum name must not include any type parameters.\n*/\nstatic function resolveEnum(name:String):Null<Enum<Dynamic>>;\n\n/**\n\tCreates an instance of class `cl`, using `args` as arguments to the\n\tclass constructor.\n\n\tThis function guarantees that the class constructor is called.\n\n\tDefault values of constructors arguments are not guaranteed to be\n\ttaken into account.\n\n\tIf `cl` or `args` are null, or if the number of elements in `args` does\n\tnot match the expected number of constructor arguments, or if any\n\targument has an invalid type,  or if `cl` has no own constructor, the\n\tresult is unspecified.\n\n\tIn particular, default values of constructor arguments are not\n\tguaranteed to be taken into account.\n*/\nstatic function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T;\n\n/**\n\tCreates an instance of class `cl`.\n\n\tThis function guarantees that the class constructor is not called.\n\n\tIf `cl` is null, the result is unspecified.\n*/\nstatic function createEmptyInstance<T>(cl:Class<T>):T;\n\n/**\n\tCreates an instance of enum `e` by calling its constructor `constr` with\n\targuments `params`.\n\n\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.\n*/\nstatic function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T;\n\n/**\n\tCreates an instance of enum `e` by calling its constructor number\n\t`index` with arguments `params`.\n\n\tThe constructor indices are preserved from Haxe syntax, so the first\n\tdeclared is index 0, the next index 1 etc.\n\n\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.\n*/\nstatic function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T;\n\n/**\n\tReturns a list of the instance fields of class `c`, including\n\tinherited fields.\n\n\tThis only includes fields which are known at compile-time. In\n\tparticular, using `getInstanceFields(getClass(obj))` will not include\n\tany fields which were added to `obj` at runtime.\n\n\tThe order of the fields in the returned Array is unspecified.\n\n\tIf `c` is null, the result is unspecified.\n*/\nstatic function getInstanceFields(c:Class<Dynamic>):Array<String>;\n\n/**\n\tReturns a list of static fields of class `c`.\n\n\tThis does not include static fields of parent classes.\n\n\tThe order of the fields in the returned Array is unspecified.\n\n\tIf `c` is null, the result is unspecified.\n*/\nstatic function getClassFields(c:Class<Dynamic>):Array<String>;\n\n/**\n\tReturns a list of the names of all constructors of enum `e`.\n\n\tThe order of the constructor names in the returned Array is preserved\n\tfrom the original syntax.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic function getEnumConstructs(e:Enum<Dynamic>):Array<String>;\n\n/**\n\tReturns the runtime type of value `v`.\n\n\tThe result corresponds to the type `v` has at runtime, which may vary\n\tper platform. Assumptions regarding this should be minimized to avoid\n\tsurprises.\n*/\nstatic function typeof(v:Dynamic):ValueType;\n\n/**\n\tRecursively compares two enum instances `a` and `b` by value.\n\n\tUnlike `a == b`, this function performs a deep equality check on the\n\targuments of the constructors, if exists.\n\n\tIf `a` or `b` are null, the result is unspecified.\n*/\nstatic function enumEq<T:EnumValue>(a:T, b:T):Bool;\n\n/**\n\tReturns the constructor name of enum instance `e`.\n\n\tThe result String does not contain any constructor arguments.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic function enumConstructor(e:EnumValue):String;\n\n/**\n\tReturns a list of the constructor arguments of enum instance `e`.\n\n\tIf `e` has no arguments, the result is [].\n\n\tOtherwise the result are the values that were used as arguments to `e`,\n\tin the order of their declaration.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic function enumParameters(e:EnumValue):Array<Dynamic>;\n\n/**\n\tReturns the index of enum instance `e`.\n\n\tThis corresponds to the original syntactic position of `e`. The index of\n\tthe first declared constructor is 0, the next one is 1 etc.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic function enumIndex(e:EnumValue):Int;\n\n/**\n\tReturns a list of all constructors of enum `e` that require no\n\targuments.\n\n\tThis may return the empty Array `[]` if all constructors of `e` require\n\targuments.\n\n\tOtherwise an instance of `e` constructed through each of its non-\n\targument constructors is returned, in the order of the constructor\n\tdeclaration.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic function allEnums<T>(e:Enum<T>):Array<T>;\n}\n\n/**\nThe different possible runtime types of a value.",
    "path": "haxe\\std\\Type.hx",
    "functions": {
      "getEnum": "Returns the enum of enum instance `o`.\n\n\tAn enum instance is the result of using an enum constructor. Given an\n\t`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\n\tIf `o` is null, null is returned.\n\n\tIn general, type parameter information cannot be obtained at runtime.",
      "getSuperClass": "Returns the super-class of class `c`.\n\n\tIf `c` has no super class, null is returned.\n\n\tIf `c` is null, the result is unspecified.\n\n\tIn general, type parameter information cannot be obtained at runtime.",
      "getClassName": "Returns the name of class `c`, including its path.\n\n\tIf `c` is inside a package, the package structure is returned dot-\n\tseparated, with another dot separating the class name:\n\t`pack1.pack2.(...).packN.ClassName`\n\tIf `c` is a sub-type of a Haxe module, that module is not part of the\n\tpackage structure.\n\n\tIf `c` has no package, the class name is returned.\n\n\tIf `c` is null, the result is unspecified.\n\n\tThe class name does not include any type parameters.",
      "getEnumName": "Returns the name of enum `e`, including its path.\n\n\tIf `e` is inside a package, the package structure is returned dot-\n\tseparated, with another dot separating the enum name:\n\t`pack1.pack2.(...).packN.EnumName`\n\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\tpackage structure.\n\n\tIf `e` has no package, the enum name is returned.\n\n\tIf `e` is null, the result is unspecified.\n\n\tThe enum name does not include any type parameters.",
      "resolveClass": "Resolves a class by name.\n\n\tIf `name` is the path of an existing class, that class is returned.\n\n\tOtherwise null is returned.\n\n\tIf `name` is null or the path to a different type, the result is\n\tunspecified.\n\n\tThe class name must not include any type parameters.",
      "resolveEnum": "Resolves an enum by name.\n\n\tIf `name` is the path of an existing enum, that enum is returned.\n\n\tOtherwise null is returned.\n\n\tIf `name` is null the result is unspecified.\n\n\tIf `name` is the path to a different type, null is returned.\n\n\tThe enum name must not include any type parameters.",
      "createInstance": "Creates an instance of class `cl`, using `args` as arguments to the\n\tclass constructor.\n\n\tThis function guarantees that the class constructor is called.\n\n\tDefault values of constructors arguments are not guaranteed to be\n\ttaken into account.\n\n\tIf `cl` or `args` are null, or if the number of elements in `args` does\n\tnot match the expected number of constructor arguments, or if any\n\targument has an invalid type,  or if `cl` has no own constructor, the\n\tresult is unspecified.\n\n\tIn particular, default values of constructor arguments are not\n\tguaranteed to be taken into account.",
      "createEmptyInstance": "Creates an instance of class `cl`.\n\n\tThis function guarantees that the class constructor is not called.\n\n\tIf `cl` is null, the result is unspecified.",
      "createEnum": "Creates an instance of enum `e` by calling its constructor `constr` with\n\targuments `params`.\n\n\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.",
      "createEnumIndex": "Creates an instance of enum `e` by calling its constructor number\n\t`index` with arguments `params`.\n\n\tThe constructor indices are preserved from Haxe syntax, so the first\n\tdeclared is index 0, the next index 1 etc.\n\n\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.",
      "getInstanceFields": "Returns a list of the instance fields of class `c`, including\n\tinherited fields.\n\n\tThis only includes fields which are known at compile-time. In\n\tparticular, using `getInstanceFields(getClass(obj))` will not include\n\tany fields which were added to `obj` at runtime.\n\n\tThe order of the fields in the returned Array is unspecified.\n\n\tIf `c` is null, the result is unspecified.",
      "getClassFields": "Returns a list of static fields of class `c`.\n\n\tThis does not include static fields of parent classes.\n\n\tThe order of the fields in the returned Array is unspecified.\n\n\tIf `c` is null, the result is unspecified.",
      "getEnumConstructs": "Returns a list of the names of all constructors of enum `e`.\n\n\tThe order of the constructor names in the returned Array is preserved\n\tfrom the original syntax.\n\n\tIf `e` is null, the result is unspecified.",
      "typeof": "Returns the runtime type of value `v`.\n\n\tThe result corresponds to the type `v` has at runtime, which may vary\n\tper platform. Assumptions regarding this should be minimized to avoid\n\tsurprises.",
      "enumEq": "Recursively compares two enum instances `a` and `b` by value.\n\n\tUnlike `a == b`, this function performs a deep equality check on the\n\targuments of the constructors, if exists.\n\n\tIf `a` or `b` are null, the result is unspecified.",
      "enumConstructor": "Returns the constructor name of enum instance `e`.\n\n\tThe result String does not contain any constructor arguments.\n\n\tIf `e` is null, the result is unspecified.",
      "enumParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\n\tIf `e` has no arguments, the result is [].\n\n\tOtherwise the result are the values that were used as arguments to `e`,\n\tin the order of their declaration.\n\n\tIf `e` is null, the result is unspecified.",
      "enumIndex": "Returns the index of enum instance `e`.\n\n\tThis corresponds to the original syntactic position of `e`. The index of\n\tthe first declared constructor is 0, the next one is 1 etc.\n\n\tIf `e` is null, the result is unspecified.",
      "allEnums": "Returns a list of all constructors of enum `e` that require no\n\targuments.\n\n\tThis may return the empty Array `[]` if all constructors of `e` require\n\targuments.\n\n\tOtherwise an instance of `e` constructed through each of its non-\n\targument constructors is returned, in the order of the constructor\n\tdeclaration.\n\n\tIf `e` is null, the result is unspecified."
    },
    "fields": {}
  },
  "abstract": {
    "doc": "Xml node types.\n\n@see https://haxe.org/manual/std-Xml.html",
    "path": "haxe\\std\\Xml.hx",
    "functions": {},
    "fields": {}
  },
  "Xml": {
    "doc": "Represents an XML element type.\n*/\nvar Element = 0;\n\n/**\n\tRepresents XML parsed character data type.\n*/\nvar PCData = 1;\n\n/**\n\tRepresents XML character data type.\n*/\nvar CData = 2;\n\n/**\n\tRepresents an XML comment type.\n*/\nvar Comment = 3;\n\n/**\n\tRepresents an XML doctype element type.\n*/\nvar DocType = 4;\n\n/**\n\tRepresents an XML processing instruction type.\n*/\nvar ProcessingInstruction = 5;\n\n/**\n\tRepresents an XML document type.\n*/\nvar Document = 6;\n\npublic function toString():String {\n\treturn switch (cast this : XmlType) {\n\t\tcase Element: \"Element\";\n\t\tcase PCData: \"PCData\";\n\t\tcase CData: \"CData\";\n\t\tcase Comment: \"Comment\";\n\t\tcase DocType: \"DocType\";\n\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\tcase Document: \"Document\";\n\t};\n}\n}\n\n/**\nCross-platform Xml API.\n\n@see https://haxe.org/manual/std-Xml.html",
    "path": "haxe\\std\\Xml.hx",
    "functions": {
      "createElement": "Returns the type of the Xml Node. This should be used before\n\taccessing other functions since some might raise an exception\n\tif the node type is not correct.\n*/\npublic var nodeType(default, null):XmlType;\n\n/**\n\tReturns the node name of an Element.\n*/\n@:isVar public var nodeName(get, set):String;\n\n/**\n\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n@:isVar public var nodeValue(get, set):String;\n\n/**\n\tReturns the parent object in the Xml hierarchy.\n\tThe parent can be `null`, an Element or a Document.\n*/\npublic var parent(default, null):Null<Xml>;\n\nvar children:Array<Xml>;\nvar attributeMap:Map<String, String>;\n\n#if !cppia inline #end function get_nodeName() {\n\tif (nodeType != Element) {\n\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t}\n\treturn nodeName;\n}\n\n#if !cppia inline #end function set_nodeName(v) {\n\tif (nodeType != Element) {\n\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t}\n\treturn this.nodeName = v;\n}\n\n#if !cppia inline #end function get_nodeValue() {\n\tif (nodeType == Document || nodeType == Element) {\n\t\tthrow 'Bad node type, unexpected $nodeType';\n\t}\n\treturn nodeValue;\n}\n\n#if !cppia inline #end function set_nodeValue(v) {\n\tif (nodeType == Document || nodeType == Element) {\n\t\tthrow 'Bad node type, unexpected $nodeType';\n\t}\n\treturn this.nodeValue = v;\n}\n\n/**\n\tCreates a node of the given type.",
      "createPCData": "Creates a node of the given type.",
      "createCData": "Creates a node of the given type.",
      "createComment": "Creates a node of the given type.",
      "createDocType": "Creates a node of the given type.",
      "createProcessingInstruction": "Creates a node of the given type.",
      "createDocument": "Creates a node of the given type.",
      "get": "Get the given attribute of an Element node. Returns `null` if not found.\n\tAttributes are case-sensitive.",
      "set": "Set the given attribute value for an Element node.\n\tAttributes are case-sensitive.",
      "remove": "Removes an attribute for an Element node.\n\tAttributes are case-sensitive.",
      "exists": "Tells if the Element node has a given attribute.\n\tAttributes are case-sensitive.",
      "attributes": "Returns an `Iterator` on all the attribute names.",
      "elements": "Returns an iterator of all child nodes.\n\tOnly works if the current node is an Element or a Document.\n*/\npublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\tensureElementType();\n\treturn children.iterator();\n}\n\n/**\n\tReturns an iterator of all child nodes which are Elements.\n\tOnly works if the current node is an Element or a Document.",
      "elementsNamed": "Returns an iterator of all child nodes which are Elements with the given nodeName.\n\tOnly works if the current node is an Element or a Document.",
      "firstElement": "Returns the first child node.\n*/\npublic #if !cppia inline #end function firstChild():Xml {\n\tensureElementType();\n\treturn children[0];\n}\n\n/**\n\tReturns the first child node which is an Element.",
      "addChild": "Adds a child node to the Document or Element.\n\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\tIf the child node was previously inside a different node, it will be moved to this Document or Element.",
      "removeChild": "Removes a child from the Document or Element.\n\tReturns true if the child was successfully removed.",
      "insertChild": "Inserts a child at the given position among the other childs.\n\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\tIf the child node was previously inside a different node, it will be moved to this Document or Element."
    },
    "fields": {
      "PCData": "XML parsed character data type.",
      "CData": "XML character data type.",
      "Comment": "XML comment type.",
      "DocType": "XML doctype element type.",
      "ProcessingInstruction": "XML processing instruction type.",
      "Document": "XML document type.",
      "Element": "Cross-platform Xml API.\n\n@see https://haxe.org/manual/std-Xml.html\n*/\nclass Xml {\n/**\n\tXML element type.",
      "nodeType": "Parses the String into an Xml document.\n*/\nstatic public function parse(str:String):Xml {\n\treturn haxe.xml.Parser.parse(str);\n}\n\n/**\n\tReturns the type of the Xml Node. This should be used before\n\taccessing other functions since some might raise an exception\n\tif the node type is not correct.",
      "parent": "Returns the node name of an Element.\n*/\n@:isVar public var nodeName(get, set):String;\n\n/**\n\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n@:isVar public var nodeValue(get, set):String;\n\n/**\n\tReturns the parent object in the Xml hierarchy.\n\tThe parent can be `null`, an Element or a Document."
    }
  },
  "cpp.Finalizable": {
    "doc": "This is just a helper class. It is not actually required to inherit from this\nto use `NativeGc.addFinalizable(this,inPin)`, only a function called\n`finalize` is needed.",
    "path": "haxe\\std\\cpp\\Finalizable.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.Lib": {
    "doc": "Platform-specific Cpp Library. Provides some platform-specific functions\nfor the C++ target, such as conversion from Haxe types to native types\nand vice-versa.",
    "path": "haxe\\std\\cpp\\Lib.hx",
    "functions": {
      "unloadAllLibraries": "Unloaded all dynamic libraries in reverse order of loading.\n\tReturns the number of libraries unloaded.",
      "loadLazy": "Tries to load, and always returns a valid function, but the function may throw\n\tif called.",
      "bytesReference": "Returns bytes referencing the content of a string.\n\tUse with extreme caution - changing constant strings will crash.\n\tChanging one string can cause others to change unexpectedly.\n\tOnly really safe if you are using it read-only or if it comes from stringReference above",
      "print": "Print the specified value on the default output.",
      "haxeToNeko": "This function is used to make porting from neko to cpp easy.\n\tIt does not need to do anything because the c-code can work with any Dynamic",
      "nekoToHaxe": "This function is used to make porting from neko to cpp easy.\n\tIt does not need to do anything because the c-code can work with any Dynamic",
      "println": "Print the specified value on the default output followed by a newline character."
    },
    "fields": {}
  },
  "cpp.net.Poll": {
    "doc": "A wrapper around native socket polling functionality for monitoring multiple sockets for I/O readiness.\nThis class provides a high-level abstraction over native `poll` operations, allowing you to monitor sockets for read and write events.",
    "path": "haxe\\std\\cpp\\net\\Poll.hx",
    "functions": {
      "prepare": "Prepares the poll structure for monitoring read and write events on the given sockets.\n\n@param read  An array of sockets to monitor for readability.\n@param write An array of sockets to monitor for writability.",
      "events": "Waits for events on the prepared sockets.\n\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.",
      "poll": "Polls the given sockets for any events (e.g., readability or writability).\n\n@param a An array of sockets to monitor for events.\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.\n@return An array of sockets that are ready for I/O operations."
    },
    "fields": {
      "writeIndexes": "An array of indices corresponding to sockets ready for writing after polling."
    }
  },
  "cpp.net.ThreadServer": {
    "doc": "The ThreadServer can be used to easily create a multithreaded server where each thread polls multiple connections.\nTo use it, at a minimum you must override or rebind clientConnected, readClientMessage, and clientMessage and you must define your Client and Message.",
    "path": "haxe\\std\\cpp\\net\\ThreadServer.hx",
    "functions": {
      "work": "Internally used to delegate something to the worker thread.",
      "addSocket": "Called when the server gets a new connection.",
      "run": "Start the server at the specified host and port.",
      "sendData": "Send data to a client.",
      "stopClient": "Shutdown a client's connection and remove them from the server."
    },
    "fields": {
      "nthreads": "Number of server threads.",
      "connectLag": "Polling timeout.",
      "errorOutput": "Stream to send error messages.",
      "initialBufferSize": "Space allocated to buffers when they are created.",
      "maxBufferSize": "Maximum size of buffered data read from a socket. An exception is thrown if the buffer exceeds this value.",
      "messageHeaderSize": "Minimum message size.",
      "updateTime": "Time between calls to update.",
      "maxSockPerThread": "The most sockets a thread will handle."
    }
  },
  "cpp.rtti.FieldIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\nallows fast dynamic access to fields by integer id.  This should speed up the CFFI.",
    "path": "haxe\\std\\cpp\\rtti\\FieldIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.rtti.FieldNumericIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\nallows fast numeric access to fields by integer id.  This should speed up the CFFI.",
    "path": "haxe\\std\\cpp\\rtti\\FieldNumericIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Parameter": {
    "doc": "Parameter describes a function parameter. Instances of this class are\nembedded in stack frame objects to describe the function parameters that\nwere used in the invocation of the function that defines that stack frame.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.StackFrame": {
    "doc": "`StackFrame` describes one call stack frame.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.ThreadInfo": {
    "doc": "`ThreadInfo` describes the state of a single thread.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Debugger": {
    "doc": "0 is never a valid thread number **/\npublic var number(default, null):Int;\n\npublic var status(default, null):Int;\n\n/** If status is \"stopped breakpoint\", this is the breakpoint number **/\npublic var breakpoint(default, null):Int;\n\n/** If status is \"critical error\", this describes the error **/\npublic var criticalErrorDescription(default, null):String;\n\n/** Stack will be listed with the lowest frame first **/\npublic var stack(default, null):Array<StackFrame>;\n\npublic function new(number:Int, status:Int, breakpoint:Int = -1, criticalErrorDescription:String = null) {\n\tthis.number = number;\n\tthis.status = status;\n\tthis.breakpoint = breakpoint;\n\tthis.criticalErrorDescription = criticalErrorDescription;\n\tthis.stack = new Array<StackFrame>();\n}\n}\n\n/**\nThis class wraps the hxcpp C++ implementation to provide a Haxe interface\nto the low level debugging features",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {
      "enableCurrentThreadDebugging": "This can be called to turn off (and then back on) all stopping of\n\tdebugged threads temporarily. It should only be used by classes that\n\tactually implement the debugger to hide themselves from the debugger as\n\tnecessary.",
      "getCurrentThreadNumber": "Returns the thread number of the calling thread.\n\n\t@return the thread number of the calling thread.",
      "getFiles": "Returns the set of source files known to the debugger. This is a copy\n\tof the original array and could be quite large. The caller should\n\tcache this value to avoid multiple copies needing to be made.\n\n\t@return the set of source files known to the debugger.",
      "getFilesFullPath": "Returns the full paths of the set of source files known to the debugger.\n\tThis is a copy of the original array and could be quite large.\n\tIt is possible that this set will be empty, in which case the full paths are not known.\n\tThe index of these files matches the index from `getFiles()`, so the full path for\n\ta given short path can be calculated.\n\n\t@return the known full paths of the set of source files",
      "getClasses": "Returns the set of class names of all classes known to the debugger.\n\tThis is a copy of the original array and could be quite large. The\n\tcaller should cache this value to avoid multiple copies needing to be\n\tmade.\n\n\t@return the set of class names of all classes known to the debugger.",
      "getThreadInfos": "Returns a `ThreadInfo` object describing every thread that existed at the\n\tmoment that the call was made, except for the debugger thread.",
      "getThreadInfo": "Returns a `ThreadInfo` object describing a single thread, or `null` if\n\tthere is no such thread or the thread queried about was the debugger\n\tthread and `unsafe` was not `true`.",
      "addFileLineBreakpoint": "Adds a new `file:line` breakpoint. The breakpoint number of the newly\n\tadded breakpoint is returned.",
      "addClassFunctionBreakpoint": "Adds a new `class:function` breakpoint. The breakpoint number of the\n\tnewly added breakpoint is returned.",
      "deleteBreakpoint": "Deletes a breakpoint, or all breakpoints.",
      "breakNow": "Breaks all threads except the debugger thread (which should be the same\n\tas the calling thread!).\n\n\tIf `wait` is `true`, waits up to 2 seconds for all threads to be broken.\n\tThreads which are in blocking system calls and cannot break after 2\n\tseconds remain running when this function returns.",
      "continueThreads": "Continue execution of all stopped threads. If `specialThreadNumber`\n\tis a valid thread number, then it will be continued past\n\t`continueCount` breakpoints instead of just 1 like all of the other\n\tthreads.",
      "stepThread": "Single steps the given thread.",
      "getStackVariables": "Returns the list of local variables (including `this`, function\n\targuments, and local variables) visible to the given thread at the\n\tgiven stack frame.\n\n\tReturns a list with a single entry, `THREAD_NOT_STOPPED`, if the\n\tthread is not stopped and thus variables cannot be fetched and\n\t`unsafe` is not `true`.\n\n\t@return the list of local variables (including `this`, function\n\t\t\targuments, and local variables) visible to the given thread at\n\t\t\tthe given stack frame.",
      "getStackVariableValue": "Returns the value of a stack variable, or `NONEXISTENT_VALUE` if the\n\trequested value does not exist.  If the thread is actively running\n\tand `unsafe` is not `true`, returns `THREAD_NOT_STOPPED`.",
      "setStackVariableValue": "Sets the value of a stack variable and returns that value. If the\n\tvariable does not exist, on the stack, this function returns\n\t`NONEXISTENT_VALUE`. If the thread is actively running and `unsafe` is not\n\t`true`, returns `THREAD_NOT_STOPPED`, and the value is not set.",
      "setOnScriptLoadedFunction": "Sets the callback to run whenever a new CPPIA script is loaded.\n\n\tThis can be helpful for adding breakpoints to a script."
    },
    "fields": {
      "breakpoint": "If status is \"stopped breakpoint\", this is the breakpoint number *",
      "criticalErrorDescription": "If status is \"critical error\", this describes the error *",
      "stack": "Stack will be listed with the lowest frame first *",
      "NONEXISTENT_VALUE": "This class wraps the hxcpp C++ implementation to provide a Haxe interface\nto the low level debugging features\n*/\nclass Debugger {\npublic static inline var THREAD_CREATED = 1;\npublic static inline var THREAD_TERMINATED = 2;\npublic static inline var THREAD_STARTED = 3;\npublic static inline var THREAD_STOPPED = 4;\n\npublic static inline var STEP_INTO = 1;\npublic static inline var STEP_OVER = 2;\npublic static inline var STEP_OUT = 3;\n\n/**\n\tThis tagging value is returned by `getStackVariableValue()` and\n\t`setStackVariableValue()` if the requested value does not exist at the\n\trequested stack frame",
      "THREAD_NOT_STOPPED": "This tagging value is returned by `getStackVariableValue()` and\n\t`setStackVariableValue()` if the stack variable that is being set is on a\n\tthread that is running, in which case the set does not take place."
    }
  },
  "eval.luv.DirSync": {
    "doc": "Retrieves the next directory entry.\n*/\nfunction next():Null<Dirent>;\n\n/**\n\tCleans up after a directory scan.\n*/\nfunction end():Void;\n}\n\n/**\n@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n/**\n\tOpens the directory at the given path for listing.\n*/\nstatic public function open(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Dir>)->Void):Void;\n\n/**\n\tCloses the directory.\n*/\npublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tRetrieves a directory entry.\n*/\npublic function read(loop:Loop, ?numberOfEntries:Int, ?request:FileRequest, callback:(result:Result<Array<Dirent>>)->Void):Void;\n\n/**\n\tBegins directory listing.\n*/\nstatic public function scan(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<DirectoryScan>)->Void):Void;\n}\n\n/**\nSynchronous version of `eval.luv.Dir` API",
    "path": "haxe\\std\\eval\\luv\\Dir.hx",
    "functions": {
      "end": "Cleans up after a directory scan.",
      "open": "@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n/**\n\tOpens the directory at the given path for listing.",
      "close": "Closes the directory.",
      "read": "Retrieves a directory entry.",
      "scan": "Begins directory listing."
    },
    "fields": {}
  },
  "eval.luv.Dns": {
    "doc": "DNS queries.\n\n@see https://aantron.github.io/luv/luv/Luv/Dns",
    "path": "haxe\\std\\eval\\luv\\Dns.hx",
    "functions": {
      "getNameInfo": "Retrieves host names."
    },
    "fields": {}
  },
  "eval.luv.Env": {
    "doc": "Environment variables.\n\n@see https://aantron.github.io/luv/luv/Luv/Env",
    "path": "haxe\\std\\eval\\luv\\Env.hx",
    "functions": {
      "setEnv": "Sets an environment variable.",
      "unsetEnv": "Deletes an environment variable.",
      "environ": "Retrieves all environment variables."
    },
    "fields": {}
  },
  "eval.luv.FileMode": {
    "doc": "Permission bits.\n@see https://aantron.github.io/luv/luv/Luv/File/Mode",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.FileSync": {
    "doc": "Abstract type for a bit field of permissions bits, i.e., an `int` in which\nmultiple bits may be set. These bit fields are returned by operations such\nas `eval.luv.File.stat`\n*/\n@:coreType abstract FileModeNumeric {}\n\ntypedef FileStatTimeSpec = {\nvar sec:Int64;\nvar nsec:Int64;\n}\n\ntypedef FileStat = {\nvar dev:UInt64;\nvar mode:FileModeNumeric;\nvar nlink:UInt64;\nvar uid:UInt64;\nvar gid:UInt64;\nvar rdev:UInt64;\nvar ino:UInt64;\nvar size:UInt64;\nvar blksize:UInt64;\nvar blocks:UInt64;\nvar flags:UInt64;\nvar gen:UInt64;\nvar atim:FileStatTimeSpec;\nvar mtim:FileStatTimeSpec;\nvar ctim:FileStatTimeSpec;\nvar birthtim:FileStatTimeSpec;\n}\n\ntypedef FileStatFs = {\nvar type:UInt64;\nvar bsize:UInt64;\nvar blocks:UInt64;\nvar bfree:UInt64;\nvar bavail:UInt64;\nvar files:UInt64;\nvar ffree:UInt64;\nvar fspare:Array<UInt64>;\n}\n\nenum abstract FileCopyFlag(Int) {\nvar COPYFILE_EXCL = 0;\nvar COPYFILE_FICLONE = 1;\nvar COPYFILE_FICLONE_FORCE = 2;\n}\n\nenum abstract FileAccessFlag(Int) {\nvar F_OK = 0;\nvar R_OK = 1;\nvar W_OK = 2;\nvar X_OK = 3;\n}\n\nenum abstract FileSymlinkFlag(Int) {\nvar SYMLINK_DIR = 0;\nvar SYMLINK_JUNCTION = 1;\n}\n\n/**\nFiles.\n\n@see https://aantron.github.io/luv/luv/Luv/File\n*/\n@:using(eval.luv.Handle)\n@:coreType abstract File to Handle {\n\nextern static public final stdin:File;\nextern static public final stdout:File;\nextern static public final stderr:File;\n\nstatic public function createRequest():FileRequest;\n\n/**\n\tChecks whether all the bits in `mask` are set in `bits`.\n\n\tFor example, if `bits` is equal to octal 0o644, then\n\t`eval.luv.File.testMode [IRUSR] bits` evaluates to `true`.\n*/\nstatic public function testMode(mask:Array<FileMode>, bits:FileModeNumeric):Bool;\n\n/**\n\tOpens the file at the given path.\n\tThe default value of the `mode` argument is equal to octal `0o644`.\n*/\nstatic public function open(loop:Loop, path:NativeString, flags:Array<FileOpenFlag>, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<File>)->Void):Void;\n\n/**\n\tCloses the file.\n*/\npublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tReads from the file.\n\n\tThe incoming data is written consecutively to into the given buffers.\n\tThe number of bytes that the operation tries to read is the total length\n\tof the buffers.\n\n\tEnd of file is indicated by `Result.Ok(0)`. Note that this is different\n\tfrom `eval.luv.Stream.readStart`.\n*/\npublic function read(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\n\tWrites to the file.\n*/\npublic function write(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\n\tDeletes the file at the given path.\n*/\nstatic public function unlink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tMoves the file at the given path to the path given by `toPath`\n*/\nstatic public function rename(loop:Loop, path:NativeString, toPath:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tCreates a temporary file with name based on the given pattern.\n*/\nstatic public function mkstemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<{name:NativeString,file:File}>)->Void):Void;\n\n/**\n\tCreates a temporary directory with name based on the given pattern.\n*/\nstatic public function mkdtemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\n\tCreates a directory.\n*/\nstatic public function mkdir(loop:Loop, path:NativeString, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tDeletes a directory.\n*/\nstatic public function rmdir(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tRetrieves status information for the file at the given path.\n*/\nstatic public function stat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\n\tLike `eval.luv.File.stat`, but does not dereference symlinks.\n*/\nstatic public function lstat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\n\tRetrieves status information for this file.\n*/\npublic function fstat(loop:Loop, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\n\tRetrieves status information for the filesystem containing the given path.\n*/\nstatic public function statFs(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStatFs>)->Void):Void;\n\n/**\n\tFlushes file changes to storage.\n*/\npublic function fsync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tLike `eval.luv.File.fsync`, but may omit some metadata.\n*/\npublic function fdataSync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tTruncates the given file to the given length.\n*/\npublic function ftruncate(loop:Loop, length:Int64, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tCopies the file at the given path to the path given by `toPath`.\n*/\nstatic public function copyFile(loop:Loop, path:NativeString, toPath:NativeString, ?flags:Array<FileCopyFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tTransfers data between file descriptors.\n*/\npublic function sendFile(loop:Loop, toFile:File, offset:Int64, length:UInt64, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\n\tChecks whether the calling process can access the file at the given path.\n*/\nstatic public function access(loop:Loop, path:NativeString, flags:Array<FileAccessFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tChanges permissions of the file at the given path.\n*/\nstatic public function chmod(loop:Loop, path:NativeString, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tChanges permissions of the file.\n*/\npublic function fchmod(loop:Loop, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tSets timestamps of the file at the given path.\n*/\nstatic public function utime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tSets timestamps of the file.\n*/\npublic function futime(loop:Loop, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tSets timestamps of the file at the given path without dereferencing symlinks.\n*/\nstatic public function lutime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tHardlinks a file at the location given by `link`.\n*/\nstatic public function link(loop:Loop, path:NativeString, link:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tSymlinks a file at the location given by `link`.\n*/\nstatic public function symlink(loop:Loop, path:NativeString, link:NativeString, ?flags:Array<FileSymlinkFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tReads the target path of a symlink.\n*/\nstatic public function readLink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\n\tResolves a real absolute path to the given file.\n*/\nstatic public function realPath(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\n\tChanges ownership of the file at the given path.\n*/\nstatic public function chown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tChanges ownership of the file at the given path. without dereferencing symlinks.\n*/\nstatic public function lchown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tChanges ownership of the file.\n*/\npublic function fchown(loop:Loop, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\n\tReturns the integer representation of `eval.luv.File`.\n\n\t`eval.luv.File` is defined as an integer file descriptor by libuv on all\n\tplatforms at the moment. This is a convenience function for interoperability\n\twith `eval.luv.Process`, the API of which assumes that files are represented\n\tby integers.\n*/\npublic function toInt():Int;\n}\n\n/**\nSynchronous version of `eval.luv.File` API",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {
      "open": "Opens the file at the given path.\n\tThe default value of the `mode` argument is equal to octal `0o644`.",
      "close": "Closes the file.",
      "read": "Reads from the file.\n\n\tThe incoming data is written consecutively to into the given buffers.\n\tThe number of bytes that the operation tries to read is the total length\n\tof the buffers.\n\n\tEnd of file is indicated by `Result.Ok(0)`. Note that this is different\n\tfrom `eval.luv.Stream.readStart`.",
      "write": "Writes to the file.",
      "unlink": "Deletes the file at the given path.",
      "rename": "Moves the file at the given path to the path given by `toPath`",
      "mkstemp": "Creates a temporary file with name based on the given pattern.",
      "mkdtemp": "Creates a temporary directory with name based on the given pattern.",
      "mkdir": "Creates a directory.",
      "rmdir": "Deletes a directory.",
      "stat": "Retrieves status information for the file at the given path.",
      "lstat": "Like `eval.luv.File.stat`, but does not dereference symlinks.",
      "fstat": "Retrieves status information for this file.",
      "statFs": "Retrieves status information for the filesystem containing the given path.",
      "fsync": "Flushes file changes to storage.",
      "fdataSync": "Like `eval.luv.File.fsync`, but may omit some metadata.",
      "ftruncate": "Truncates the given file to the given length.",
      "copyFile": "Copies the file at the given path to the path given by `toPath`.",
      "sendFile": "Transfers data between file descriptors.",
      "access": "Checks whether the calling process can access the file at the given path.",
      "chmod": "Changes permissions of the file at the given path.",
      "fchmod": "Changes permissions of the file.",
      "utime": "Sets timestamps of the file at the given path.",
      "futime": "Sets timestamps of the file.",
      "lutime": "Sets timestamps of the file at the given path without dereferencing symlinks.",
      "link": "Hardlinks a file at the location given by `link`.",
      "symlink": "Symlinks a file at the location given by `link`.",
      "readLink": "Reads the target path of a symlink.",
      "realPath": "Resolves a real absolute path to the given file.",
      "chown": "Changes ownership of the file at the given path.",
      "lchown": "Changes ownership of the file at the given path. without dereferencing symlinks.",
      "fchown": "Changes ownership of the file.",
      "toInt": "Returns the integer representation of `eval.luv.File`.\n\n\t`eval.luv.File` is defined as an integer file descriptor by libuv on all\n\tplatforms at the moment. This is a convenience function for interoperability\n\twith `eval.luv.Process`, the API of which assumes that files are represented\n\tby integers."
    },
    "fields": {}
  },
  "eval.luv.abstract": {
    "doc": "Error handling.\n\n@see https://aantron.github.io/luv/luv/Luv/Error",
    "path": "haxe\\std\\eval\\luv\\UVError.hx",
    "functions": {},
    "fields": {
      "UV_EACCES": "permission denied",
      "UV_EADDRINUSE": "address already in use",
      "UV_EADDRNOTAVAIL": "address not available",
      "UV_EAFNOSUPPORT": "address family not supported",
      "UV_EAGAIN": "resource temporarily unavailable",
      "UV_EAI_ADDRFAMILY": "address family not supported",
      "UV_EAI_AGAIN": "temporary failure",
      "UV_EAI_BADFLAGS": "bad ai_flags value",
      "UV_EAI_BADHINTS": "invalid value for hints",
      "UV_EAI_CANCELED": "request canceled",
      "UV_EAI_FAIL": "permanent failure",
      "UV_EAI_FAMILY": "ai_family not supported",
      "UV_EAI_MEMORY": "out of memory",
      "UV_EAI_NODATA": "no address",
      "UV_EAI_NONAME": "unknown node or service",
      "UV_EAI_OVERFLOW": "argument buffer overflow",
      "UV_EAI_PROTOCOL": "resolved protocol is unknown",
      "UV_EAI_SERVICE": "service not available for socket type",
      "UV_EAI_SOCKTYPE": "socket type not supported",
      "UV_EALREADY": "connection already in progress",
      "UV_EBADF": "bad file descriptor",
      "UV_EBUSY": "resource busy or locked",
      "UV_ECANCELED": "operation canceled",
      "UV_ECONNABORTED": "invalid Unicode character */\n// var UV_ECHARSET = 24; // not defined in Luv ocaml library\n/** software caused connection abort",
      "UV_ECONNREFUSED": "connection refused",
      "UV_ECONNRESET": "connection reset by peer",
      "UV_EDESTADDRREQ": "destination address required",
      "UV_EEXIST": "file already exists",
      "UV_EFAULT": "bad address in system call argument",
      "UV_EFBIG": "file too large",
      "UV_EHOSTUNREACH": "host is unreachable",
      "UV_EINTR": "interrupted system call",
      "UV_EINVAL": "invalid argument",
      "UV_EIO": "i/o error",
      "UV_EISCONN": "socket is already connected",
      "UV_EISDIR": "illegal operation on a directory",
      "UV_ELOOP": "too many symbolic links encountered",
      "UV_EMFILE": "too many open files",
      "UV_EMSGSIZE": "message too long",
      "UV_ENAMETOOLONG": "name too long",
      "UV_ENETDOWN": "network is down",
      "UV_ENETUNREACH": "network is unreachable",
      "UV_ENFILE": "file table overflow",
      "UV_ENOBUFS": "no buffer space available",
      "UV_ENODEV": "no such device",
      "UV_ENOENT": "no such file or directory",
      "UV_ENOMEM": "not enough memory",
      "UV_ENONET": "machine is not on the network",
      "UV_ENOPROTOOPT": "protocol not available",
      "UV_ENOSPC": "no space left on device",
      "UV_ENOSYS": "function not implemented",
      "UV_ENOTCONN": "socket is not connected",
      "UV_ENOTDIR": "not a directory",
      "UV_ENOTEMPTY": "directory not empty",
      "UV_ENOTSOCK": "socket operation on non-socket",
      "UV_ENOTSUP": "operation not supported on socket",
      "UV_EPERM": "operation not permitted",
      "UV_EPIPE": "broken pipe",
      "UV_EPROTO": "protocol error",
      "UV_EPROTONOSUPPORT": "protocol not supported",
      "UV_EPROTOTYPE": "protocol wrong type for socket",
      "UV_ERANGE": "result too large",
      "UV_EROFS": "read-only file system",
      "UV_ESHUTDOWN": "cannot send after transport endpoint shutdown",
      "UV_ESPIPE": "invalid seek",
      "UV_ESRCH": "no such process",
      "UV_ETIMEDOUT": "connection timed out",
      "UV_ETXTBSY": "text file is busy",
      "UV_EXDEV": "cross-device link not permitted",
      "UV_UNKNOWN": "unknown error",
      "UV_EOF": "end of file",
      "UV_ENXIO": "no such device or address",
      "UV_EMLINK": "too many links",
      "UV_ENOTTY": "inappropriate ioctl for device",
      "UV_EFTYPE": "inappropriate file type or format",
      "UV_EILSEQ": "illegal byte sequence",
      "UV_EOVERFLOW": "value too large for defined data type *",
      "UV_ESOCKTNOSUPPORT": "socket type not supported*"
    }
  },
  "eval.luv.LuvException": {
    "doc": "Exceptions thrown by functions in `eval.luv` package.",
    "path": "haxe\\std\\eval\\luv\\LuvException.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Metrics": {
    "doc": "Metrics.\n\n@see https://aantron.github.io/luv/luv/Luv/Metrics",
    "path": "haxe\\std\\eval\\luv\\Metrics.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Network": {
    "doc": "Network interfaces and hostname.\n\n@see https://aantron.github.io/luv/luv/Luv/Network",
    "path": "haxe\\std\\eval\\luv\\Network.hx",
    "functions": {
      "ifIndexToName": "Retrieves a network interface name.",
      "ifIndexToIid": "Retrieves a network interface identifier suitable for use in an IPv6 scoped address.",
      "getHostName": "Evaluates to the system's hostname."
    },
    "fields": {}
  },
  "eval.luv.Passwd": {
    "doc": "Current user information.\n\n@see https://aantron.github.io/luv/luv/Luv/Passwd",
    "path": "haxe\\std\\eval\\luv\\Passwd.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Path": {
    "doc": "Relevant directories.\n\n@see https://aantron.github.io/luv/luv/Luv/Path",
    "path": "haxe\\std\\eval\\luv\\Path.hx",
    "functions": {
      "cwd": "Evaluates to the current working directory.",
      "chdir": "Changes the current working directory.",
      "homedir": "Evaluates to the path of the home directory.",
      "tmpdir": "Evaluates to the path of the temporary directory."
    },
    "fields": {}
  },
  "eval.luv.Pid": {
    "doc": "Process ids.\n\n@see https://aantron.github.io/luv/luv/Luv/Pid",
    "path": "haxe\\std\\eval\\luv\\Pid.hx",
    "functions": {
      "getPPid": "Evaluates to the pid of the parent process."
    },
    "fields": {}
  },
  "eval.luv.Random": {
    "doc": "System entropy source.\n\n@see https://aantron.github.io/luv/luv/Luv/Random",
    "path": "haxe\\std\\eval\\luv\\Random.hx",
    "functions": {
      "random": "Fills the given buffer with bits from the system entropy source."
    },
    "fields": {}
  },
  "eval.luv.Resource": {
    "doc": "Resource usage.\n\n@see https://aantron.github.io/luv/luv/Luv/Resource",
    "path": "haxe\\std\\eval\\luv\\Resource.hx",
    "functions": {
      "loadAvg": "Evaluates to the load average.",
      "freeMemory": "Evaluates to the amount of free memory, in bytes.\n\tReturns `null` when unknown.",
      "totalMemory": "Evaluates to the total amount of memory, in bytes.\n\tReturns `null` when unknown.",
      "constrainedMemory": "Gets the amount of memory available to the process (in bytes) based on\n\tlimits imposed by the OS.\n\tIf there is no such constraint returns `null`",
      "getPriority": "Evaluates to the priority of the process with the given pid.",
      "setPriority": "Sets the priority of the process with the given pid.",
      "residentSetMemory": "Evaluates to the resident set size for the current process.",
      "getRUsage": "Gets the resource usage measures for the current process."
    },
    "fields": {}
  },
  "eval.luv.AddressFamily": {
    "doc": "Network address families.",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.SocketType": {
    "doc": "Socket types.",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {
      "ipv6": "Converts a string and port number to an IPv6 struct sockaddr.",
      "toString": "Converts a network address to a string."
    },
    "fields": {}
  },
  "eval.luv.SystemInfo": {
    "doc": "System information.\n\n@see https://aantron.github.io/luv/luv/Luv/System_info",
    "path": "haxe\\std\\eval\\luv\\SystemInfo.hx",
    "functions": {
      "uname": "Gets information about the CPUs on the system."
    },
    "fields": {}
  },
  "eval.luv.ThreadPool": {
    "doc": "Thread pool.\n\n@see https://aantron.github.io/luv/luv/Luv/Thread_pool",
    "path": "haxe\\std\\eval\\luv\\ThreadPool.hx",
    "functions": {
      "setSize": "Sets thread pool size.\n\n\tThis function should be called as soon during process startup as possible."
    },
    "fields": {}
  },
  "eval.luv.Time": {
    "doc": "Current time.\n\n@see https://aantron.github.io/luv/luv/Luv/Time",
    "path": "haxe\\std\\eval\\luv\\Time.hx",
    "functions": {
      "hrTime": "Samples the high-resolution timer.",
      "sleep": "Suspends the calling thread for at least the given number of milliseconds."
    },
    "fields": {}
  },
  "eval.luv.Version": {
    "doc": "Version information for the vendored libuv.\n\n@see https://aantron.github.io/luv/luv/Luv/Version",
    "path": "haxe\\std\\eval\\luv\\Version.hx",
    "functions": {},
    "fields": {}
  },
  "eval.vm.Gc": {
    "doc": "The memory management counters are returned in a stat record.\nThe total amount of memory allocated by the program since it was started is (in words) minor_words + major_words - promoted_words. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.\n*/\ntypedef Stat = {\n/**\n\tNumber of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.\n*/\nvar minor_words:Float;\n\n/**\n\tNumber of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.\n*/\nvar promoted_words:Float;\n\n/**\n\tNumber of words allocated in the major heap, including the promoted words, since the program was started.\n*/\nvar major_words:Float;\n\n/**\n\tNumber of minor collections since the program was started.\n*/\nvar minor_collections:Float;\n\n/**\n\tNumber of major collection cycles completed since the program was started.\n*/\nvar major_collections:Float;\n\n/**\n\tTotal size of the major heap, in words.\n*/\nvar heap_words:Int;\n\n/**\n\tNumber of contiguous pieces of memory that make up the major heap.\n*/\nvar heap_chunks:Int;\n\n/**\n\tNumber of words of live data in the major heap, including the header words.\n*/\nvar live_words:Int;\n\n/**\n\tNumber of live blocks in the major heap.\n*/\nvar live_blocks:Int;\n\n/**\n\tNumber of words in the free list.\n*/\nvar free_words:Int;\n\n/**\n\tNumber of blocks in the free list.\n*/\nvar free_blocks:Int;\n\n/**\n\tSize (in words) of the largest block in the free list.\n*/\nvar largest_free:Int;\n\n/**\n\tNumber of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.\n*/\nvar fragments:Int;\n\n/**\n\tNumber of heap compactions since the program was started.\n*/\nvar compactions:Int;\n\n/**\n\tMaximum size reached by the major heap, in words.\n*/\nvar top_heap_words:Int;\n\n/**\n\tCurrent size of the stack, in words.\n*/\nvar stack_size:Int;\n}\n\n/**\nThe GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n/**\n\tThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.\n*/\nvar minor_heap_size:Int;\n\n/**\n\tHow much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.\n*/\nvar major_heap_increment:Int;\n\n/**\n\tThe major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.\n*/\nvar space_overhead:Int;\n\n/**\n\tThis value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.\n*/\nvar verbose:Int;\n\n/**\n\tHeap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.\n*/\nvar max_overhead:Int;\n\n/**\n\tThe maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.\n*/\nvar stack_limit:Int;\n\n/**\n\tThe policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.\n*/\nvar allocation_policy:Int;\n}\n\n/**\nMemory management control and statistics; finalised values.",
    "path": "haxe\\std\\eval\\vm\\Gc.hx",
    "functions": {
      "compact": "Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.",
      "counters": "Return (minor_words, promoted_words, major_words). This function is as fast as quick_stat.",
      "finalise": "Registers f as a finalisation function for v. v must be heap-allocated. f will be called with v as argument at some point between the first time v becomes unreachable (including through weak pointers) and the time v is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before v becomes unreachable).\n\tThe GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to finalise. If finalise is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.\n\n\tIn the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.",
      "full_major": "Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.",
      "get": "Return the current values of the GC parameters in a control record.",
      "major": "Do a minor collection and finish the current major collection cycle.",
      "major_slice": "Do a minor collection and a slice of major collection. n is the size of the slice: the GC will do enough work to free (on average) n words of memory. If n = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).",
      "minor": "Trigger a minor collection.",
      "print_stat": "Print the current values of the memory management counters (in human-readable form) into the channel argument.",
      "quick_stat": "Same as stat except that live_words, live_blocks, free_words, free_blocks, largest_free, and fragments are set to 0. This function is much faster than stat because it does not need to go through the heap.",
      "set": "Changes the GC parameters according to the control record r.",
      "stat": "Return the current values of the memory management counters in a stat record. This function examines every heap block to get the statistics."
    },
    "fields": {
      "promoted_words": "Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.",
      "major_words": "Number of words allocated in the major heap, including the promoted words, since the program was started.",
      "minor_collections": "Number of minor collections since the program was started.",
      "major_collections": "Number of major collection cycles completed since the program was started.",
      "heap_words": "Total size of the major heap, in words.",
      "heap_chunks": "Number of contiguous pieces of memory that make up the major heap.",
      "live_words": "Number of words of live data in the major heap, including the header words.",
      "live_blocks": "Number of live blocks in the major heap.",
      "free_words": "Number of words in the free list.",
      "free_blocks": "Number of blocks in the free list.",
      "largest_free": "Size (in words) of the largest block in the free list.",
      "fragments": "Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.",
      "compactions": "Number of heap compactions since the program was started.",
      "top_heap_words": "Maximum size reached by the major heap, in words.",
      "stack_size": "Current size of the stack, in words.",
      "minor_heap_size": "The GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n/**\n\tThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.",
      "major_heap_increment": "How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.",
      "space_overhead": "The major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.",
      "verbose": "This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.",
      "max_overhead": "Heap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.",
      "stack_limit": "The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.",
      "allocation_policy": "The policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0."
    }
  },
  "flash.Lib": {
    "doc": "Platform-specific Flash Library. Provides some platform-specific\nfunctions for the Flash target.",
    "path": "haxe\\std\\flash\\Lib.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.UnsafeStringMap": {
    "doc": "This is similar to `StringMap` excepts that it does not sanitize the keys.\nAs a result, it will be faster to access the map for reading, but it might fail\nwith some reserved keys such as `constructor` or `prototype`.",
    "path": "haxe\\std\\flash\\_std\\haxe\\ds\\UnsafeStringMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.StackItem": {
    "doc": "Elements return by `CallStack` methods.",
    "path": "haxe\\std\\haxe\\CallStack.hx",
    "functions": {
      "exceptionStack": "Return the exception stack : this is the stack elements between\n\tthe place the last exception was thrown and the place it was\n\tcaught, or an empty array if not available.\n\tSet `fullStack` parameter to true in order to return the full exception stack.\n\n\tMay not work if catch type was a derivative from `haxe.Exception`.",
      "toString": "Returns a representation of the stack as a printable string.",
      "subtract": "Returns a range of entries of current stack from the beginning to the the\n\tcommon part of this and `stack`.",
      "copy": "Make a copy of the stack."
    },
    "fields": {}
  },
  "haxe.FlatEnum": {
    "doc": "This type unifies with any function type.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.\n*/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\nThis type unifies with an enum instance if all constructors of the enum\nrequire no arguments.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.NotVoid": {
    "doc": "This type unifies with anything but `Void`.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Constructible": {
    "doc": "This type unifies with any instance of classes that have a constructor\nwhich\n\nis `public` and\nunifies with the type used for type parameter `T`.\n\nIf a type parameter `A` is assigned to a type parameter `B` which is constrained\nto `Constructible<T>`, A must be explicitly constrained to\n`Constructible<T>` as well.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.DynamicAccess": {
    "doc": "DynamicAccess is an abstract type for working with anonymous structures\nthat are intended to hold collections of objects by the string key.\n\nFor example, these types of structures are often created from JSON.\n\nBasically, it wraps `Reflect` calls in a `Map`-like interface.",
    "path": "haxe\\std\\haxe\\DynamicAccess.hx",
    "functions": {
      "get": "Returns a value by specified `key`.\n\n\tIf the structure does not contain the given key, `null` is returned.\n\n\tIf `key` is `null`, the result is unspecified.",
      "set": "Sets a `value` for a specified `key`.\n\n\tIf the structure contains the given key, its value will be overwritten.\n\n\tReturns the given value.\n\n\tIf `key` is `null`, the result is unspecified.",
      "exists": "Tells if the structure contains a specified `key`.\n\n\tIf `key` is `null`, the result is unspecified.",
      "remove": "Removes a specified `key` from the structure.\n\n\tReturns true, if `key` was present in structure, or false otherwise.\n\n\tIf `key` is `null`, the result is unspecified.",
      "keys": "Returns an array of `keys` in a structure.",
      "copy": "Returns a shallow copy of the structure",
      "iterator": "Returns an Iterator over the values of this `DynamicAccess`.\n\n\tThe order of values is undefined.",
      "keyValueIterator": "Returns an Iterator over the keys and values of this `DynamicAccess`.\n\n\tThe order of values is undefined."
    },
    "fields": {}
  },
  "haxe.EntryPoint": {
    "doc": "If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\nThis class can be redefined by custom frameworks so they can handle their own main loop logic.",
    "path": "haxe\\std\\haxe\\EntryPoint.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumFlags": {
    "doc": "A typed interface for bit flags. This is not a real object, only a typed\ninterface for an actual Int. Each flag can be tested/set with the\ncorresponding enum instance. Up to 32 flags can be stored that way.\n\nEnum constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc. The methods are optimized if the\nenum instance is passed directly, e.g. as `has(EnumCtor)`. Otherwise\n`Type.enumIndex()` reflection is used.",
    "path": "haxe\\std\\haxe\\EnumFlags.hx",
    "functions": {
      "has": "Checks if the index of enum instance `v` is set.\n\n\tThis method is optimized if `v` is an enum instance expression such as\n\t`SomeEnum.SomeCtor`.\n\n\tIf `v` is `null`, the result is unspecified.",
      "set": "Sets the index of enum instance `v`.\n\n\tThis method is optimized if `v` is an enum instance expression such as\n\t`SomeEnum.SomeCtor`.\n\n\tIf `v` is `null`, the result is unspecified.",
      "unset": "Unsets the index of enum instance `v`.\n\n\tThis method is optimized if `v` is an enum instance expression such as\n\t`SomeEnum.SomeCtor`.\n\n\tIf `v` is `null`, the result is unspecified.",
      "setTo": "Depending on the value of `condition` sets (`condition=true`) or unsets (`condition=false`)\n\tthe index of enum instance `v`.\n\n\tThis method is optimized if `v` is an enum instance expression such as\n\t`SomeEnum.SomeCtor`.\n\n\tIf `v` is `null`, the result is unspecified.",
      "ofInt": "Convert a integer bitflag into a typed one (this is a no-op, it does not\n\thave any impact on speed).",
      "toInt": "Convert the typed bitflag into the corresponding int value (this is a\n\tno-op, it doesn't have any impact on speed)."
    },
    "fields": {}
  },
  "haxe.EnumTools": {
    "doc": "This class provides advanced methods on enums. It is ideally used with\n`using EnumTools` and then acts as an\n  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n  `enum` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumValueTools": {
    "doc": "Returns the name of enum `e`, including its path.\n\n\tIf `e` is inside a package, the package structure is returned dot-\n\tseparated, with another dot separating the enum name:\n\n\t\tpack1.pack2.(...).packN.EnumName\n\n\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\tpackage structure.\n\n\tIf `e` has no package, the enum name is returned.\n\n\tIf `e` is `null`, the result is unspecified.\n\n\tThe enum name does not include any type parameters.\n*/\nstatic inline function getName<T>(e:Enum<T>):String {\n\treturn Type.getEnumName(e);\n}\n\n/**\n\tCreates an instance of enum `e` by calling its constructor `constr` with\n\targuments `params`.\n\n\tIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.\n*/\nstatic inline function createByName<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\treturn Type.createEnum(e, constr, params);\n}\n\n/**\n\tCreates an instance of enum `e` by calling its constructor number\n\t`index` with arguments `params`.\n\n\tThe constructor indices are preserved from Haxe syntax, so the first\n\tdeclared is index 0, the next index 1 etc.\n\n\tIf `e` or `index` is `null`, or if enum `e` has no constructor\n\tcorresponding to index `index`, or if the number of elements in `params`\n\tdoes not match the expected number of constructor arguments, or if any\n\targument has an invalid type, the result is unspecified.\n*/\nstatic inline function createByIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\treturn Type.createEnumIndex(e, index, params);\n}\n\n/**\n\tReturns a list of all constructors of enum `e` that require no\n\targuments.\n\n\tThis may return the empty Array `[]` if all constructors of `e` require\n\targuments.\n\n\tOtherwise an instance of `e` constructed through each of its non-\n\targument constructors is returned, in the order of the constructor\n\tdeclaration.\n\n\tIf `e` is `null`, the result is unspecified.\n*/\nstatic inline function createAll<T>(e:Enum<T>):Array<T> {\n\treturn Type.allEnums(e);\n}\n\n/**\n\tReturns a list of the names of all constructors of enum `e`.\n\n\tThe order of the constructor names in the returned Array is preserved\n\tfrom the original syntax.\n\n\tIf `c` is `null`, the result is unspecified.\n*/\nstatic inline function getConstructors<T>(e:Enum<T>):Array<String> {\n\treturn Type.getEnumConstructs(e);\n}\n\n#if jvm\n@:noCompletion\nextern static function values<T>(en:Enum<T>):jvm.NativeArray<java.lang.Enum<T>>;\n#end\n}\n\n/**\nThis class provides advanced methods on enum values. It is ideally used with\n`using EnumValueTools` and then acts as an\n  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n  `EnumValue` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {
      "createByName": "Creates an instance of enum `e` by calling its constructor `constr` with\n\targuments `params`.\n\n\tIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n\t`constr`, or if the number of elements in `params` does not match the\n\texpected number of constructor arguments, or if any argument has an\n\tinvalid type, the result is unspecified.",
      "createByIndex": "Creates an instance of enum `e` by calling its constructor number\n\t`index` with arguments `params`.\n\n\tThe constructor indices are preserved from Haxe syntax, so the first\n\tdeclared is index 0, the next index 1 etc.\n\n\tIf `e` or `index` is `null`, or if enum `e` has no constructor\n\tcorresponding to index `index`, or if the number of elements in `params`\n\tdoes not match the expected number of constructor arguments, or if any\n\targument has an invalid type, the result is unspecified.",
      "createAll": "Returns a list of all constructors of enum `e` that require no\n\targuments.\n\n\tThis may return the empty Array `[]` if all constructors of `e` require\n\targuments.\n\n\tOtherwise an instance of `e` constructed through each of its non-\n\targument constructors is returned, in the order of the constructor\n\tdeclaration.\n\n\tIf `e` is `null`, the result is unspecified.",
      "getConstructors": "Returns a list of the names of all constructors of enum `e`.\n\n\tThe order of the constructor names in the returned Array is preserved\n\tfrom the original syntax.\n\n\tIf `c` is `null`, the result is unspecified.",
      "equals": "This class provides advanced methods on enum values. It is ideally used with\n`using EnumValueTools` and then acts as an\n  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n  `EnumValue` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.\n*/\nextern class EnumValueTools {\n/**\n\tRecursively compares two enum instances `a` and `b` by value.\n\n\tUnlike `a == b`, this function performs a deep equality check on the\n\targuments of the constructors (if there are any).\n\n\tIf `a` or `b` are `null`, the result is unspecified.",
      "getName": "Returns the constructor name of enum instance `e`.\n\n\tThe result String does not contain any constructor arguments.\n\n\tIf `e` is `null`, the result is unspecified.",
      "getParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\n\tIf `e` has no arguments, the result is `[]`.\n\n\tOtherwise the result are the values that were used as arguments to `e`,\n\tin the order of their declaration.\n\n\tIf `e` is `null`, the result is unspecified.",
      "getIndex": "Returns the index of enum instance `e`.\n\n\tThis corresponds to the original syntactic position of `e`. The index of\n\tthe first declared constructor is 0, the next one is 1 etc.\n\n\tIf `e` is `null`, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.Exception": {
    "doc": "Base class for exceptions.\n\nIf this class (or derivatives) is used to catch an exception, then\n`haxe.CallStack.exceptionStack()` will not return a stack for the exception\ncaught. Use `haxe.Exception.stack` property instead:\n```haxe\ntry {\n\tthrowSomething();\n} catch(e:Exception) {\n\ttrace(e.stack);\n}\n```\n\nCustom exceptions should extend this class:\n```haxe\nclass MyException extends haxe.Exception {}\n//...\nthrow new MyException('terrible exception');\n```\n\n`haxe.Exception` is also a wildcard type to catch any exception:\n```haxe\ntry {\n\tthrow 'Catch me!';\n} catch(e:haxe.Exception) {\n\ttrace(e.message); // Output: Catch me!\n}\n```\n\nTo rethrow an exception just throw it again.\nHaxe will try to rethrow an original native exception whenever possible.\n```haxe\ntry {\n\tvar a:Array<Int> = null;\n\ta.push(1); // generates target-specific null-pointer exception\n} catch(e:haxe.Exception) {\n\tthrow e; // rethrows native exception instead of haxe.Exception\n}\n```",
    "path": "haxe\\std\\haxe\\Exception.hx",
    "functions": {
      "thrown": "Used internally for wrapping non-throwable values for `throw` expressions.",
      "new": "Create a new Exception instance.\n\n\tThe `previous` argument could be used for exception chaining.\n\n\tThe `native` argument is for internal usage only.\n\tThere is no need to provide `native` argument manually and no need to keep it\n\tupon extending `haxe.Exception` unless you know what you're doing.",
      "unwrap": "Extract an originally thrown value.\n\n\tUsed internally for catching non-native exceptions.\n\tDo _not_ override unless you know what you are doing.",
      "toString": "Returns exception message.",
      "details": "Detailed exception description.\n\n\tIncludes message, stack and the chain of previous exceptions (if set)."
    },
    "fields": {
      "stack": "The call stack at the moment of the exception creation.",
      "previous": "Contains an exception, which was passed to `previous` constructor argument.",
      "native": "Native exception, which caused this exception."
    }
  },
  "haxe.Int64Helper": {
    "doc": "Helper for parsing to `Int64` instances.",
    "path": "haxe\\std\\haxe\\Int64Helper.hx",
    "functions": {
      "fromFloat": "Create `Int64` from given float."
    },
    "fields": {}
  },
  "haxe.Json": {
    "doc": "Cross-platform JSON API: it will automatically use the optimized native API if available.\nUse `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:\nThis will provide extra encoding (but not decoding) features such as enums (replaced by their index) and StringMaps.\n\n@see https://haxe.org/manual/std-Json.html",
    "path": "haxe\\std\\haxe\\Json.hx",
    "functions": {
      "stringify": "Encodes the given `value` and returns the resulting JSON string.\n\n\tIf `replacer` is given and is not null, it is used to retrieve the\n\tactual object to be encoded. The `replacer` function takes two parameters,\n\tthe key and the value being encoded. Initial key value is an empty string.\n\n\tIf `space` is given and is not null, the result will be pretty-printed.\n\tSuccessive levels will be indented by this string.\n\n\t@see https://haxe.org/manual/std-Json-encoding.html"
    },
    "fields": {}
  },
  "haxe.Log": {
    "doc": "Log primarily provides the `trace()` method, which is invoked upon a call to\n`trace()` in Haxe code.",
    "path": "haxe\\std\\haxe\\Log.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Resource": {
    "doc": "Resource can be used to access resources that were added through the\n`--resource file@name` command line parameter.\n\nDepending on their type they can be obtained as `String` through\n`getString(name)`, or as binary data through `getBytes(name)`.\n\nA list of all available resource names can be obtained from `listNames()`.",
    "path": "haxe\\std\\haxe\\Resource.hx",
    "functions": {
      "getString": "Retrieves the resource identified by `name` as a `String`.\n\n\tIf `name` does not match any resource name, `null` is returned.",
      "getBytes": "Retrieves the resource identified by `name` as an instance of\n\thaxe.io.Bytes.\n\n\tIf `name` does not match any resource name, `null` is returned."
    },
    "fields": {}
  },
  "haxe.Serializer": {
    "doc": "The Serializer class can be used to encode values and objects into a `String`,\nfrom which the `Unserializer` class can recreate the original representation.\n\nThis class can be used in two ways:\n\n- create a `new Serializer()` instance, call its `serialize()` method with\n\tany argument and finally retrieve the String representation from\n\t`toString()`\n- call `Serializer.run()` to obtain the serialized representation of a\n\tsingle argument\n\nSerialization is guaranteed to work for all haxe-defined classes, but may\nor may not work for instances of external/native classes.\n\nThe specification of the serialization format can be found here:\n<https://haxe.org/manual/std-serialization-format.html>",
    "path": "haxe\\std\\haxe\\Serializer.hx",
    "functions": {
      "reset": "Resets the internal state of the Serializer, allowing it to be reused.\n\n\tThis does not affect the `useCache` or `useEnumIndex` properties;\n\ttheir values will remain unchanged after calling this method.",
      "toString": "Return the String representation of `this` Serializer.\n\n\tThe exact format specification can be found here:\n\thttps://haxe.org/manual/serialization/format",
      "serialize": "Serializes `v`.\n\n\tAll haxe-defined values and objects with the exception of functions can\n\tbe serialized. Serialization of external/native objects is not\n\tguaranteed to work. This is also true for classes extending external/native\n\tclasses. On some targets, this might include exceptions, too.\n\n\tThe values of `this.useCache` and `this.useEnumIndex` may affect\n\tserialization output.",
      "run": "Serializes `v` and returns the String representation.\n\n\tThis is a convenience function for creating a new instance of\n\tSerializer, serialize `v` into it and obtain the result through a call\n\tto `toString()`."
    },
    "fields": {
      "USE_ENUM_INDEX": "Serializes enum values using constructor indices instead of names.\n\n\tWhen `USE_ENUM_INDEX` is set to `true`, enum constructors are serialized by\n\ttheir numeric index. This can reduce the size of the serialized data,\n\tespecially for enums with long or frequently used constructor names.\n\n\tHowever, using indices makes serialized data more fragile for long-term\n\tstorage. If enum definitions change (e.g., by adding or removing constructors),\n\tthe indices may no longer match the intended constructors.\n\n\tThis is a global default. You can override it per instance using the\n\t`useEnumIndex` field on a `Serializer`.",
      "useCache": "Determines whether this `Serializer` instance uses object caching.\n\n\tWhen enabled, repeated references to the same object are serialized using references\n\tinstead of duplicating data, reducing output size and preserving object identity.\n\n\tSee `USE_CACHE` for a complete description.",
      "useEnumIndex": "Determines whether this `Serializer` instance serializes enum values using their index\n\tinstead of their constructor name.\n\n\tUsing indexes can reduce the size of the serialized data but may be less readable and\n\tmore fragile if enum definitions change.\n\n\tSee `USE_ENUM_INDEX` for a complete description."
    }
  },
  "haxe.Template": {
    "doc": "`Template` provides a basic templating mechanism to replace values in a source\nString, and to have some basic logic.\n\nA complete documentation of the supported syntax is available at:\n<https://haxe.org/manual/std-template.html>",
    "path": "haxe\\std\\haxe\\Template.hx",
    "functions": {
      "execute": "Executes `this` `Template`, taking into account `context` for\n\treplacements and `macros` for callback functions.\n\n\tIf `context` has a field `name`, its value replaces all occurrences of\n\t`::name::` in the `Template`. Otherwise `Template.globals` is checked instead,\n\tIf `name` is not a field of that either, `::name::` is replaced with `null`.\n\n\tIf `macros` has a field `name`, all occurrences of `$$name(args)` are\n\treplaced with the result of calling that field. The first argument is\n\talways the `resolve()` method, followed by the given arguments.\n\tIf `macros` has no such field, the result is unspecified.\n\n\tIf `context` is `null`, the result is unspecified. If `macros` is `null`,\n\tno macros are used."
    },
    "fields": {}
  },
  "haxe.Timer": {
    "doc": "The `Timer` class allows you to create asynchronous timers on platforms that\nsupport events.\n\nThe intended usage is to create an instance of the `Timer` class with a given\ninterval, set its `run()` method to a custom function to be invoked and\neventually call `stop()` to stop the `Timer`.\n\nNote that a running `Timer` may or may not prevent the program to exit\nautomatically when `main()` returns.\n\nIt is also possible to extend this class and override its `run()` method in\nthe child class.\n\nNotice for threaded targets:\n`Timer` instances require threads they were created in to run with Haxe's event loops.\nMain thread of a Haxe program always contains an event loop. For other cases use\n`sys.thread.Thread.createWithEventLoop` and `sys.thread.Thread.runWithEventLoop` methods.",
    "path": "haxe\\std\\haxe\\Timer.hx",
    "functions": {
      "stop": "Stops `this` Timer.\n\n\tAfter calling this method, no additional invocations of `this.run`\n\twill occur.\n\n\tIt is not possible to restart `this` Timer once stopped.",
      "delay": "This method is invoked repeatedly on `this` Timer.\n\n\tIt can be overridden in a subclass, or rebound directly to a custom\n\tfunction:\n\n\t```haxe\n\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\ttimer.run = function() { ... }\n\t```\n\n\tOnce bound, it can still be rebound to different functions until `this`\n\tTimer is stopped through a call to `this.stop`.\n*/\npublic dynamic function run() {}\n\n/**\n\tInvokes `f` after `time_ms` milliseconds.\n\n\tThis is a convenience function for creating a new Timer instance with\n\t`time_ms` as argument, binding its `run()` method to `f` and then stopping\n\t`this` Timer upon the first invocation.\n\n\tIf `f` is `null`, the result is unspecified.",
      "measure": "Measures the time it takes to execute `f`, in seconds with fractions.\n\n\tThis is a convenience function for calculating the difference between\n\t`Timer.stamp()` before and after the invocation of `f`.\n\n\tThe difference is passed as argument to `Log.trace()`, with `\"s\"` appended\n\tto denote the unit. The optional `pos` argument is passed through.\n\n\tIf `f` is `null`, the result is unspecified.",
      "stamp": "Returns a timestamp, in seconds with fractions.\n\n\tThe value itself might differ depending on platforms, only differences\n\tbetween two values make sense.",
      "milliseconds": "Returns a monotonically increasing timestamp with millisecond resolution.\n\nThe precision and epoch of the timer is platform defined."
    },
    "fields": {}
  },
  "haxe.Unit": {
    "doc": "A unit type that only has one value.",
    "path": "haxe\\std\\haxe\\Unit.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Unserializer": {
    "doc": "The `Unserializer` class is the complement to the `Serializer` class. It parses\na serialization `String` and creates objects from the contained data.\n\nThis class can be used in two ways:\n\n- create a `new Unserializer()` instance with a given serialization\n\tString, then call its `unserialize()` method until all values are\n\textracted\n- call `Unserializer.run()`  to unserialize a single value from a given\n\tString\n\nThe specification of the serialization format can be found here:\n<https://haxe.org/manual/serialization/format>",
    "path": "haxe\\std\\haxe\\Unserializer.hx",
    "functions": {
      "setResolver": "Sets the type resolver of `this` Unserializer instance to `r`.\n\n\tIf `r` is `null`, a special resolver is used which returns `null` for all\n\tinput values.\n\n\tSee `DEFAULT_RESOLVER` for more information on type resolvers.",
      "getResolver": "Gets the type resolver of `this` Unserializer instance.\n\n\tSee `DEFAULT_RESOLVER` for more information on type resolvers.",
      "unserialize": "Unserializes the next part of `this` Unserializer instance and returns\n\tthe according value.\n\n\tThis function may call `this.resolver.resolveClass` to determine a\n\tClass from a String, and `this.resolver.resolveEnum` to determine an\n\tEnum from a String.\n\n\tIf `this` Unserializer instance contains no more or invalid data, an\n\texception is thrown.\n\n\tThis operation may fail on structurally valid data if a type cannot be\n\tresolved or if a field cannot be set. This can happen when unserializing\n\tStrings that were serialized on a different Haxe target, in which the\n\tserialization side has to make sure not to include platform-specific\n\tdata.\n\n\tClasses are created from `Type.createEmptyInstance`, which means their\n\tconstructors are not called.",
      "run": "Unserializes `v` and returns the according value.\n\n\tThis is a convenience function for creating a new instance of\n\tUnserializer with `v` as buffer and calling its `unserialize()` method\n\tonce."
    },
    "fields": {
      "index": "Creates a new Unserializer instance, with its internal buffer\n\tinitialized to `buf`.\n\n\tThis does not parse `buf` immediately. It is parsed only when calls to\n\t`this.unserialize` are made.\n\n\tEach Unserializer instance maintains its own cache.\n*/\npublic function new(buf:String) {\n\tthis.buf = buf;\n\tlength = this.buf.fastLength();\n\tpos = 0;\n\t#if neko\n\tupos = 0;\n\t#end\n\tscache = new Array();\n\tcache = new Array();\n\tvar r = DEFAULT_RESOLVER;\n\tif (r == null) {\n\t\tr = new DefaultResolver();\n\t\tDEFAULT_RESOLVER = r;\n\t}\n\tresolver = r;\n}\n\n/**\n\tSets the type resolver of `this` Unserializer instance to `r`.\n\n\tIf `r` is `null`, a special resolver is used which returns `null` for all\n\tinput values.\n\n\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\npublic function setResolver(r) {\n\tif (r == null)\n\t\tresolver = NullResolver.instance;\n\telse\n\t\tresolver = r;\n}\n\n/**\n\tGets the type resolver of `this` Unserializer instance.\n\n\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\npublic function getResolver() {\n\treturn resolver;\n}\n\ninline function get(p:Int):Int {\n\t#if php\n\treturn p >= length ? 0 : buf.fastCharCodeAt(p);\n\t#else\n\treturn StringTools.fastCodeAt(buf, p);\n\t#end\n}\n\nfunction readDigits() {\n\tvar k = 0;\n\tvar s = false;\n\tvar fpos = pos;\n\twhile (true) {\n\t\tvar c = get(pos);\n\t\tif (StringTools.isEof(c))\n\t\t\tbreak;\n\t\tif (c == \"-\".code) {\n\t\t\tif (pos != fpos)\n\t\t\t\tbreak;\n\t\t\ts = true;\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c < \"0\".code || c > \"9\".code)\n\t\t\tbreak;\n\t\tk = k * 10 + (c - \"0\".code);\n\t\tpos++;\n\t}\n\tif (s)\n\t\tk *= -1;\n\treturn k;\n}\n\nfunction readFloat() {\n\tvar p1 = pos;\n\twhile (true) {\n\t\tvar c = get(pos);\n\t\tif (StringTools.isEof(c))\n\t\t\tbreak;\n\t\t// + - . , 0-9\n\t\tif ((c >= 43 && c < 58) || c == \"e\".code || c == \"E\".code)\n\t\t\tpos++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn Std.parseFloat(buf.fastSubstr(p1, pos - p1));\n}\n\nfunction unserializeObject(o:{}) {\n\twhile (true) {\n\t\tif (pos >= length)\n\t\t\tthrow \"Invalid object\";\n\t\tif (get(pos) == \"g\".code)\n\t\t\tbreak;\n\t\tvar k:Dynamic = unserialize();\n\t\tif (!Std.isOfType(k, String))\n\t\t\tthrow \"Invalid object key\";\n\t\tvar v = unserialize();\n\t\tReflect.setField(o, k, v);\n\t}\n\tpos++;\n}\n\nfunction unserializeEnum<T>(edecl:Enum<T>, tag:String) {\n\tif (get(pos++) != \":\".code)\n\t\tthrow \"Invalid enum format\";\n\tvar nargs = readDigits();\n\tif (nargs == 0)\n\t\treturn Type.createEnum(edecl, tag);\n\tvar args = new Array();\n\twhile (nargs-- > 0)\n\t\targs.push(unserialize());\n\treturn Type.createEnum(edecl, tag, args);\n}\n\n/**\n\tUnserializes the next part of `this` Unserializer instance and returns\n\tthe according value.\n\n\tThis function may call `this.resolver.resolveClass` to determine a\n\tClass from a String, and `this.resolver.resolveEnum` to determine an\n\tEnum from a String.\n\n\tIf `this` Unserializer instance contains no more or invalid data, an\n\texception is thrown.\n\n\tThis operation may fail on structurally valid data if a type cannot be\n\tresolved or if a field cannot be set. This can happen when unserializing\n\tStrings that were serialized on a different Haxe target, in which the\n\tserialization side has to make sure not to include platform-specific\n\tdata.\n\n\tClasses are created from `Type.createEmptyInstance`, which means their\n\tconstructors are not called.\n*/\npublic function unserialize():Dynamic {\n\tswitch (get(pos++)) {\n\t\tcase \"n\".code:\n\t\t\treturn null;\n\t\tcase \"t\".code:\n\t\t\treturn true;\n\t\tcase \"f\".code:\n\t\t\treturn false;\n\t\tcase \"z\".code:\n\t\t\treturn 0;\n\t\tcase \"i\".code:\n\t\t\treturn readDigits();\n\t\tcase \"d\".code:\n\t\t\treturn readFloat();\n\t\tcase \"y\".code:\n\t\t\tvar len = readDigits();\n\t\t\tif (get(pos++) != \":\".code || length - pos < len)\n\t\t\t\tthrow \"Invalid string length\";\n\t\t\tvar s = buf.fastSubstr(pos, len);\n\t\t\tpos += len;\n\t\t\ts = StringTools.urlDecode(s);\n\t\t\tscache.push(s);\n\t\t\treturn s;\n\t\tcase \"k\".code:\n\t\t\treturn Math.NaN;\n\t\tcase \"m\".code:\n\t\t\treturn Math.NEGATIVE_INFINITY;\n\t\tcase \"p\".code:\n\t\t\treturn Math.POSITIVE_INFINITY;\n\t\tcase \"a\".code:\n\t\t\tvar buf = buf;\n\t\t\tvar a = new Array<Dynamic>();\n\t\t\t#if cpp\n\t\t\tvar cachePos = cache.length;\n\t\t\t#end\n\t\t\tcache.push(a);\n\t\t\twhile (true) {\n\t\t\t\tvar c = get(pos);\n\t\t\t\tif (c == \"h\".code) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (c == \"u\".code) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tvar n = readDigits();\n\t\t\t\t\ta[a.length + n - 1] = null;\n\t\t\t\t} else\n\t\t\t\t\ta.push(unserialize());\n\t\t\t}\n\t\t\t#if cpp\n\t\t\treturn cache[cachePos] = cpp.NativeArray.resolveVirtualArray(a);\n\t\t\t#else\n\t\t\treturn a;\n\t\t\t#end\n\t\tcase \"o\".code:\n\t\t\tvar o = {};\n\t\t\tcache.push(o);\n\t\t\tunserializeObject(o);\n\t\t\treturn o;\n\t\tcase \"r\".code:\n\t\t\tvar n = readDigits();\n\t\t\tif (n < 0 || n >= cache.length)\n\t\t\t\tthrow \"Invalid reference\";\n\t\t\treturn cache[n];\n\t\tcase \"R\".code:\n\t\t\tvar n = readDigits();\n\t\t\tif (n < 0 || n >= scache.length)\n\t\t\t\tthrow \"Invalid string reference\";\n\t\t\treturn scache[n];\n\t\tcase \"x\".code:\n\t\t\tthrow unserialize();\n\t\tcase \"c\".code:\n\t\t\tvar name = unserialize();\n\t\t\tvar cl = resolver.resolveClass(name);\n\t\t\tif (cl == null)\n\t\t\t\tthrow \"Class not found \" + name;\n\t\t\tvar o = Type.createEmptyInstance(cl);\n\t\t\tcache.push(o);\n\t\t\tunserializeObject(o);\n\t\t\treturn o;\n\t\tcase \"w\".code:\n\t\t\tvar name = unserialize();\n\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\tif (edecl == null)\n\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\tvar e = unserializeEnum(edecl, unserialize());\n\t\t\tcache.push(e);\n\t\t\treturn e;\n\t\tcase \"j\".code:\n\t\t\tvar name = unserialize();\n\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\tif (edecl == null)\n\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\tpos++; /* skip ':'"
    }
  },
  "haxe.ValueException": {
    "doc": "An exception containing arbitrary value.\n\nThis class is automatically used for throwing values, which don't extend `haxe.Exception`\nor native exception type.\nFor example:\n```haxe\nthrow \"Terrible error\";\n```\nwill be compiled to\n```haxe\nthrow new ValueException(\"Terrible error\");\n```",
    "path": "haxe\\std\\haxe\\ValueException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Adler32": {
    "doc": "Calculates the Adler32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Adler32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Base64": {
    "doc": "Allows one to encode/decode String and bytes using Base64 encoding.",
    "path": "haxe\\std\\haxe\\crypto\\Base64.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.BaseCode": {
    "doc": "Allows one to encode/decode String and bytes using a power of two base dictionary.",
    "path": "haxe\\std\\haxe\\crypto\\BaseCode.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Crc32": {
    "doc": "Calculates the Crc32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Crc32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.HashMethod": {
    "doc": "Hash methods for Hmac calculation.",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Hmac": {
    "doc": "Calculates a Hmac of the given Bytes using a HashMethod.",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Md5": {
    "doc": "Creates a MD5 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Md5.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha1": {
    "doc": "Creates a Sha1 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha1.hx",
    "functions": {
      "rol": "Bitwise rotate a 32-bit number to the left",
      "ft": "Perform the appropriate triplet combination function for the current iteration",
      "kt": "Determine the appropriate additive constant for the current iteration"
    },
    "fields": {}
  },
  "haxe.crypto.Sha224": {
    "doc": "Creates a Sha224 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha224.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha256": {
    "doc": "Creates a Sha256 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha256.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.display.abstract": {
    "doc": "This type is already available with it's unqualified name for one of these reasons:\n\t  - it's a toplevel type\n\t  - it's imported with an `import` in the current module\n\t  - it's imported in an `import.hx` file\n*/\nvar Imported;\n\n/**\n\tThe type is currently not imported. It can be accessed either\n\twith its fully qualified name or by inserting an import.\n*/\nvar Unimported;\n\n/**\n\tA type with the same name is already imported in the module.\n\tThe fully qualified name has to be used to access it.\n*/\nvar Shadowed;\n}\n\n/* Type instance */\ntypedef JsonPackagePath = {\nvar pack:Array<String>;\n}\n\ntypedef JsonModulePath = JsonPackagePath & {\nvar moduleName:String;\nvar ?importStatus:ImportStatus;\n}\n\ntypedef JsonTypePath = JsonModulePath & {\nvar typeName:String;\n}\n\ntypedef JsonStaticFieldPath = JsonTypePath & {\nvar fieldName:String;\n}\n\ntypedef JsonTypePathWithParams = {\nvar path:JsonTypePath;\nvar params:JsonTypes;\n}\n\ntypedef JsonFunctionArgument = {\nvar name:String;\nvar opt:Bool;\nvar t:JsonType<Dynamic>;\nvar ?value:{\n\tvar string:String;\n};\n}\n\ntypedef JsonFunctionSignature = {\nvar args:Array<JsonFunctionArgument>;\nvar ret:JsonType<Dynamic>;\n}\n\nenum abstract JsonAnonStatusKind<T>(String) {\nvar AClosed;\nvar AOpened;\nvar AConst;\nvar AExtend:JsonAnonStatusKind<JsonTypes>;\nvar AClassStatics:JsonAnonStatusKind<JsonTypePath>;\nvar AEnumStatics:JsonAnonStatusKind<JsonTypePath>;\nvar AAbstractStatics:JsonAnonStatusKind<JsonTypePath>;\n}\n\ntypedef JsonAnonStatus<T> = {\nvar kind:JsonAnonStatusKind<T>;\nvar args:T;\n}\n\ntypedef JsonAnon = {\nvar fields:JsonClassFields;\nvar status:JsonAnonStatus<Dynamic>;\n}\n\nenum abstract JsonTypeKind<T>(String) {\nvar TMono;\nvar TInst:JsonTypeKind<JsonTypePathWithParams>;\nvar TEnum:JsonTypeKind<JsonTypePathWithParams>;\nvar TType:JsonTypeKind<JsonTypePathWithParams>;\nvar TAbstract:JsonTypeKind<JsonTypePathWithParams>;\nvar TFun:JsonTypeKind<JsonFunctionSignature>;\nvar TAnonymous:JsonTypeKind<JsonAnon>;\nvar TDynamic:JsonTypeKind<Null<JsonType<Dynamic>>>;\n}\n\ntypedef JsonType<T> = {\nvar kind:JsonTypeKind<T>;\nvar args:T;\n}\n\ntypedef JsonTypes = Array<JsonType<Dynamic>>;\n\n/* Type parameters */\ntypedef JsonTypeParameter = {\nvar name:String;\nvar constraints:JsonTypes;\n}\n\ntypedef JsonTypeParameters = Array<JsonTypeParameter>;\n\n/* Expr",
    "path": "haxe\\std\\haxe\\display\\JsonModuleTypes.hx",
    "functions": {},
    "fields": {
      "Unimported": "The type is currently not imported. It can be accessed either\n\twith its fully qualified name or by inserting an import.",
      "Shadowed": "A type with the same name is already imported in the module.\n\tThe fully qualified name has to be used to access it."
    }
  },
  "haxe.ds.ArraySort": {
    "doc": "ArraySort provides a stable implementation of merge sort through its `sort`\nmethod. It should be used instead of `Array.sort` in cases where the order\nof equal elements has to be retained on all targets.",
    "path": "haxe\\std\\haxe\\ds\\ArraySort.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.BalancedTree": {
    "doc": "BalancedTree allows key-value mapping with arbitrary keys, as long as they\ncan be ordered. By default, `Reflect.compare` is used in the `compare`\nmethod, which can be overridden in subclasses.\n\nOperations have a logarithmic average and worst-case cost.\n\nIteration over keys and values, using `keys` and `iterator` respectively,\nare in-order.",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.TreeNode": {
    "doc": "Creates a new BalancedTree, which is initially empty.\n*/\npublic function new() {}\n\n/**\n\tBinds `key` to `value`.\n\n\tIf `key` is already bound to a value, that binding disappears.\n\n\tIf `key` is null, the result is unspecified.\n*/\npublic function set(key:K, value:V) {\n\troot = setLoop(key, value, root);\n}\n\n/**\n\tReturns the value `key` is bound to.\n\n\tIf `key` is not bound to any value, `null` is returned.\n\n\tIf `key` is null, the result is unspecified.\n*/\npublic function get(key:K):Null<V> {\n\tvar node = root;\n\twhile (node != null) {\n\t\tvar c = compare(key, node.key);\n\t\tif (c == 0)\n\t\t\treturn node.value;\n\t\tif (c < 0)\n\t\t\tnode = node.left;\n\t\telse\n\t\t\tnode = node.right;\n\t}\n\treturn null;\n}\n\n/**\n\tRemoves the current binding of `key`.\n\n\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\treturned.\n\n\tOtherwise the binding of `key` is removed and true is returned.\n\n\tIf `key` is null, the result is unspecified.\n*/\npublic function remove(key:K) {\n\ttry {\n\t\troot = removeLoop(key, root);\n\t\treturn true;\n\t} catch (e:String) {\n\t\treturn false;\n\t}\n}\n\n/**\n\tTells if `key` is bound to a value.\n\n\tThis method returns true even if `key` is bound to null.\n\n\tIf `key` is null, the result is unspecified.\n*/\npublic function exists(key:K) {\n\tvar node = root;\n\twhile (node != null) {\n\t\tvar c = compare(key, node.key);\n\t\tif (c == 0)\n\t\t\treturn true;\n\t\telse if (c < 0)\n\t\t\tnode = node.left;\n\t\telse\n\t\t\tnode = node.right;\n\t}\n\treturn false;\n}\n\n/**\n\tIterates over the bound values of `this` BalancedTree.\n\n\tThis operation is performed in-order.\n*/\npublic function iterator():Iterator<V> {\n\tvar ret = [];\n\titeratorLoop(root, ret);\n\treturn ret.iterator();\n}\n\n/**\n\tSee `Map.keyValueIterator`\n*/\n@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\treturn new haxe.iterators.MapKeyValueIterator(this);\n}\n\n/**\n\tIterates over the keys of `this` BalancedTree.\n\n\tThis operation is performed in-order.\n*/\npublic function keys():Iterator<K> {\n\tvar ret = [];\n\tkeysLoop(root, ret);\n\treturn ret.iterator();\n}\n\npublic function copy():BalancedTree<K, V> {\n\tvar copied = new BalancedTree<K, V>();\n\tcopied.root = root;\n\treturn copied;\n}\n\nfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\n\tif (node == null)\n\t\treturn new TreeNode<K, V>(null, k, v, null);\n\tvar c = compare(k, node.key);\n\treturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\n\t\tvar nl = setLoop(k, v, node.left);\n\t\tbalance(nl, node.key, node.value, node.right);\n\t} else {\n\t\tvar nr = setLoop(k, v, node.right);\n\t\tbalance(node.left, node.key, node.value, nr);\n\t}\n}\n\nfunction removeLoop(k:K, node:TreeNode<K, V>) {\n\tif (node == null)\n\t\tthrow \"Not_found\";\n\tvar c = compare(k, node.key);\n\treturn if (c == 0) merge(node.left,\n\t\tnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\n\t\tnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n}\n\nstatic function iteratorLoop<K,V>(node:TreeNode<K, V>, acc:Array<V>) {\n\tif (node != null) {\n\t\titeratorLoop(node.left, acc);\n\t\tacc.push(node.value);\n\t\titeratorLoop(node.right, acc);\n\t}\n}\n\nfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\n\tif (node != null) {\n\t\tkeysLoop(node.left, acc);\n\t\tacc.push(node.key);\n\t\tkeysLoop(node.right, acc);\n\t}\n}\n\nstatic function sizeLoop<K,V>(node:TreeNode<K, V>):Int {\n\tif (node != null) {\n\t\treturn sizeLoop(node.left) + 1 + sizeLoop(node.right);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nfunction merge(t1, t2) {\n\tif (t1 == null)\n\t\treturn t2;\n\tif (t2 == null)\n\t\treturn t1;\n\tvar t = minBinding(t2);\n\treturn balance(t1, t.key, t.value, removeMinBinding(t2));\n}\n\nfunction minBinding(t:TreeNode<K, V>) {\n\treturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n}\n\nfunction removeMinBinding(t:TreeNode<K, V>) {\n\treturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n}\n\nfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\n\tvar hl = l.get_height();\n\tvar hr = r.get_height();\n\treturn if (hl > hr + 2) {\n\t\tif (l.left.get_height() >= l.right.get_height())\n\t\t\tnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\n\t\telse\n\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\n\t\t\t\tnew TreeNode<K, V>(l.right.right, k, v, r));\n\t} else if (hr > hl + 2) {\n\t\tif (r.right.get_height() > r.left.get_height())\n\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\n\t\telse\n\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\n\t\t\t\tnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n\t} else {\n\t\tnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n\t}\n}\n\nfunction compare(k1:K, k2:K) {\n\treturn Reflect.compare(k1, k2);\n}\n\npublic function toString() {\n\treturn root == null ? \"[]\" : '[${root.toString()}]';\n}\n\n/**\n\tRemoves all keys from `this` BalancedTree.\n*/\npublic function clear():Void {\n\troot = null;\n}\n\npublic function size():Int {\n\treturn sizeLoop(root);\n}\n}\n\n/**\nA tree node of `haxe.ds.BalancedTree`.",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {
      "set": "Binds `key` to `value`.\n\n\tIf `key` is already bound to a value, that binding disappears.\n\n\tIf `key` is null, the result is unspecified.",
      "get": "Returns the value `key` is bound to.\n\n\tIf `key` is not bound to any value, `null` is returned.\n\n\tIf `key` is null, the result is unspecified.",
      "remove": "Removes the current binding of `key`.\n\n\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\treturned.\n\n\tOtherwise the binding of `key` is removed and true is returned.\n\n\tIf `key` is null, the result is unspecified.",
      "exists": "Tells if `key` is bound to a value.\n\n\tThis method returns true even if `key` is bound to null.\n\n\tIf `key` is null, the result is unspecified.",
      "iterator": "Iterates over the bound values of `this` BalancedTree.\n\n\tThis operation is performed in-order.",
      "keys": "See `Map.keyValueIterator`\n*/\n@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\treturn new haxe.iterators.MapKeyValueIterator(this);\n}\n\n/**\n\tIterates over the keys of `this` BalancedTree.\n\n\tThis operation is performed in-order.",
      "clear": "Removes all keys from `this` BalancedTree."
    },
    "fields": {}
  },
  "haxe.ds.Either": {
    "doc": "Either represents values which are either of type `L` (Left) or type `R`\n(Right).",
    "path": "haxe\\std\\haxe\\ds\\Either.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.EnumValueMap": {
    "doc": "EnumValueMap allows mapping of enum value keys to arbitrary values.\n\nKeys are compared by value and recursively over their parameters. If any\nparameter is not an enum value, `Reflect.compare` is used to compare them.",
    "path": "haxe\\std\\haxe\\ds\\EnumValueMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.HashMap": {
    "doc": "HashMap allows mapping of hashable objects to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\HashMap.hx",
    "functions": {
      "exists": "See `Map.set`\n*/\n@:arrayAccess public inline function set(k:K, v:V) {\n\tthis.keys.set(k.hashCode(), k);\n\tthis.values.set(k.hashCode(), v);\n}\n\n/**\n\tSee `Map.get`\n*/\n@:arrayAccess public inline function get(k:K) {\n\treturn this.values.get(k.hashCode());\n}\n\n/**\n\tSee `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`",
      "copy": "See `Map.copy`",
      "iterator": "See `Map.iterator`",
      "keyValueIterator": "See `Map.keyValueIterator`",
      "clear": "See `Map.clear`",
      "size": "See `Map.size`"
    },
    "fields": {}
  },
  "haxe.ds.IntMap": {
    "doc": "IntMap allows mapping of Int keys to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\IntMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<Int, T> {\n\treturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<Int, T>;\n#end\n\n/**\n\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.List": {
    "doc": "A linked-list of elements. The list is composed of element container objects\nthat are chained together. It is optimized so that adding or removing an\nelement does not imply copying the whole list content every time.\n\n@see https://haxe.org/manual/std-List.html",
    "path": "haxe\\std\\haxe\\ds\\List.hx",
    "functions": {
      "add": "Adds element `item` at the end of `this` List.\n\n\t`this.length` increases by 1.",
      "push": "Adds element `item` at the beginning of `this` List.\n\n\t`this.length` increases by 1.",
      "first": "Returns the first element of `this` List, or null if no elements exist.\n\n\tThis function does not modify `this` List.",
      "last": "Returns the last element of `this` List, or null if no elements exist.\n\n\tThis function does not modify `this` List.",
      "pop": "Returns the first element of `this` List, or null if no elements exist.\n\n\tThe element is removed from `this` List.",
      "isEmpty": "Tells if `this` List is empty.",
      "clear": "Empties `this` List.\n\n\tThis function does not traverse the elements, but simply sets the\n\tinternal references to null and `this.length` to 0.",
      "remove": "Removes the first occurrence of `v` in `this` List.\n\n\tIf `v` is found by checking standard equality, it is removed from `this`\n\tList and the function returns true.\n\n\tOtherwise, false is returned.",
      "iterator": "Returns an iterator on the elements of the list.",
      "toString": "Returns an iterator of the List indices and values.\n*/\n@:pure @:runtime public inline function keyValueIterator():ListKeyValueIterator<T> {\n\treturn new ListKeyValueIterator(h);\n}\n\n/**\n\tReturns a string representation of `this` List.\n\n\tThe result is enclosed in { } with the individual elements being\n\tseparated by a comma.",
      "join": "Returns a string representation of `this` List, with `sep` separating\n\teach element.",
      "filter": "Returns a list filtered with `f`. The returned list will contain all\n\telements for which `f(x) == true`.",
      "map": "Returns a new list where all elements have been converted by the\n\tfunction `f`."
    },
    "fields": {}
  },
  "haxe.ds.ListSort": {
    "doc": "ListSort provides a stable implementation of merge sort through its `sort`\nmethod. It has a O(N.log(N)) complexity and does not require additional memory allocation.",
    "path": "haxe\\std\\haxe\\ds\\ListSort.hx",
    "functions": {
      "sortSingleLinked": "Same as `sort` but on single linked list."
    },
    "fields": {}
  },
  "haxe.ds.ObjectMap": {
    "doc": "ObjectMap allows mapping of object keys to arbitrary values.\n\nOn static targets, the keys are considered to be strong references. Refer\nto `haxe.ds.WeakMap` for a weak reference version.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\ObjectMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<K, V> {\n\treturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<K, V>;\n#end\n\n/**\n\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.Option": {
    "doc": "An Option is a wrapper type which can either have a value (Some) or not a\nvalue (None).\n\n@see https://haxe.org/manual/std-Option.html",
    "path": "haxe\\std\\haxe\\ds\\Option.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.StringMap": {
    "doc": "StringMap allows mapping of String keys to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\StringMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t(java) Implementation detail: Do not `set()` any new value while\n\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<String, T> {\n\treturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<String, T>;\n#end\n\n/**\n\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.Vector": {
    "doc": "A Vector is a storage of fixed size. It can be faster than Array on some\ntargets, and is never slower.\n\n@see https://haxe.org/manual/std-vector.html",
    "path": "haxe\\std\\haxe\\ds\\Vector.hx",
    "functions": {
      "toData": "Copies `length` of elements from `src` Vector, beginning at `srcPos` to\n\t`dest` Vector, beginning at `destPos`\n\n\tThe results are unspecified if `length` results in out-of-bounds access,\n\tor if `src` or `dest` are null\n*/\npublic static #if (java || neko || cpp || eval) inline #end function blit<T>(src:Vector<T>, srcPos:Int, dest:Vector<T>, destPos:Int, len:Int):Void {\n\t#if neko\n\tuntyped __dollar__ablit(dest, destPos, src, srcPos, len);\n\t#elseif java\n\tjava.lang.System.arraycopy(src, srcPos, dest, destPos, len);\n\t#elseif cpp\n\tdest.toData().blit(destPos, src.toData(), srcPos, len);\n\t#elseif eval\n\tsrc.toData().blit(srcPos, dest.toData(), destPos, len);\n\t#else\n\tif (src == dest) {\n\t\tif (srcPos < destPos) {\n\t\t\tvar i = srcPos + len;\n\t\t\tvar j = destPos + len;\n\t\t\tfor (k in 0...len) {\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tsrc[j] = src[i];\n\t\t\t}\n\t\t} else if (srcPos > destPos) {\n\t\t\tvar i = srcPos;\n\t\t\tvar j = destPos;\n\t\t\tfor (k in 0...len) {\n\t\t\t\tsrc[j] = src[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i in 0...len) {\n\t\t\tdest[destPos + i] = src[srcPos + i];\n\t\t}\n\t}\n\t#end\n}\n\n/**\n\tCreates a new Array, copy the content from the Vector to it, and returns it.\n*/\npublic #if (flash || cpp || js || java || eval) inline #end function toArray():Array<T> {\n\t#if cpp\n\treturn this.copy();\n\t#elseif python\n\treturn this.copy();\n\t#elseif js\n\treturn this.slice(0);\n\t#elseif eval\n\treturn this.toArray();\n\t#else\n\tvar a = new Array();\n\tvar len = length;\n\t#if (neko)\n\t// prealloc good size\n\tif (len > 0)\n\t\ta[len - 1] = get(0);\n\t#end\n\tfor (i in 0...len)\n\t\ta[i] = get(i);\n\treturn a;\n\t#end\n}\n\n/**\n\tExtracts the data of `this` Vector.\n\n\tThis returns the internal representation type.",
      "fromData": "Initializes a new Vector from `data`.\n\n\tSince `data` is the internal representation of Vector, this is a no-op.\n\n\tIf `data` is null, the corresponding Vector is also `null`.",
      "fromArrayCopy": "Creates a new Vector by copying the elements of `array`.\n\n\tThis always creates a copy, even on platforms where the internal\n\trepresentation is Array.\n\n\tThe elements are not copied and retain their identity, so\n\t`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.\n\n\tIf `array` is null, the result is unspecified.",
      "sort": "Returns a shallow copy of `this` Vector.\n\n\tThe elements are not copied and retain their identity, so\n\t`a[i] == a.copy()[i]` is true for any valid `i`. However,\n\t`a == a.copy()` is always false.\n*/\nextern public inline function copy<T>():Vector<T> {\n\t#if eval\n\treturn fromData(this.copy());\n\t#else\n\tvar r = new Vector<T>(length);\n\tVector.blit(cast this, 0, r, 0, length);\n\treturn r;\n\t#end\n}\n\n/**\n\tReturns a string representation of `this` Vector, with `sep` separating\n\teach element.\n\n\tThe result of this operation is equal to `Std.string(this[0]) + sep +\n\tStd.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`\n\n\tIf `this` Vector has length 0, the result is the empty String `\"\"`.\n\tIf `this` has exactly one element, the result is equal to a call to\n\t`Std.string(this[0])`.\n\n\tIf `sep` is null, the result is unspecified.\n*/\nextern public inline function join<T>(sep:String):String {\n\t#if (flash10 || cpp || eval)\n\treturn this.join(sep);\n\t#else\n\tvar b = new StringBuf();\n\tvar len = length;\n\tfor (i in 0...len) {\n\t\tb.add(Std.string(get(i)));\n\t\tif (i < len - 1) {\n\t\t\tb.add(sep);\n\t\t}\n\t}\n\treturn b.toString();\n\t#end\n}\n\n/**\n\tCreates a new Vector by applying function `f` to all elements of `this`.\n\n\tThe order of elements is preserved.\n\n\tIf `f` is null, the result is unspecified.\n*/\nextern public inline function map<S>(f:T->S):Vector<S> {\n\t#if eval\n\treturn fromData(this.map(f));\n\t#else\n\tvar length = length;\n\tvar r = new Vector<S>(length);\n\tvar len = length;\n\tfor (i in 0...len) {\n\t\tvar v = f(get(i));\n\t\tr.set(i, v);\n\t}\n\treturn r;\n\t#end\n}\n\n/**\n\tSorts `this` Vector according to the comparison function `f`, where\n\t`f(x,y)` returns 0 if x == y, a positive Int if x > y and a\n\tnegative Int if x < y.\n\n\tThis operation modifies `this` Vector in place.\n\n\tThe sort operation is not guaranteed to be stable, which means that the\n\torder of equal elements may not be retained.\n\n\tIf `f` is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.ds.WeakMap": {
    "doc": "WeakMap allows mapping of object keys to arbitrary values.\n\nThe keys are considered to be weak references on static targets.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\WeakMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`",
      "iterator": "See `Map.iterator`",
      "keyValueIterator": "See `Map.keyValueIterator`",
      "copy": "See `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`",
      "size": "See `Map.size`"
    },
    "fields": {}
  },
  "haxe.exceptions.ArgumentException": {
    "doc": "An exception that is thrown when an invalid value provided for an argument of a function.",
    "path": "haxe\\std\\haxe\\exceptions\\ArgumentException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.NotImplementedException": {
    "doc": "An exception that is thrown when requested function or operation does not have an implementation.",
    "path": "haxe\\std\\haxe\\exceptions\\NotImplementedException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.PosException": {
    "doc": "An exception that carry position information of a place where it was created.",
    "path": "haxe\\std\\haxe\\exceptions\\PosException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonParser": {
    "doc": "An implementation of JSON parser in Haxe.\n\nThis class is used by `haxe.Json` when native JSON implementation\nis not available.\n\n@see https://haxe.org/manual/std-Json-parsing.html",
    "path": "haxe\\std\\lua\\_std\\haxe\\format\\JsonParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonPrinter": {
    "doc": "An implementation of JSON printer in Haxe.\n\nThis class is used by `haxe.Json` when native JSON implementation\nis not available.\n\n@see https://haxe.org/manual/std-Json-encoding.html",
    "path": "haxe\\std\\haxe\\format\\JsonPrinter.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.http.HttpBase": {
    "doc": "This class can be used to handle Http requests consistently across\nplatforms. There are two intended usages:\n\n- call `haxe.Http.requestUrl(url)` and receive the result as a `String`\n(only available on `sys` targets)\n- create a `new haxe.Http(url)`, register your callbacks for `onData`,\n`onError` and `onStatus`, then call `request()`.",
    "path": "haxe\\std\\haxe\\http\\HttpBase.hx",
    "functions": {
      "setHeader": "Sets the header identified as `name` to value `value`.\n\n\tIf `name` or `value` are null, the result is unspecified.\n\n\tThis method provides a fluent interface.",
      "setParameter": "Sets the parameter identified as `name` to value `value`.\n\n\tIf `name` or `value` are null, the result is unspecified.\n\n\tThis method provides a fluent interface.",
      "setPostData": "Sets the post data of `this` Http request to `data` string.\n\n\tThere can only be one post data per request. Subsequent calls to\n\tthis method or to `setPostBytes()` overwrite the previously set value.\n\n\tIf `data` is null, the post data is considered to be absent.\n\n\tThis method provides a fluent interface.",
      "setPostBytes": "Sets the post data of `this` Http request to `data` bytes.\n\n\tThere can only be one post data per request. Subsequent calls to\n\tthis method or to `setPostData()` overwrite the previously set value.\n\n\tIf `data` is null, the post data is considered to be absent.\n\n\tThis method provides a fluent interface.",
      "request": "Sends `this` Http request to the Url specified by `this.url`.\n\n\tIf `post` is true, the request is sent as POST request, otherwise it is\n\tsent as GET request.\n\n\tDepending on the outcome of the request, this method calls the\n\t`onStatus()`, `onError()`, `onData()` or `onBytes()` callback functions.\n\n\tIf `this.url` is null, the result is unspecified.\n\n\tIf `this.url` is an invalid or inaccessible Url, the `onError()` callback\n\tfunction is called.\n\n\t[js] If `this.async` is false, the callback functions are called before\n\tthis method returns.",
      "hasOnData": "This method is called upon a successful request, with `data` containing\n\tthe result String.\n\n\tThe intended usage is to bind it to a custom function:\n\t`httpInstance.onData = function(data) { // handle result }`\n*/\npublic dynamic function onData(data:String) {}\n\n/**\n\tThis method is called upon a successful request, with `data` containing\n\tthe result String.\n\n\tThe intended usage is to bind it to a custom function:\n\t`httpInstance.onBytes = function(data) { // handle result }`\n*/\npublic dynamic function onBytes(data:Bytes) {}\n\n/**\n\tThis method is called upon a request error, with `msg` containing the\n\terror description.\n\n\tThe intended usage is to bind it to a custom function:\n\t`httpInstance.onError = function(msg) { // handle error }`\n*/\npublic dynamic function onError(msg:String) {}\n\n/**\n\tThis method is called upon a Http status change, with `status` being the\n\tnew status.\n\n\tThe intended usage is to bind it to a custom function:\n\t`httpInstance.onStatus = function(status) { // handle status }`\n*/\npublic dynamic function onStatus(status:Int) {}\n\n/**\n\tOverride this if extending `haxe.Http` with overriding `onData`"
    },
    "fields": {}
  },
  "haxe.http.abstract": {
    "doc": "HTTP Request Status",
    "path": "haxe\\std\\haxe\\http\\HttpStatus.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Encoding": {
    "doc": "String binary encoding supported by Haxe I/O",
    "path": "haxe\\std\\haxe\\io\\Encoding.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Eof": {
    "doc": "This exception is raised when reading while data is no longer available in the `haxe.io.Input`.",
    "path": "haxe\\std\\haxe\\io\\Eof.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.FPHelper": {
    "doc": "Helper that converts between floating point and binary representation.\nAlways works in low-endian encoding.",
    "path": "haxe\\std\\haxe\\io\\FPHelper.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.class": {
    "doc": "An Output is an abstract write. A specific output implementation will only\nhave to override the `writeByte` and maybe the `write`, `flush` and `close`\nmethods. See `File.write` and `String.write` for two ways of creating an\nOutput.",
    "path": "haxe\\std\\haxe\\io\\Output.hx",
    "functions": {
      "writeBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\n\tReturns the actual length of written data that can differ from `len`.\n\n\tSee `writeFullBytes` that tries to write the exact amount of specified bytes.",
      "flush": "Flush any buffered data.",
      "close": "Close the output.\n\n\tBehaviour while writing after calling this method is unspecified.",
      "write": "Write all bytes stored in `s`.",
      "writeFullBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\n\tUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.",
      "writeFloat": "Write `x` as 32-bit floating point number.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeDouble": "Write `x` as 64-bit double-precision floating point number.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeInt8": "Write `x` as 8-bit signed integer.",
      "writeInt16": "Write `x` as 16-bit signed integer.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeUInt16": "Write `x` as 16-bit unsigned integer.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeInt24": "Write `x` as 24-bit signed integer.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeUInt24": "Write `x` as 24-bit unsigned integer.\n\n\tEndianness is specified by the `bigEndian` property.",
      "writeInt32": "Write `x` as 32-bit signed integer.\n\n\tEndianness is specified by the `bigEndian` property.",
      "prepare": "Inform that we are about to write at least `nbytes` bytes.\n\n\tThe underlying implementation can allocate proper working space depending\n\ton this information, or simply ignore it. This is not a mandatory call\n\tbut a tip and is only used in some specific cases.",
      "writeInput": "Read all available data from `i` and write it.\n\n\tThe `bufsize` optional argument specifies the size of chunks by\n\twhich data is read and written. Its default value is 4096.",
      "writeString": "Write `s` string."
    },
    "fields": {}
  },
  "haxe.io.abstract": {
    "doc": "A scheme consists of a sequence of characters beginning with a letter and followed\nby any combination of letters, digits, plus (`+`, period (`.`), or hyphen (`-`).\n\nAlthough schemes are case-insensitive, the canonical form is lowercase\nand documents that specify schemes must do so with lowercase letters.\nIt is followed by a colon (`:`).",
    "path": "haxe\\std\\haxe\\io\\Scheme.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Path": {
    "doc": "This class provides a convenient way of working with paths. It supports the\ncommon path formats:\n\n- `directory1/directory2/filename.extension`\n- `directory1\\directory2\\filename.extension`",
    "path": "haxe\\std\\haxe\\io\\Path.hx",
    "functions": {
      "toString": "Returns a String representation of `this` path.\n\n\tIf `this.backslash` is `true`, backslash is used as directory separator,\n\totherwise slash is used. This only affects the separator between\n\t`this.dir` and `this.file`.\n\n\tIf `this.directory` or `this.extension` is `null`, their representation\n\tis the empty String `\"\"`.",
      "withoutExtension": "Returns the String representation of `path` without the file extension.\n\n\tIf `path` is `null`, the result is unspecified.",
      "withoutDirectory": "Returns the String representation of `path` without the directory.\n\n\tIf `path` is `null`, the result is unspecified.",
      "directory": "Returns the directory of `path`.\n\n\tIf the directory is `null`, the empty String `\"\"` is returned.\n\n\tIf `path` is `null`, the result is unspecified.",
      "extension": "Returns the extension of `path`.\n\n\tIf `path` has no extension, the empty String `\"\"` is returned.\n\n\tIf `path` is `null`, the result is unspecified.",
      "withExtension": "Returns a String representation of `path` where the extension is `ext`.\n\n\tIf `path` has no extension, `ext` is added as extension.\n\n\tIf `path` or `ext` are `null`, the result is unspecified.",
      "join": "Joins all paths in `paths` together.\n\n\tIf `paths` is empty, the empty String `\"\"` is returned. Otherwise the\n\tpaths are joined with a slash between them.\n\n\tIf `paths` is `null`, the result is unspecified.",
      "normalize": "Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).\n\n\tAlso replaces backslashes `\\` with slashes `/` and afterwards turns\n\tmultiple slashes into a single one.\n\n\tIf `path` is `null`, the result is unspecified.",
      "addTrailingSlash": "Adds a trailing slash to `path`, if it does not have one already.\n\n\tIf the last slash in `path` is a backslash, a backslash is appended to\n\t`path`.\n\n\tIf the last slash in `path` is a slash, or if no slash is found, a slash\n\tis appended to `path`. In particular, this applies to the empty String\n\t`\"\"`.\n\n\tIf `path` is `null`, the result is unspecified.",
      "removeTrailingSlashes": "Removes trailing slashes from `path`.\n\n\tIf `path` does not end with a `/` or `\\`, `path` is returned unchanged.\n\n\tOtherwise the substring of `path` excluding the trailing slashes or\n\tbackslashes is returned.\n\n\tIf `path` is `null`, the result is unspecified.",
      "isAbsolute": "Returns `true` if the path is an absolute path, and `false` otherwise."
    },
    "fields": {
      "file": "The file name.\n\n\tThis is the part of the part between the directory and the extension.\n\n\tIf there is no file name, e.g. for `\".htaccess\"` or `\"/dir/\"`, the value\n\tis the empty String `\"\"`.",
      "ext": "The file extension.\n\n\tIt is separated from the file name by a dot. This dot is not part of\n\tthe extension.\n\n\tIf the path has no extension, the value is `null`.",
      "backslash": "`true` if the last directory separator is a backslash, `false` otherwise."
    }
  },
  "haxe.iterators.ArrayIterator": {
    "doc": "This iterator is used only when `Array<T>` is passed to `Iterable<T>`",
    "path": "haxe\\std\\haxe\\iterators\\ArrayIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessIterator": {
    "doc": "This iterator can be used to iterate over the values of `haxe.DynamicAccess`.",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessIterator.hx",
    "functions": {
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessKeyValueIterator": {
    "doc": "This Key/Value iterator can be used to iterate over `haxe.DynamicAccess`.",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessKeyValueIterator.hx",
    "functions": {
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringIterator": {
    "doc": "This iterator can be used to iterate over char codes in a string.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different of runtimes.",
    "path": "haxe\\std\\haxe\\iterators\\StringIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\nway. It handles surrogate pairs on platforms that require it. On each\niteration, it returns the next character code.\n\nNote that this has different semantics than a standard for-loop over the\nString's length due to the fact that it deals with surrogate pairs.",
    "path": "haxe\\std\\haxe\\iterators\\StringIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`",
      "unicodeIterator": "Convenience function which can be used as a static extension."
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIterator": {
    "doc": "This iterator can be used to iterate over char indexes and char codes in a string.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different runtimes.",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIterator.hx",
    "functions": {
      "hasNext": "See `KeyValueIterator.hasNext`",
      "next": "See `KeyValueIterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\nway. It handles surrogate pairs on platforms that require it. On each\niteration, it returns the next character offset as key and the next\ncharacter code as value.\n\nNote that in the general case, because of surrogate pairs, the key values\nshould not be used as offsets for various String API operations. For the\nsame reason, the last key value returned might be less than `s.length - 1`.",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`",
      "unicodeKeyValueIterator": "Convenience function which can be used as a static extension."
    },
    "fields": {}
  },
  "haxe.macro.CompilationServer": {
    "doc": "Disables file modification checks, avoiding some filesystem operations.\n*/\nvar NoFileSystemCheck = 0;\n\n/**\n\tDefault behavior: check last modification time.\n*/\nvar CheckFileModificationTime = 1;\n\n/**\n\tIf a file is modified, also checks if its content changed. This check\n\tis not free, but useful when .hx files are auto-generated.\n*/\nvar CheckFileContentModification = 2;\n}\n\ntypedef CompilationStats = {\nvar filesParsed:Int;\nvar modulesTyped:Int;\nvar modulesRestoredFromHxb:Int;\nvar classesBuilt:Int;\nvar methodsTyped:Int;\nvar macrosCalled:Int;\n}\n\n/**\nThis class provides some methods which can be invoked from command line using\n`--macro server.field(args)`.",
    "path": "haxe\\std\\haxe\\macro\\CompilationServer.hx",
    "functions": {
      "invalidateModule": "Invalidates a module, removing it from the cache.\n\n\tIf the module has already been loaded in current context, a\n\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\tcaught using `try ... catch`.",
      "invalidateFiles": "Invalidates all files given in `filePaths`, removing them from the cache.",
      "getStats": "Get current compilation server stats counters.\n\n\tCan be called at different compilation stages, or even in the middle of\n\ta macro execution.\n\n\tCounters are reset at the beginning of each request."
    },
    "fields": {
      "CheckFileModificationTime": "Default behavior: check last modification time.",
      "CheckFileContentModification": "If a file is modified, also checks if its content changed. This check\n\tis not free, but useful when .hx files are auto-generated."
    }
  },
  "haxe.macro.Compiler": {
    "doc": "All these methods can be called for compiler configuration macros.",
    "path": "haxe\\std\\haxe\\macro\\Compiler.hx",
    "functions": {
      "define": "Set a conditional compiler flag.\n\n\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "addClassPath": "Add a class path where \".hx\" source files or packages (sub-directories) can be found.\n\n\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "getConfiguration": "Returns all the configuration settings applied to the compiler.\n\n\tUsage of this function outside a macro context returns `null`.",
      "setPlatformConfiguration": "Sets the target configuration.\n\n\tUsage of this function outside a macro context does nothing.",
      "addNativeLib": "Adds a native library depending on the platform (e.g. `-swf-lib` for Flash).\n\n\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "include": "Includes all modules in package `pack` in the compilation.\n\n\tIn order to include single modules, their paths can be listed directly\n\ton command line: `haxe ... ModuleName pack.ModuleName`.\n\n\tBy default `Compiler.include` will search for modules in the directories defined with `-cp`.\n\tIf you want to specify a different set of paths to search for modules, you can use the optional\n\targument `classPath`.\n\n\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n\n\t@param pack The package dot-path as String. Use `''` to include the root package.\n\t@param rec If true, recursively adds all sub-packages.\n\t@param ignore Array of module names to ignore for inclusion.\n\t\t   You can use `module*` with a * at the end for Wildcard matching\n\t@param classPaths An alternative array of paths (directory names) to use to search for modules to include.\n\t\t   Note that if you pass this argument, only the specified paths will be used for inclusion.\n\t@param strict If true and given package wasn't found in any of class paths, fail with an error.",
      "excludeBaseType": "Exclude a class or an enum without changing it to `@:nativeGen`.",
      "exclude": "Exclude a specific class, enum, or all classes and enums in a\n\tpackage from being generated. Excluded types become `extern`.\n\n\t@param pack The package dot-path as String. Use `''` to exclude the root package.\n\t@param rec If true, recursively excludes all sub-packages.",
      "excludeFile": "Exclude classes and enums listed in an extern file (one per line) from being generated.",
      "keep": "Marks types or packages to be kept by DCE.\n\n\tThis also extends to the sub-types of resolved modules.\n\n\tIn order to include module sub-types directly, their full dot path\n\tincluding the containing module has to be used\n\t(e.g. `msignal.Signal.Signal0`).\n\n\tThis operation has no effect if the type has already been loaded, e.g.\n\tthrough `Context.getType`.\n\n\t@param path A package, module or sub-type dot path to keep.\n\t@param paths An Array of package, module or sub-type dot paths to keep.\n\t@param recursive If true, recurses into sub-packages for package paths.",
      "nullSafety": "Enables null safety for a type or a package.\n\n\t@param path A package, module or sub-type dot path to enable null safety for.\n\t@param recursive If true, recurses into sub-packages for package paths.",
      "addGlobalMetadata": "Adds metadata `meta` to all types (if `toTypes = true`) or fields (if\n\t`toFields = true`) whose dot-path matches `pathFilter`.\n\n\tIf `recursive` is true a dot-path is considered matched if it starts\n\twith `pathFilter`. This automatically applies to path filters of\n\tpackages. Otherwise an exact match is required.\n\n\tIf `pathFilter` is the empty String `\"\"` it matches everything (if\n\t`recursive = true`) or only top-level types (if `recursive = false`).\n\n\tThis operation has no effect if the type has already been loaded, e.g.\n\tthrough `Context.getType`.",
      "registerMetadataDescriptionFile": "Reference a json file describing user-defined metadata\n\tSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/meta.json",
      "registerDefinesDescriptionFile": "Reference a json file describing user-defined defines\n\tSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/define.json",
      "registerCustomMetadata": "Register a custom metadata for documentation and completion purposes",
      "registerCustomDefine": "Register a custom define for documentation purposes",
      "setCustomJSGenerator": "Change the default JS output by using a custom generator callback",
      "flushDiskCache": "Clears cached results of file lookups",
      "getHxbWriterConfiguration": "Gets the current hxb writer configuration, if any.",
      "setHxbWriterConfiguration": "Sets the hxb writer configuration to `config`. If no hxb writer configuration\n\texists, it is created.\n\n\tThe intended usage is\n\n\t```\n\tvar config = Compiler.getHxbWriterConfiguration();\n\tconfig.archivePath = \"newPath.zip\";\n\t// Other changes\n\tCompiler.setHxbWriterConfiguration(config);\n\t```\n\n\tIf `config` is `null`, hxb writing is disabled.\n\n\t@see haxe.hxb.WriterConfig"
    },
    "fields": {
      "Closure": "Prepend the file content to the body of the top-level closure.\n\n\tSince the closure is in strict-mode, there may be run-time error if the input is not strict-mode-compatible.",
      "Inline": "Directly inject the file content at the call site.",
      "Off": "Disable null safety.",
      "Loose": "Loose safety.\n\tIf an expression is checked `!= null`, then it's considered safe even if it could be modified after the check.\n\tE.g.\n\t```haxe\n\tfunction example(o:{field:Null<String>}) {\n\t\tif(o.field != null) {\n\t\t\tmutate(o);\n\t\t\tvar notNullable:String = o.field; //no error\n\t\t}\n\t}\n\n\tfunction mutate(o:{field:Null<String>}) {\n\t\to.field = null;\n\t}\n\t```",
      "Strict": "Full scale null safety.\n\tIf a field is checked `!= null` it stays safe until a call is made or any field of any object is reassigned,\n\tbecause that could potentially alter an object of the checked field.\n\tE.g.\n\t```haxe\n\tfunction example(o:{field:Null<String>}, b:{o:{field:Null<String>}}) {\n\t\tif(o.field != null) {\n\t\t\tvar notNullable:String = o.field; //no error\n\t\t\tsomeCall();\n\t\t\tvar notNullable:String = o.field; // Error!\n\t\t}\n\t\tif(o.field != null) {\n\t\t\tvar notNullable:String = o.field; //no error\n\t\t\tb.o = {field:null};\n\t\t\tvar notNullable:String = o.field; // Error!\n\t\t}\n\t}\n\t```",
      "StrictThreaded": "Full scale null safety for a multi-threaded environment.\n\tWith this mode checking a field `!= null` does not make it safe, because it could be changed from another thread\n\tat the same time or immediately after the check.\n\tThe only nullable thing could be safe are local variables."
    }
  },
  "haxe.macro.ComplexTypeTools": {
    "doc": "This class provides some utility methods to work with AST-level types. It is\nbest used through `using haxe.macro.ComplexTypeTools` syntax and then provides\nadditional methods on `haxe.macro.ComplexType` instances.",
    "path": "haxe\\std\\haxe\\macro\\ComplexTypeTools.hx",
    "functions": {
      "toType": "Returns a type corresponding to `c`.\n\n\tIf `c` is null, the result is null."
    },
    "fields": {}
  },
  "haxe.macro.Context": {
    "doc": "Context provides an API for macro programming.\n\nIt contains common functions that interact with the macro interpreter to\nquery or set information. Other API functions are available in the tools\nclasses:\n\n- `haxe.macro.ComplexTypeTools`\n- `haxe.macro.ExprTools`\n- `haxe.macro.TypeTools`",
    "path": "haxe\\std\\haxe\\macro\\Context.hx",
    "functions": {
      "fatalError": "Displays a compilation error `msg` at the given `Position` `pos`\n\tand aborts the compilation.",
      "reportError": "Displays a compilation error `msg` at the given `Position` `pos`\n\twithout aborting the current macro call.",
      "warning": "Displays a compilation warning `msg` at the given `Position` `pos`.",
      "info": "Displays a compilation info `msg` at the given `Position` `pos`.",
      "getMessages": "Gets a list of all current compilation info/warning messages.",
      "filterMessages": "Filters all current info/warning messages. Filtered out messages will\n\tnot be displayed by the compiler.",
      "initMacrosDone": "Check if compiler is past initializations macros or not.\n\tWhen it is, configuration phase is over and parsing/typing can start.",
      "resolvePath": "Resolves a file name `file` based on the current class paths.\n\n\tThe resolution follows the usual class path rules where the last\n\tdeclared class path has priority.\n\n\tIf a class path was declared relative, this method returns the relative\n\tfile path. Otherwise it returns the absolute file path.\n\n\tIf no type can be found, an exception of type `String` is thrown.",
      "getClassPath": "Returns an `Array` of current class paths in the order of their\n\tdeclaration.\n\n\tModifying the returned array has no effect on the compiler. Class paths\n\tcan be added using `haxe.macro.Compiler.addClassPath`.",
      "containsDisplayPosition": "Check if current display position is within `pos`.",
      "currentPos": "Returns the position at which the macro was called.",
      "getMacroStack": "Get the call stack (excluding the call to `Context.getMacroStack()`\n\tthat led to current macro.",
      "getExpectedType": "Returns the type which is expected at the place the macro is called.\n\n\tThis affects usages such as `var x:Int = macroCall()`, where the\n\texpected type will be reported as `Int`.\n\n\tMight return `null` if no specific type is expected or if the calling\n\tmacro is not an expression-macro.",
      "getCallArguments": "Returns the call arguments that lead to the invocation of the current\n\t`@:genericBuild` macro, if available.\n\n\tReturns `null` if the current macro is not a `@:genericBuild` macro.",
      "getLocalClass": "Returns the current class in which the macro was called.\n\n\tIf no such class exists, `null` is returned.",
      "getLocalModule": "Returns the current module path in/on which the macro was called.",
      "getLocalType": "Returns the current type in/on which the macro was called.\n\n\tIf no such type exists, `null` is returned.",
      "getLocalMethod": "Returns the name of the method from which the macro was called.\n\n\tIf no such method exists, `null` is returned.",
      "getLocalUsing": "Returns an `Array` of classes which are available for `using` usage in\n\tthe context the macro was called.\n\n\tModifying the returned array has no effect on the compiler.",
      "getLocalImports": "Returns an `Array` of all imports in the context the macro was called.\n\n\tModifying the returned array has no effect on the compiler.",
      "getLocalVars": "Returns a map of local variables accessible in the context the macro was\n\tcalled.\n\n\tThe keys of the returned map are the variable names, the values are\n\ttheir types.\n\n\tModifying the returned map has no effect on the compiler.",
      "getLocalTVars": "Similar to `getLocalVars`, but returns elements of type `TVar` instead\n\tof `Type`.",
      "defined": "Tells if the conditional compilation flag `s` has been set.\n\n\tCompiler flags are set using the `-D` command line parameter, or\n\tby calling `haxe.macro.Compiler.define`.\n\n\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "definedValue": "Returns the value defined for the conditional compilation flag `key`.\n\n\tIf no value is defined for `key`, `null` is returned.\n\n\tCompiler flags values are set using the `-D key=value` command line\n\tparameter, or by calling `haxe.macro.Compiler.define`.\n\n\tThe default value is `\"1\"`.\n\n\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "getDefines": "Returns a map of all conditional compilation flags that have been set.\n\n\tCompiler flags are set using the `-D` command line parameter, or\n\tby calling `haxe.macro.Compiler.define`.\n\n\tModifying the returned map has no effect on the compiler.\n\n\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "getType": "Resolves a type identified by `name`.\n\n\tThe resolution follows the usual class path rules where the last\n\tdeclared class path has priority.\n\n\tIf no type can be found, an exception of type `String` is thrown.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "getModule": "Resolves a module identified by `name` and returns an `Array` of all\n\tits contained types.\n\n\tThe resolution follows the usual class path rules where the last\n\tdeclared class path has priority.\n\n\tIf no module can be found, an exception of type `String` is thrown.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "getMainExpr": "Returns the typed expression of the call to the main function.\n\n\tThis function will only work in the generation phase. Any calls\n\tmade outside a function passed to `haxe.macro.Context.onGenerate`\n\tor `haxe.macro.Context.onAfterGenerate` will return `null`.",
      "getAllModuleTypes": "Returns an array of module types to be generated in the output.\n\n\tThis list may change depending on the phase of compilation and\n\tshould not be treated as conclusive until the generation phase.\n\n\tModifying the returned array has no effect on the compilation.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "parse": "Parses `expr` as Haxe code, returning the corresponding AST.\n\n\tString interpolation of single quote strings within `expr` is not\n\tsupported.\n\n\tThe provided `Position` `pos` is used for all generated inner AST nodes.",
      "parseInlineString": "Similar to `parse`, but error positions are reported within the provided\n\tString `expr`.",
      "registerFileContents": "Parse file content for newlines, allowing positions to be resolved\n\tproperly inside that file later on (using `Context.parseInlineString`\n\tfor example). Works with both real and virtual files.",
      "makeExpr": "Builds an expression from `v`.\n\n\tThis method generates AST nodes depending on the macro-runtime value of\n\t`v`. As such, only basic types and enums are supported and the behavior\n\tfor other types is undefined.\n\n\tThe provided `Position` `pos` is used for all generated inner AST nodes.",
      "signature": "Returns a hashed MD5 signature of value `v`.",
      "onGenerate": "Adds a callback function `callback` which is invoked after the\n\tcompiler's typing phase, just before its generation phase.\n\n\tThe callback receives an `Array` containing all types which are about\n\tto be generated. Modifications are limited to metadata, it is mainly\n\tintended to obtain information.\n\n\tBy default, the callback is made before types are stored in the compilation\n\tserver, if active. This means that any effect persists for the next compilation.\n\tIf `persistent` is set to `false`, changes to types made by the callback only\n\taffect the current compilation. If no compilation server is used, this flag has\n\tno effect.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.",
      "onAfterGenerate": "Adds a callback function `callback` which is invoked after the compiler\n\tgeneration phase.\n\n\tCompilation has completed at this point and cannot be influenced\n\tanymore. However, contextual information is still available.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.",
      "onAfterTyping": "Adds a callback function `callback` which is invoked after the compiler\n\tis done typing, but before optimization. The callback receives the types\n\twhich have been typed.\n\n\tIt is possible to define new types in the callback, in which case it\n\twill be called again with the new types as argument.",
      "onAfterInitMacros": "Adds a callback function `callback` which is invoked after the compiler\n\tis done running initialization macros, when typing begins.\n\n\t`onAfterInitMacros` should be used to delay typer-dependant code from\n\tyour initialization macros, to properly separate configuration phase and\n\tactual typing.",
      "onTypeNotFound": "Adds a callback function `callback` which is invoked when a type name\n\tcannot be resolved.\n\n\tThe callback may return a type definition, which is then used for the\n\texpected type. If it returns `null`, the type is considered to still not\n\texist.",
      "typeof": "Types expression `e` and returns its type.\n\n\tTyping the expression may result in a compiler error which can be\n\tcaught using `try ... catch`.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "typeExpr": "Types expression `e` and returns the corresponding `TypedExpr`.\n\n\tTyping the expression may result in a compiler error which can be\n\tcaught using `try ... catch`. Note that not all compiler errors can\n\tbe caught this way because the compiler might delay various checks\n\tto a later stage, at which point the exception handler is no longer\n\tactive.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "resolveType": "Resolve type `t` and returns the corresponding `Type`.\n\n\tResolving the type may result in a compiler error which can be\n\tcaught using `try ... catch`.\n\tResolution is performed based on the current context in which the macro is called.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "resolveComplexType": "Resolve type `t` and returns the corresponding `ComplexType`.\n\n\tResolving the type may result in a compiler error which can be\n\tcaught using `try ... catch`.\n\tResolution is performed based on the current context in which the macro is called.\n\tThe difference with `resolveType` is that it only performs type resolution, it does not\n\tbuild any type or trigger macros.",
      "toComplexType": "Returns the `ComplexType` corresponding to the given `Type` `t`.\n\n\tSee `haxe.macro.TypeTools.toComplexType` for details.",
      "unify": "Tries to unify `t1` and `t2` and returns `true` if successful.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "follow": "Follows a type.\n\n\tSee `haxe.macro.TypeTools.follow` for details.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "followWithAbstracts": "Follows a type, including abstracts' underlying implementation\n\n\tSee `haxe.macro.TypeTools.followWithAbstracts` for details.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "getPosInfos": "Returns the information stored in `Position` `p`.",
      "makePosition": "Builds a `Position` from `inf`.",
      "getResources": "Returns a map of all registered resources for this compilation unit.\n\n\tModifying the returned map has no effect on the compilation, use\n\t`haxe.macro.Context.addResource` to add new resources to the compilation unit.",
      "addResource": "Makes resource `data` available as `name`.\n\n\tThe resource is then available using the `haxe.macro.Resource` API.\n\n\tIf a previous resource was bound to `name`, it is overwritten.\n\n\tCompilation server : when using the compilation server, the resource is bound\n\tto the Haxe module which calls the macro, so it will be included again if\n\tthat module is reused. If this resource concerns several modules, prefix its\n\tname with a `$` sign, this will bind it to the macro module instead.",
      "getBuildFields": "Returns an `Array` of fields of the class which is to be built.\n\n\tThis is only defined for `@:build/@:autoBuild` macros.",
      "defineType": "Defines a new type from `TypeDefinition` `t`.\n\n\tIf a matching module has already been loaded in current context, a\n\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\tcaught using `try ... catch`.\n\n\tIf `moduleDependency` is given and is not `null`, it should contain\n\ta module path that will be used as a dependency for the newly defined module\n\tinstead of the current module.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "makeMonomorph": "Creates and returns a new instance of monomorph (`TMono`) type.\n\n\tReturned monomorph can be used with e.g. `Context.unify` to make the compiler\n\tbind the monomorph to an actual type and let macro further process the resulting type.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "defineModule": "Defines a new module as `modulePath` with several `TypeDefinition`\n\t`types`. This is analogous to defining a .hx file.\n\n\tIf a matching module has already been loaded in current context, a\n\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\tcaught using `try ... catch`.\n\n\tThe individual `types` can reference each other and any identifier\n\trespects the `imports` and `usings` as usual, expect that imports are\n\tnot allowed to have `.*` wildcards or `as s` shorthands.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "getTypedExpr": "Returns a syntax-level expression corresponding to typed expression `t`.\n\n\tThis process may lose some information.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "storeTypedExpr": "Store typed expression `t` internally and give a syntax-level expression\n\tthat can be returned from a macro and will be replaced by the stored\n\ttyped expression.\n\n\tIf `t` is `null` or invalid, an exception is thrown.\n\n\tNOTE: the returned value references an internally stored typed expression\n\tthat is reset between compilations, so care should be taken when storing\n\tthe expression returned by this method in a static variable and using the\n\tcompilation server.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "storeExpr": "Types expression `e`, stores the resulting typed expression internally and\n\treturns a syntax-level expression that can be returned from a macro and\n\twill be replaced by the stored typed expression.\n\n\tIf `e` is `null` or invalid, an exception is thrown.\n\n\tA call to `storeExpr(e)` is equivalent to `storeTypedExpr(typeExpr(e))` without\n\tthe overhead of encoding and decoding between regular and macro runtime.\n\n\tNOTE: the returned value references an internally stored typed expression\n\tthat is reset between compilations, so care should be taken when storing\n\tthe expression returned by this method in a static variable and using the\n\tcompilation server.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "typeAndStoreExpr": "This function works like `storeExpr`, but also returns access to the expression's\n\ttype through the `type` field of the return value.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "registerModuleDependency": "Manually adds a dependency between module `modulePath` and an external\n\tfile `externFile`.\n\n\tThis affects the compilation cache, causing the module to be typed if\n\t`externFile` has changed.\n\n\tHas no effect if the compilation cache is not used.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "timer": "Creates a timer which will be printed in the compilation report\n\tif `--times` compilation argument is set.\n\n\tNote that a timer may be omitted from the report if the amount of time\n\tmeasured is too small.\n\n\tThis method immediately starts a timer and returns a function to stop it:\n\t```\n\tvar stopTimer = haxe.macro.Context.timer(\"my heavy task\");\n\trunTask();\n\tstopTimer();\n\t```",
      "withImports": "Executes `code` in a context that has `imports` and `usings` added.\n\n\tThis is equivalent to temporarily having `import` and `using` statements in a file. These\n\tare only active during the execution of `code` and do not affect anything afterwards. This\n\tis true even if `code` throws an exception.\n\n\tIf any argument is `null`, the result is unspecified.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used.",
      "withOptions": "Executes `code` in a context that has some compiler options set, restore the compiler to its\n\tdefault behavior afterwards.\n\n\t`allowInlining`: enable or disable inlining during typing with `typeExpr`.\n\n\t`allowTransform`: when disabled, the code typed with `typeExpr` will be almost exactly the same\n\tas the input code. This will disable some abstract types transformations.\n\n\tUsage of this function from initialization macros is deprecated and may\n\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\trun your code once typer is ready to be used."
    },
    "fields": {}
  },
  "haxe.macro.Constant": {
    "doc": "Represents a position in a file.\n*/\ntypedef Position = {\n/**\n\tReference to the filename.\n*/\nvar file:String;\n\n/**\n\tPosition of the first character.\n*/\nvar min:Int;\n\n/**\n\tPosition of the last character.\n*/\nvar max:Int;\n}\n#end\n\nenum StringLiteralKind {\nDoubleQuotes;\nSingleQuotes;\n}\n\n/**\nRepresents a constant.\n@see https://haxe.org/manual/expression-constants.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "min": "Position of the first character.",
      "max": "Position of the last character.",
      "expr": "Represents a constant.\n@see https://haxe.org/manual/expression-constants.html\n*/\nenum Constant {\n/**\n\tRepresents an integer literal.\n*/\nCInt(v:String, ?s:String);\n\n/**\n\tRepresents a float literal.\n*/\nCFloat(f:String, ?s:String);\n\n/**\n\tRepresents a string literal.\n*/\nCString(s:String, ?kind:StringLiteralKind);\n\n/**\n\tRepresents an identifier.\n*/\nCIdent(s:String);\n\n/**\n\tRepresents a regular expression literal.\n\n\tExample: `~/haxe/i`\n\n\t- The first argument `haxe` is a string with regular expression pattern.\n\t- The second argument `i` is a string with regular expression flags.\n\n\t@see https://haxe.org/manual/std-regex.html\n*/\nCRegexp(r:String, opt:String);\n}\n\n/**\nA binary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Binop {\n/**\n\t`+`\n*/\nOpAdd;\n\n/**\n\t`*`\n*/\nOpMult;\n\n/**\n\t`/`\n*/\nOpDiv;\n\n/**\n\t`-`\n*/\nOpSub;\n\n/**\n\t`=`\n*/\nOpAssign;\n\n/**\n\t`==`\n*/\nOpEq;\n\n/**\n\t`!=`\n*/\nOpNotEq;\n\n/**\n\t`>`\n*/\nOpGt;\n\n/**\n\t`>=`\n*/\nOpGte;\n\n/**\n\t`<`\n*/\nOpLt;\n\n/**\n\t`<=`\n*/\nOpLte;\n\n/**\n\t`&`\n*/\nOpAnd;\n\n/**\n\t`|`\n*/\nOpOr;\n\n/**\n\t`^`\n*/\nOpXor;\n\n/**\n\t`&&`\n*/\nOpBoolAnd;\n\n/**\n\t`||`\n*/\nOpBoolOr;\n\n/**\n\t`<<`\n*/\nOpShl;\n\n/**\n\t`>>`\n*/\nOpShr;\n\n/**\n\t`>>>`\n*/\nOpUShr;\n\n/**\n\t`%`\n*/\nOpMod;\n\n/**\n\t`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\nOpAssignOp(op:Binop);\n\n/**\n\t`...`\n*/\nOpInterval;\n\n/**\n\t`=>`\n*/\nOpArrow;\n\n/**\n\t`in`\n*/\nOpIn;\n\n/**\n\t`??`\n*/\nOpNullCoal;\n}\n\n/**\nA unary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Unop {\n/**\n\t`++`\n*/\nOpIncrement;\n\n/**\n\t`--`\n*/\nOpDecrement;\n\n/**\n\t`!`\n*/\nOpNot;\n\n/**\n\t`-`\n*/\nOpNeg;\n\n/**\n\t`~`\n*/\nOpNegBits;\n\n/**\n\t`...`\n*/\nOpSpread;\n}\n\nenum EFieldKind {\nNormal;\nSafe;\n}\n\n/**\nRepresents a node in the AST.\n@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n/**\n\tThe expression kind."
    }
  },
  "haxe.macro.Binop": {
    "doc": "Represents an integer literal.\n*/\nCInt(v:String, ?s:String);\n\n/**\n\tRepresents a float literal.\n*/\nCFloat(f:String, ?s:String);\n\n/**\n\tRepresents a string literal.\n*/\nCString(s:String, ?kind:StringLiteralKind);\n\n/**\n\tRepresents an identifier.\n*/\nCIdent(s:String);\n\n/**\n\tRepresents a regular expression literal.\n\n\tExample: `~/haxe/i`\n\n\t- The first argument `haxe` is a string with regular expression pattern.\n\t- The second argument `i` is a string with regular expression flags.\n\n\t@see https://haxe.org/manual/std-regex.html\n*/\nCRegexp(r:String, opt:String);\n}\n\n/**\nA binary operator.\n@see https://haxe.org/manual/types-numeric-operators.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Unop": {
    "doc": "`+`\n*/\nOpAdd;\n\n/**\n\t`*`\n*/\nOpMult;\n\n/**\n\t`/`\n*/\nOpDiv;\n\n/**\n\t`-`\n*/\nOpSub;\n\n/**\n\t`=`\n*/\nOpAssign;\n\n/**\n\t`==`\n*/\nOpEq;\n\n/**\n\t`!=`\n*/\nOpNotEq;\n\n/**\n\t`>`\n*/\nOpGt;\n\n/**\n\t`>=`\n*/\nOpGte;\n\n/**\n\t`<`\n*/\nOpLt;\n\n/**\n\t`<=`\n*/\nOpLte;\n\n/**\n\t`&`\n*/\nOpAnd;\n\n/**\n\t`|`\n*/\nOpOr;\n\n/**\n\t`^`\n*/\nOpXor;\n\n/**\n\t`&&`\n*/\nOpBoolAnd;\n\n/**\n\t`||`\n*/\nOpBoolOr;\n\n/**\n\t`<<`\n*/\nOpShl;\n\n/**\n\t`>>`\n*/\nOpShr;\n\n/**\n\t`>>>`\n*/\nOpUShr;\n\n/**\n\t`%`\n*/\nOpMod;\n\n/**\n\t`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\nOpAssignOp(op:Binop);\n\n/**\n\t`...`\n*/\nOpInterval;\n\n/**\n\t`=>`\n*/\nOpArrow;\n\n/**\n\t`in`\n*/\nOpIn;\n\n/**\n\t`??`\n*/\nOpNullCoal;\n}\n\n/**\nA unary operator.\n@see https://haxe.org/manual/types-numeric-operators.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.QuoteStatus": {
    "doc": "`++`\n*/\nOpIncrement;\n\n/**\n\t`--`\n*/\nOpDecrement;\n\n/**\n\t`!`\n*/\nOpNot;\n\n/**\n\t`-`\n*/\nOpNeg;\n\n/**\n\t`~`\n*/\nOpNegBits;\n\n/**\n\t`...`\n*/\nOpSpread;\n}\n\nenum EFieldKind {\nNormal;\nSafe;\n}\n\n/**\nRepresents a node in the AST.\n@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n/**\n\tThe expression kind.\n*/\nvar expr:ExprDef;\n\n/**\n\tThe position of the expression.\n*/\nvar pos:Position;\n}\n\n/**\nRepresents a AST node identical to `Expr`, but it allows constraining the\ntype of accepted expressions.\n@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\nRepresents a switch case.\n@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n/**\n\tThe value expressions of the case.\n*/\nvar values:Array<Expr>;\n\n/**\n\tThe optional guard expressions of the case, if available.\n*/\nvar ?guard:Expr;\n\n/**\n\tThe expression of the case, if available.\n*/\nvar ?expr:Expr;\n}\n\n/**\nRepresents a variable in the AST.\n@see https://haxe.org/manual/expression-var.html\n*/\ntypedef Var = {\n/**\n\tThe name of the variable.\n*/\nvar name:String;\n\n/**\n\tThe position of the variable name.\n*/\nvar ?namePos:Position;\n\n/**\n\tThe type-hint of the variable, if available.\n*/\nvar ?type:ComplexType;\n\n/**\n\tThe expression of the variable, if available.\n*/\nvar ?expr:Expr;\n\n/**\n\tWhether or not the variable can be assigned to.\n*/\nvar ?isFinal:Bool;\n\n/**\n\tWhether or not the variable is static.\n*/\nvar ?isStatic:Bool;\n\n/**\n\tMetadata associated with the variable, if available.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a catch in the AST.\n@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n/**\n\tThe name of the catch variable.\n*/\nvar name:String;\n\n/**\n\tThe type of the catch.\n*/\nvar ?type:ComplexType;\n\n/**\n\tThe expression of the catch.\n*/\nvar expr:Expr;\n}\n\n/**\nRepresents the way something is quoted.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "pos": "The position of the expression.",
      "values": "Represents a AST node identical to `Expr`, but it allows constraining the\ntype of accepted expressions.\n@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\nRepresents a switch case.\n@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n/**\n\tThe value expressions of the case.",
      "name": "The position of the variable name.\n*/\nvar ?namePos:Position;\n\n/**\n\tThe type-hint of the variable, if available.\n*/\nvar ?type:ComplexType;\n\n/**\n\tThe expression of the variable, if available.\n*/\nvar ?expr:Expr;\n\n/**\n\tWhether or not the variable can be assigned to.\n*/\nvar ?isFinal:Bool;\n\n/**\n\tWhether or not the variable is static.\n*/\nvar ?isStatic:Bool;\n\n/**\n\tMetadata associated with the variable, if available.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a catch in the AST.\n@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n/**\n\tThe name of the catch variable.",
      "expr": "The type of the catch.\n*/\nvar ?type:ComplexType;\n\n/**\n\tThe expression of the catch.",
      "field": "Represents the way something is quoted.\n*/\nenum QuoteStatus {\n/**\n\tNo quotes\n*/\nUnquoted;\n\n/**\n\tDouble quotes `\"`\n*/\nQuoted;\n}\n\n/**\nRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n/**\n\tThe name of the field."
    }
  },
  "haxe.macro.FunctionKind": {
    "doc": "No quotes\n*/\nUnquoted;\n\n/**\n\tDouble quotes `\"`\n*/\nQuoted;\n}\n\n/**\nRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n/**\n\tThe name of the field.\n*/\nvar field:String;\n\n/**\n\tThe field expression.\n*/\nvar expr:Expr;\n\n/**\n\tHow the field name is quoted.\n*/\nvar ?quotes:QuoteStatus;\n}\n\n/**\nRepresents function kind in the AST",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "expr": "The field expression.",
      "pack": "How the field name is quoted.\n*/\nvar ?quotes:QuoteStatus;\n}\n\n/**\nRepresents function kind in the AST\n*/\nenum FunctionKind {\n/**\n\tAnonymous function\n*/\nFAnonymous;\n\n/**\n\tNamed function\n*/\nFNamed(name:String, ?inlined:Bool);\n\n/**\n\tArrow function\n*/\nFArrow;\n}\n\n/**\nRepresents the kind of a node in the AST.\n*/\nenum ExprDef {\n/**\n\tA constant.\n*/\nEConst(c:Constant);\n\n/**\n\tArray access `e1[e2]`.\n*/\nEArray(e1:Expr, e2:Expr);\n\n/**\n\tBinary operator `e1 op e2`.\n*/\nEBinop(op:Binop, e1:Expr, e2:Expr);\n\n/**\n\tField access on `e.field`.\n\n\tIf `kind` is null, it is equal to Normal.\n*/\nEField(e:Expr, field:String, ?kind:EFieldKind);\n\n/**\n\tParentheses `(e)`.\n*/\nEParenthesis(e:Expr);\n\n/**\n\tAn object declaration.\n*/\nEObjectDecl(fields:Array<ObjectField>);\n\n/**\n\tAn array declaration `[el]`.\n*/\nEArrayDecl(values:Array<Expr>);\n\n/**\n\tA call `e(params)`.\n*/\nECall(e:Expr, params:Array<Expr>);\n\n/**\n\tA constructor call `new t(params)`.\n*/\nENew(t:TypePath, params:Array<Expr>);\n\n/**\n\tAn unary operator `op` on `e`:\n\n\t- `e++` (`op = OpIncrement, postFix = true`)\n\t- `e--` (`op = OpDecrement, postFix = true`)\n\t- `++e` (`op = OpIncrement, postFix = false`)\n\t- `--e` (`op = OpDecrement, postFix = false`)\n\t- `-e` (`op = OpNeg, postFix = false`)\n\t- `!e` (`op = OpNot, postFix = false`)\n\t- `~e` (`op = OpNegBits, postFix = false`)\n*/\nEUnop(op:Unop, postFix:Bool, e:Expr);\n\n/**\n\tVariable declarations.\n*/\nEVars(vars:Array<Var>);\n\n/**\n\tA function declaration.\n*/\nEFunction(kind:Null<FunctionKind>, f:Function);\n\n/**\n\tA block of expressions `{exprs}`.\n*/\nEBlock(exprs:Array<Expr>);\n\n/**\n\tA `for` expression.\n*/\nEFor(it:Expr, expr:Expr);\n\n/**\n\tAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\nEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n/**\n\tRepresents a `while` expression.\n\n\tWhen `normalWhile` is `true` it is `while (...)`.\n\n\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n/**\n\tRepresents a `switch` expression with related cases and an optional.\n\t`default` case if `edef != null`.\n*/\nESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n/**\n\tRepresents a `try`-expression with related catches.\n*/\nETry(e:Expr, catches:Array<Catch>);\n\n/**\n\tA `return` or `return e` expression.\n*/\nEReturn(?e:Expr);\n\n/**\n\tA `break` expression.\n*/\nEBreak;\n\n/**\n\tA `continue` expression.\n*/\nEContinue;\n\n/**\n\tAn `untyped e` source code.\n*/\nEUntyped(e:Expr);\n\n/**\n\tA `throw e` expression.\n*/\nEThrow(e:Expr);\n\n/**\n\tA `cast e` or `cast (e, m)` expression.\n*/\nECast(e:Expr, t:Null<ComplexType>);\n\n/**\n\tUsed internally to provide completion.\n*/\nEDisplay(e:Expr, displayKind:DisplayKind);\n\n/**\n\tA `(econd) ? eif : eelse` expression.\n*/\nETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n/**\n\tA `(e:t)` expression.\n*/\nECheckType(e:Expr, t:ComplexType);\n\n/**\n\tA `@m e` expression.\n*/\nEMeta(s:MetadataEntry, e:Expr);\n\n/**\n\tAn `expr is Type` expression.\n*/\nEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\nDKCall;\nDKDot;\nDKStructure;\nDKMarked;\nDKPattern(outermost:Bool);\n}\n\n/**\nRepresents a type syntax in the AST.\n*/\nenum ComplexType {\n/**\n\tRepresents the type path.\n*/\nTPath(p:TypePath);\n\n/**\n\tRepresents a function type.\n\t@see https://haxe.org/manual/types-function.html\n*/\nTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n/**\n\tRepresents an anonymous structure type.\n\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(fields:Array<Field>);\n\n/**\n\tRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n\t`(Int -> Void) -> String`.\n*/\nTParent(t:ComplexType);\n\n/**\n\tRepresents typedef extensions `> Iterable<T>`.\n\tThe array `p` holds the type paths to the given types.\n\t@see https://haxe.org/manual/type-system-extensions.html\n*/\nTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n/**\n\tRepresents an optional type.\n*/\nTOptional(t:ComplexType);\n\n/**\n\tRepresents a type with a name.\n*/\nTNamed(n:String, t:ComplexType);\n\n/**\n\tRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\nTIntersection(tl:Array<ComplexType>);\n}\n\n/**\nRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n/**\n\tRepresents the package of the type path."
    }
  },
  "haxe.macro.ExprDef": {
    "doc": "Anonymous function\n*/\nFAnonymous;\n\n/**\n\tNamed function\n*/\nFNamed(name:String, ?inlined:Bool);\n\n/**\n\tArrow function\n*/\nFArrow;\n}\n\n/**\nRepresents the kind of a node in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ComplexType": {
    "doc": "A constant.\n*/\nEConst(c:Constant);\n\n/**\n\tArray access `e1[e2]`.\n*/\nEArray(e1:Expr, e2:Expr);\n\n/**\n\tBinary operator `e1 op e2`.\n*/\nEBinop(op:Binop, e1:Expr, e2:Expr);\n\n/**\n\tField access on `e.field`.\n\n\tIf `kind` is null, it is equal to Normal.\n*/\nEField(e:Expr, field:String, ?kind:EFieldKind);\n\n/**\n\tParentheses `(e)`.\n*/\nEParenthesis(e:Expr);\n\n/**\n\tAn object declaration.\n*/\nEObjectDecl(fields:Array<ObjectField>);\n\n/**\n\tAn array declaration `[el]`.\n*/\nEArrayDecl(values:Array<Expr>);\n\n/**\n\tA call `e(params)`.\n*/\nECall(e:Expr, params:Array<Expr>);\n\n/**\n\tA constructor call `new t(params)`.\n*/\nENew(t:TypePath, params:Array<Expr>);\n\n/**\n\tAn unary operator `op` on `e`:\n\n\t- `e++` (`op = OpIncrement, postFix = true`)\n\t- `e--` (`op = OpDecrement, postFix = true`)\n\t- `++e` (`op = OpIncrement, postFix = false`)\n\t- `--e` (`op = OpDecrement, postFix = false`)\n\t- `-e` (`op = OpNeg, postFix = false`)\n\t- `!e` (`op = OpNot, postFix = false`)\n\t- `~e` (`op = OpNegBits, postFix = false`)\n*/\nEUnop(op:Unop, postFix:Bool, e:Expr);\n\n/**\n\tVariable declarations.\n*/\nEVars(vars:Array<Var>);\n\n/**\n\tA function declaration.\n*/\nEFunction(kind:Null<FunctionKind>, f:Function);\n\n/**\n\tA block of expressions `{exprs}`.\n*/\nEBlock(exprs:Array<Expr>);\n\n/**\n\tA `for` expression.\n*/\nEFor(it:Expr, expr:Expr);\n\n/**\n\tAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\nEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n/**\n\tRepresents a `while` expression.\n\n\tWhen `normalWhile` is `true` it is `while (...)`.\n\n\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n/**\n\tRepresents a `switch` expression with related cases and an optional.\n\t`default` case if `edef != null`.\n*/\nESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n/**\n\tRepresents a `try`-expression with related catches.\n*/\nETry(e:Expr, catches:Array<Catch>);\n\n/**\n\tA `return` or `return e` expression.\n*/\nEReturn(?e:Expr);\n\n/**\n\tA `break` expression.\n*/\nEBreak;\n\n/**\n\tA `continue` expression.\n*/\nEContinue;\n\n/**\n\tAn `untyped e` source code.\n*/\nEUntyped(e:Expr);\n\n/**\n\tA `throw e` expression.\n*/\nEThrow(e:Expr);\n\n/**\n\tA `cast e` or `cast (e, m)` expression.\n*/\nECast(e:Expr, t:Null<ComplexType>);\n\n/**\n\tUsed internally to provide completion.\n*/\nEDisplay(e:Expr, displayKind:DisplayKind);\n\n/**\n\tA `(econd) ? eif : eelse` expression.\n*/\nETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n/**\n\tA `(e:t)` expression.\n*/\nECheckType(e:Expr, t:ComplexType);\n\n/**\n\tA `@m e` expression.\n*/\nEMeta(s:MetadataEntry, e:Expr);\n\n/**\n\tAn `expr is Type` expression.\n*/\nEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\nDKCall;\nDKDot;\nDKStructure;\nDKMarked;\nDKPattern(outermost:Bool);\n}\n\n/**\nRepresents a type syntax in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeParam": {
    "doc": "Represents the type path.\n*/\nTPath(p:TypePath);\n\n/**\n\tRepresents a function type.\n\t@see https://haxe.org/manual/types-function.html\n*/\nTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n/**\n\tRepresents an anonymous structure type.\n\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(fields:Array<Field>);\n\n/**\n\tRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n\t`(Int -> Void) -> String`.\n*/\nTParent(t:ComplexType);\n\n/**\n\tRepresents typedef extensions `> Iterable<T>`.\n\tThe array `p` holds the type paths to the given types.\n\t@see https://haxe.org/manual/type-system-extensions.html\n*/\nTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n/**\n\tRepresents an optional type.\n*/\nTOptional(t:ComplexType);\n\n/**\n\tRepresents a type with a name.\n*/\nTNamed(n:String, t:ComplexType);\n\n/**\n\tRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\nTIntersection(tl:Array<ComplexType>);\n}\n\n/**\nRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n/**\n\tRepresents the package of the type path.\n*/\nvar pack:Array<String>;\n\n/**\n\tThe name of the type path.\n*/\nvar name:String;\n\n/**\n\tOptional parameters of the type path.\n*/\nvar ?params:Array<TypeParam>;\n\n/**\n\tSub is set on module sub-type access:\n\t`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\nvar ?sub:String;\n\n/**\n\tThe full position of the type path, including type parameters.\n*/\nvar ?pos:Position;\n\n/**\n\tThe position of the dot-path itself, without type parameters.\n*/\nvar ?posPath:Position;\n}\n\n/**\nRepresents a concrete type parameter in the AST.\n\nHaxe allows expressions in concrete type parameters, e.g.\n`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\nin the normal case it's `TPType`.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "Optional parameters of the type path.\n*/\nvar ?params:Array<TypeParam>;\n\n/**\n\tSub is set on module sub-type access:\n\t`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\nvar ?sub:String;\n\n/**\n\tThe full position of the type path, including type parameters.\n*/\nvar ?pos:Position;\n\n/**\n\tThe position of the dot-path itself, without type parameters.\n*/\nvar ?posPath:Position;\n}\n\n/**\nRepresents a concrete type parameter in the AST.\n\nHaxe allows expressions in concrete type parameters, e.g.\n`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\nin the normal case it's `TPType`.\n*/\nenum TypeParam {\nTPType(t:ComplexType);\nTPExpr(e:Expr);\n}\n\n/**\nRepresents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n/**\n\tThe name of the type parameter."
    }
  },
  "haxe.macro.Access": {
    "doc": "Represents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n/**\n\tThe name of the type parameter.\n*/\nvar name:String;\n\n/**\n\tThe optional constraints of the type parameter.\n*/\nvar ?constraints:Array<ComplexType>;\n\n/**\n\tThe optional default type of the type parameter.\n*/\nvar ?defaultType:Null<ComplexType>;\n\n/**\n\tThe optional parameters of the type parameter.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\n\tThe metadata of the type parameter.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a function in the AST.\n*/\ntypedef Function = {\n/**\n\tA list of function arguments.\n*/\nvar args:Array<FunctionArg>;\n\n/**\n\tThe return type-hint of the function, if available.\n*/\nvar ?ret:ComplexType;\n\n/**\n\tThe expression of the function body, if available.\n*/\nvar ?expr:Expr;\n\n/**\n\tAn optional list of function parameter type declarations.\n*/\nvar ?params:Array<TypeParamDecl>;\n}\n\n/**\nRepresents a function argument in the AST.\n*/\ntypedef FunctionArg = {\n/**\n\tThe name of the function argument.\n*/\nvar name:String;\n\n/**\n\tWhether or not the function argument is optional.\n*/\nvar ?opt:Bool;\n\n/**\n\tThe type-hint of the function argument, if available.\n*/\nvar ?type:ComplexType;\n\n/**\n\tThe optional value of the function argument, if available.\n*/\nvar ?value:Expr;\n\n/**\n\tThe metadata of the function argument.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a metadata entry in the AST.\n*/\ntypedef MetadataEntry = {\n/**\n\tThe name of the metadata entry.\n*/\nvar name:String;\n\n/**\n\tThe optional parameters of the metadata entry.\n*/\nvar ?params:Array<Expr>;\n\n/**\n\tThe position of the metadata entry.\n*/\nvar pos:Position;\n}\n\n/**\nRepresents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\nRepresents a field in the AST.\n*/\ntypedef Field = {\n/**\n\tThe name of the field.\n*/\nvar name:String;\n\n/**\n\tThe documentation of the field, if available. If the field has no\n\tdocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\n\tThe access modifiers of the field. By default fields have private access.\n\t@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nvar ?access:Array<Access>;\n\n/**\n\tThe kind of the field.\n*/\nvar kind:FieldType;\n\n/**\n\tThe position of the field.\n*/\nvar pos:Position;\n\n/**\n\tThe optional metadata of the field.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents an access modifier.\n@see https://haxe.org/manual/class-field-access-modifier.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "args": "The optional constraints of the type parameter.\n*/\nvar ?constraints:Array<ComplexType>;\n\n/**\n\tThe optional default type of the type parameter.\n*/\nvar ?defaultType:Null<ComplexType>;\n\n/**\n\tThe optional parameters of the type parameter.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\n\tThe metadata of the type parameter.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a function in the AST.\n*/\ntypedef Function = {\n/**\n\tA list of function arguments.",
      "name": "Represents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\nRepresents a field in the AST.\n*/\ntypedef Field = {\n/**\n\tThe name of the field.",
      "pos": "The position of the field.",
      "kind": "The documentation of the field, if available. If the field has no\n\tdocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\n\tThe access modifiers of the field. By default fields have private access.\n\t@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nvar ?access:Array<Access>;\n\n/**\n\tThe kind of the field.",
      "pack": "The optional metadata of the field.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents an access modifier.\n@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nenum Access {\n/**\n\tPublic access modifier, grants access from anywhere.\n\t@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPublic;\n\n/**\n\tPrivate access modifier, grants access to class and its sub-classes\n\tonly.\n\t@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPrivate;\n\n/**\n\tStatic access modifier.\n*/\nAStatic;\n\n/**\n\tOverride access modifier.\n\t@see https://haxe.org/manual/class-field-override.html\n*/\nAOverride;\n\n/**\n\tDynamic (re-)bindable access modifier.\n\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\nADynamic;\n\n/**\n\tInline access modifier. Allows expressions to be directly inserted in\n\tplace of calls to them.\n\t@see https://haxe.org/manual/class-field-inline.html\n*/\nAInline;\n\n/**\n\tMacro access modifier. Allows expression macro functions. These are\n\tnormal functions which are executed as soon as they are typed.\n*/\nAMacro;\n\n/**\n\tFinal access modifier. For functions, they can not be overridden. For\n\tvariables, it means they can be assigned to only once.\n*/\nAFinal;\n\n/**\n\tExtern access modifier.\n*/\nAExtern;\n\n/**\n\tAbstract access modifier.\n*/\nAAbstract;\n\n/**\n\tOverload access modifier.\n*/\nAOverload;\n\n/**\n\tEnum access modifier.\n*/\nAEnum;\n}\n\n/**\nRepresents the field type in the AST.\n*/\nenum FieldType {\n/**\n\tRepresents a variable field type.\n*/\nFVar(t:Null<ComplexType>, ?e:Expr);\n\n/**\n\tRepresents a function field type.\n*/\nFFun(f:Function);\n\n/**\n\tRepresents a property with getter and setter field type.\n*/\nFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\nRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n/**\n\tThe package of the type definition."
    }
  },
  "haxe.macro.FieldType": {
    "doc": "Public access modifier, grants access from anywhere.\n\t@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPublic;\n\n/**\n\tPrivate access modifier, grants access to class and its sub-classes\n\tonly.\n\t@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPrivate;\n\n/**\n\tStatic access modifier.\n*/\nAStatic;\n\n/**\n\tOverride access modifier.\n\t@see https://haxe.org/manual/class-field-override.html\n*/\nAOverride;\n\n/**\n\tDynamic (re-)bindable access modifier.\n\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\nADynamic;\n\n/**\n\tInline access modifier. Allows expressions to be directly inserted in\n\tplace of calls to them.\n\t@see https://haxe.org/manual/class-field-inline.html\n*/\nAInline;\n\n/**\n\tMacro access modifier. Allows expression macro functions. These are\n\tnormal functions which are executed as soon as they are typed.\n*/\nAMacro;\n\n/**\n\tFinal access modifier. For functions, they can not be overridden. For\n\tvariables, it means they can be assigned to only once.\n*/\nAFinal;\n\n/**\n\tExtern access modifier.\n*/\nAExtern;\n\n/**\n\tAbstract access modifier.\n*/\nAAbstract;\n\n/**\n\tOverload access modifier.\n*/\nAOverload;\n\n/**\n\tEnum access modifier.\n*/\nAEnum;\n}\n\n/**\nRepresents the field type in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeDefKind": {
    "doc": "Represents a variable field type.\n*/\nFVar(t:Null<ComplexType>, ?e:Expr);\n\n/**\n\tRepresents a function field type.\n*/\nFFun(f:Function);\n\n/**\n\tRepresents a property with getter and setter field type.\n*/\nFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\nRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n/**\n\tThe package of the type definition.\n*/\nvar pack:Array<String>;\n\n/**\n\tThe name of the type definition.\n*/\nvar name:String;\n\n/**\n\tThe documentation of the type, if available. If the type has no\n\tdocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\n\tThe position to the type definition.\n*/\nvar pos:Position;\n\n/**\n\tThe optional metadata of the type definition.\n*/\nvar ?meta:Metadata;\n\n/**\n\tThe parameter type declarations of the type definition.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\n\tWhether or not the type is extern.\n*/\nvar ?isExtern:Bool;\n\n/**\n\tThe kind of the type definition.\n*/\nvar kind:TypeDefKind;\n\n/**\n\tThe fields of the type definition.\n*/\nvar fields:Array<Field>;\n}\n\n/**\nRepresents a type definition kind.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "The name of the type definition.",
      "pos": "Represents a type definition kind.\n*/\nenum TypeDefKind {\n/**\n\tRepresents an enum kind.\n*/\nTDEnum;\n\n/**\n\tRepresents a structure kind.\n*/\nTDStructure;\n\n/**\n\tRepresents a class kind.\n*/\nTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n/**\n\tRepresents an alias/typedef kind.\n*/\nTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n/**\n\tRepresents an abstract kind.\n*/\nTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n/**\n\tRepresents a module-level field.\n*/\nTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\nRepresents an abstract flag.\n*/\nenum AbstractFlag {\n/**\n\tIndicates that this abstract is an `enum abstract`\n*/\nAbEnum;\n\n/**\n\tIndicates that this abstract can be assigned from `ct`.\n\tThis flag can be added several times to add multiple \"from\" types.\n*/\nAbFrom(ct:ComplexType);\n\n/**\n\tIndicates that this abstract can be assigned to `ct`.\n\tThis flag can be added several times to add multiple \"to\" types.\n*/\nAbTo(ct:ComplexType);\n}\n\n/**\nThis error can be used to handle or produce compilation errors in macros.\n*/\nclass Error extends Exception {\n/**\n\tThe position of the error.",
      "kind": "The optional metadata of the type definition.\n*/\nvar ?meta:Metadata;\n\n/**\n\tThe parameter type declarations of the type definition.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\n\tWhether or not the type is extern.\n*/\nvar ?isExtern:Bool;\n\n/**\n\tThe kind of the type definition.",
      "fields": "The fields of the type definition."
    }
  },
  "haxe.macro.AbstractFlag": {
    "doc": "Represents an enum kind.\n*/\nTDEnum;\n\n/**\n\tRepresents a structure kind.\n*/\nTDStructure;\n\n/**\n\tRepresents a class kind.\n*/\nTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n/**\n\tRepresents an alias/typedef kind.\n*/\nTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n/**\n\tRepresents an abstract kind.\n*/\nTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n/**\n\tRepresents a module-level field.\n*/\nTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\nRepresents an abstract flag.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Error": {
    "doc": "Indicates that this abstract is an `enum abstract`\n*/\nAbEnum;\n\n/**\n\tIndicates that this abstract can be assigned from `ct`.\n\tThis flag can be added several times to add multiple \"from\" types.\n*/\nAbFrom(ct:ComplexType);\n\n/**\n\tIndicates that this abstract can be assigned to `ct`.\n\tThis flag can be added several times to add multiple \"to\" types.\n*/\nAbTo(ct:ComplexType);\n}\n\n/**\nThis error can be used to handle or produce compilation errors in macros.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ImportMode": {
    "doc": "The position of the error.\n*/\npublic var pos:Position;\n\n/**\n\tChild error messages, if any.\n*/\nprivate var childErrors:Array<Error>;\n\n/**\n\tInstantiates an error with given message and position.\n*/\npublic function new(message:String, pos:Position, ?previous:Exception) {\n\tsuper(message, previous);\n\tthis.pos = pos;\n}\n}\n\n/**\nRepresents the import mode.\n@see https://haxe.org/manual/type-system-import.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "childErrors": "Child error messages, if any.",
      "path": "Instantiates an error with given message and position.\n*/\npublic function new(message:String, pos:Position, ?previous:Exception) {\n\tsuper(message, previous);\n\tthis.pos = pos;\n}\n}\n\n/**\nRepresents the import mode.\n@see https://haxe.org/manual/type-system-import.html\n*/\nenum ImportMode {\n/**\n\tRepresents a default import `import c`.\n*/\nINormal;\n\n/**\n\tRepresents the alias import `import c as alias`.\n*/\nIAsName(alias:String);\n\n/**\n\tRepresents the wildcard import `import *`.\n*/\nIAll;\n}\n\n/**\nRepresents the import expression.\n*/\ntypedef ImportExpr = {\n/**\n\tThe path to the import expression.",
      "mode": "The mode of the import expression."
    }
  },
  "haxe.macro.ExprTools": {
    "doc": "This class provides some utility methods to work with expressions. It is\nbest used through 'using haxe.macro.ExprTools' syntax and then provides\nadditional methods on haxe.macro.Expr instances.\n\nWhile mainly intended to be used in macros, it works in non-macro code as\nwell.",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ExprArrayTools": {
    "doc": "Converts expression `e` to a human-readable String representation.\n\n\tThe result is guaranteed to be valid Haxe code, but there may be\n\tdifferences from the original lexical syntax.\n*/\nstatic public function toString(e:Expr):String\n\treturn new Printer().printExpr(e);\n\n/**\n\tCalls function `f` on each sub-expression of `e`.\n\n\tIf `e` has no sub-expressions, this operation has no effect.\n\n\tOtherwise `f` is called once per sub-expression of `e`, with the\n\tsub-expression as argument. These calls are done in order of the\n\tsub-expression declarations.\n\n\tThis method does not call itself recursively. It should instead be used\n\tin a recursive function which handles the expression nodes of interest.\n\n\tUsage example:\n\t```haxe\n\tfunction findStrings(e:Expr) {\n\t\tswitch(e.expr) {\n\t\t\tcase EConst(CString(s)):\n\t\t\t\t// handle s\n\t\t\tcase _:\n\t\t\t\tExprTools.iter(e, findStrings);\n\t\t}\n\t}\n\t```\n*/\nstatic public function iter(e:Expr, f:Expr->Void):Void {\n\tswitch (e.expr) {\n\t\tcase EConst(_), EContinue, EBreak:\n\t\tcase EField(e, _), EParenthesis(e), EUntyped(e), EThrow(e), EDisplay(e, _), ECheckType(e, _), EUnop(_, _, e), ECast(e, _), EIs(e, _) | EMeta(_, e):\n\t\t\tf(e);\n\t\tcase EArray(e1, e2), EWhile(e1, e2, _), EBinop(_, e1, e2), EFor(e1, e2):\n\t\t\tf(e1);\n\t\t\tf(e2);\n\t\tcase EVars(vl):\n\t\t\tfor (v in vl)\n\t\t\t\topt2(v.expr, f);\n\t\tcase ETry(e, cl):\n\t\t\tf(e);\n\t\t\tfor (c in cl)\n\t\t\t\tf(c.expr);\n\t\tcase ETernary(e1, e2, e3) | EIf(e1, e2, e3):\n\t\t\tf(e1);\n\t\t\tf(e2);\n\t\t\topt2(e3, f);\n\t\tcase EArrayDecl(el), ENew(_, el), EBlock(el):\n\t\t\tExprArrayTools.iter(el, f);\n\t\tcase EObjectDecl(fl):\n\t\t\tfor (fd in fl)\n\t\t\t\tf(fd.expr);\n\t\tcase ECall(e, el):\n\t\t\tf(e);\n\t\t\tExprArrayTools.iter(el, f);\n\t\tcase EReturn(e):\n\t\t\topt2(e, f);\n\t\tcase EFunction(_, func):\n\t\t\tfor (arg in func.args)\n\t\t\t\topt2(arg.value, f);\n\t\t\topt2(func.expr, f);\n\t\tcase ESwitch(e, cl, edef):\n\t\t\tf(e);\n\t\t\tfor (c in cl) {\n\t\t\t\tExprArrayTools.iter(c.values, f);\n\t\t\t\topt2(c.guard, f);\n\t\t\t\topt2(c.expr, f);\n\t\t\t}\n\t\t\tif (edef != null && edef.expr != null)\n\t\t\t\tf(edef);\n\t}\n}\n\n/**\n\tTransforms the sub-expressions of `e` by calling `f` on each of them.\n\n\tIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\n\tOtherwise `f` is called once per sub-expression of `e`, with the\n\tsub-expression as argument. These calls are done in order of the\n\tsub-expression declarations.\n\n\tThis method does not call itself recursively. It should instead be used\n\tin a recursive function which handles the expression nodes of interest.\n\n\tUsage example:\n\t```haxe\n\tfunction capitalizeStrings(e:Expr) {\n\t\treturn switch(e.expr) {\n\t\t\tcase EConst(CString(s)):\n\t\t\t\t{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\n\t\t\tcase _:\n\t\t\t\tExprTools.map(e, capitalizeStrings);\n\t\t}\n\t}\n\t```\n*/\nstatic public function map(e:Expr, f:Expr->Expr):Expr {\n\treturn {\n\t\tpos: e.pos,\n\t\texpr: switch (e.expr) {\n\t\t\tcase EConst(_): e.expr;\n\t\t\tcase EArray(e1, e2): EArray(f(e1), f(e2));\n\t\t\tcase EBinop(op, e1, e2): EBinop(op, f(e1), f(e2));\n\t\t\tcase EField(e, field, kind): EField(f(e), field, kind);\n\t\t\tcase EParenthesis(e): EParenthesis(f(e));\n\t\t\tcase EObjectDecl(fields):\n\t\t\t\tvar ret = [];\n\t\t\t\tfor (field in fields)\n\t\t\t\t\tret.push({field: field.field, expr: f(field.expr), quotes: field.quotes});\n\t\t\t\tEObjectDecl(ret);\n\t\t\tcase EArrayDecl(el): EArrayDecl(ExprArrayTools.map(el, f));\n\t\t\tcase ECall(e, params): ECall(f(e), ExprArrayTools.map(params, f));\n\t\t\tcase ENew(tp, params): ENew(tp, ExprArrayTools.map(params, f));\n\t\t\tcase EUnop(op, postFix, e): EUnop(op, postFix, f(e));\n\t\t\tcase EVars(vars):\n\t\t\t\tvar ret = [];\n\t\t\t\tfor (v in vars) {\n\t\t\t\t\tvar v2:Var = {name: v.name, type: v.type, expr: opt(v.expr, f)};\n\t\t\t\t\tif (v.isFinal != null)\n\t\t\t\t\t\tv2.isFinal = v.isFinal;\n\t\t\t\t\tif (v.isStatic != null)\n\t\t\t\t\t\tv2.isStatic = v.isStatic;\n\t\t\t\t\tret.push(v2);\n\t\t\t\t}\n\t\t\t\tEVars(ret);\n\t\t\tcase EBlock(el): EBlock(ExprArrayTools.map(el, f));\n\t\t\tcase EFor(it, expr): EFor(f(it), f(expr));\n\t\t\tcase EIf(econd, eif, eelse): EIf(f(econd), f(eif), opt(eelse, f));\n\t\t\tcase EWhile(econd, e, normalWhile): EWhile(f(econd), f(e), normalWhile);\n\t\t\tcase EReturn(e): EReturn(opt(e, f));\n\t\t\tcase EUntyped(e): EUntyped(f(e));\n\t\t\tcase EThrow(e): EThrow(f(e));\n\t\t\tcase ECast(e, t): ECast(f(e), t);\n\t\t\tcase EIs(e, t): EIs(f(e), t);\n\t\t\tcase EDisplay(e, dk): EDisplay(f(e), dk);\n\t\t\tcase ETernary(econd, eif, eelse): ETernary(f(econd), f(eif), f(eelse));\n\t\t\tcase ECheckType(e, t): ECheckType(f(e), t);\n\t\t\tcase EContinue, EBreak:\n\t\t\t\te.expr;\n\t\t\tcase ETry(e, catches):\n\t\t\t\tvar ret = [];\n\t\t\t\tfor (c in catches)\n\t\t\t\t\tret.push({name: c.name, type: c.type, expr: f(c.expr)});\n\t\t\t\tETry(f(e), ret);\n\t\t\tcase ESwitch(e, cases, edef):\n\t\t\t\tvar ret = [];\n\t\t\t\tfor (c in cases)\n\t\t\t\t\tret.push({expr: opt(c.expr, f), guard: opt(c.guard, f), values: ExprArrayTools.map(c.values, f)});\n\t\t\t\tESwitch(f(e), ret, edef == null || edef.expr == null ? edef : f(edef));\n\t\t\tcase EFunction(kind, func):\n\t\t\t\tvar ret = [];\n\t\t\t\tfor (arg in func.args)\n\t\t\t\t\tret.push({\n\t\t\t\t\t\tname: arg.name,\n\t\t\t\t\t\topt: arg.opt,\n\t\t\t\t\t\ttype: arg.type,\n\t\t\t\t\t\tvalue: opt(arg.value, f)\n\t\t\t\t\t});\n\t\t\t\tEFunction(kind, {\n\t\t\t\t\targs: ret,\n\t\t\t\t\tret: func.ret,\n\t\t\t\t\tparams: func.params,\n\t\t\t\t\texpr: f(func.expr)\n\t\t\t\t});\n\t\t\tcase EMeta(m, e): EMeta(m, f(e));\n\t\t}\n\t};\n}\n\n/**\n\tReturns the value `e` represents.\n\n\tSupported expressions are:\n\n\t - `Int`, `Float` and `String` literals\n\t - identifiers `true`, `false` and `null`\n\t - structure declarations if all their fields are values\n\t - array declarations if all their elements are values\n\t - unary operators `-`, `!` and `~` if the operand is a value\n\t - binary operators except `=>`, `...` and assignments\n\n\tParentheses, metadata and the `untyped` keyword are ignored.\n\n\tIf any non-value is encountered, an exception of type `String` is\n\tthrown.\n\n\tIf `e` is null, the result is unspecified.\n*/\nstatic public function getValue(e:Expr):Dynamic {\n\treturn switch (e.expr) {\n\t\tcase EConst(CInt(v)): Std.parseInt(v);\n\t\tcase EConst(CFloat(v)): Std.parseFloat(v);\n\t\tcase EConst(CString(s)): s;\n\t\tcase EConst(CIdent(\"true\")): true;\n\t\tcase EConst(CIdent(\"false\")): false;\n\t\tcase EConst(CIdent(\"null\")): null;\n\t\tcase EParenthesis(e1) | EUntyped(e1) | EMeta(_, e1): getValue(e1);\n\t\tcase EObjectDecl(fields):\n\t\t\tvar obj = {};\n\t\t\tfor (field in fields) {\n\t\t\t\tReflect.setField(obj, field.field, getValue(field.expr));\n\t\t\t}\n\t\t\tobj;\n\t\tcase EArrayDecl(el): el.map(getValue);\n\t\tcase EIf(econd, eif, eelse) | ETernary(econd, eif, eelse):\n\t\t\tif (eelse == null) {\n\t\t\t\tthrow \"If statements only have a value if the else clause is defined\";\n\t\t\t} else {\n\t\t\t\tvar econd:Dynamic = getValue(econd);\n\t\t\t\tecond ? getValue(eif) : getValue(eelse);\n\t\t\t}\n\t\tcase EUnop(op, false, e1):\n\t\t\tvar e1:Dynamic = getValue(e1);\n\t\t\tswitch (op) {\n\t\t\t\tcase OpNot: !e1;\n\t\t\t\tcase OpNeg: -e1;\n\t\t\t\tcase OpNegBits: ~e1;\n\t\t\t\tcase _: throw 'Unsupported expression: $e';\n\t\t\t}\n\t\tcase EBinop(op, e1, e2):\n\t\t\tvar e1:Dynamic = getValue(e1);\n\t\t\tvar e2:Dynamic = getValue(e2);\n\t\t\tswitch (op) {\n\t\t\t\tcase OpAdd: e1 + e2;\n\t\t\t\tcase OpSub: e1 - e2;\n\t\t\t\tcase OpMult: e1 * e2;\n\t\t\t\tcase OpDiv: e1 / e2;\n\t\t\t\tcase OpMod: e1 % e2;\n\t\t\t\tcase OpEq: e1 == e2;\n\t\t\t\tcase OpNotEq: e1 != e2;\n\t\t\t\tcase OpLt: e1 < e2;\n\t\t\t\tcase OpLte: e1 <= e2;\n\t\t\t\tcase OpGt: e1 > e2;\n\t\t\t\tcase OpGte: e1 >= e2;\n\t\t\t\tcase OpOr: e1 | e2;\n\t\t\t\tcase OpAnd: e1 & e2;\n\t\t\t\tcase OpXor: e1 ^ e2;\n\t\t\t\tcase OpBoolAnd: e1 && e2;\n\t\t\t\tcase OpBoolOr: e1 || e2;\n\t\t\t\tcase OpShl: e1 << e2;\n\t\t\t\tcase OpShr: e1 >> e2;\n\t\t\t\tcase OpUShr: e1 >>> e2;\n\t\t\t\tcase _: throw 'Unsupported expression: $e';\n\t\t\t}\n\t\tcase _: throw 'Unsupported expression: $e';\n\t}\n}\n\nstatic inline function opt(e:Null<Expr>, f:Expr->Expr):Expr\n\treturn e == null ? null : f(e);\n\nstatic inline function opt2(e:Null<Expr>, f:Expr->Void):Void\n\tif (e != null)\n\t\tf(e);\n}\n\n/**\nThis class provides functions on expression arrays for convenience. For a\ndetailed reference on each method, see the documentation of ExprTools.",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\n\tIf `e` has no sub-expressions, this operation has no effect.\n\n\tOtherwise `f` is called once per sub-expression of `e`, with the\n\tsub-expression as argument. These calls are done in order of the\n\tsub-expression declarations.\n\n\tThis method does not call itself recursively. It should instead be used\n\tin a recursive function which handles the expression nodes of interest.\n\n\tUsage example:\n\t```haxe\n\tfunction findStrings(e:Expr) {\n\t\tswitch(e.expr) {\n\t\t\tcase EConst(CString(s)):\n\t\t\t\t// handle s\n\t\t\tcase _:\n\t\t\t\tExprTools.iter(e, findStrings);\n\t\t}\n\t}\n\t```",
      "map": "Transforms the sub-expressions of `e` by calling `f` on each of them.\n\n\tIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\n\tOtherwise `f` is called once per sub-expression of `e`, with the\n\tsub-expression as argument. These calls are done in order of the\n\tsub-expression declarations.\n\n\tThis method does not call itself recursively. It should instead be used\n\tin a recursive function which handles the expression nodes of interest.\n\n\tUsage example:\n\t```haxe\n\tfunction capitalizeStrings(e:Expr) {\n\t\treturn switch(e.expr) {\n\t\t\tcase EConst(CString(s)):\n\t\t\t\t{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\n\t\t\tcase _:\n\t\t\t\tExprTools.map(e, capitalizeStrings);\n\t\t}\n\t}\n\t```",
      "getValue": "Returns the value `e` represents.\n\n\tSupported expressions are:\n\n\t - `Int`, `Float` and `String` literals\n\t - identifiers `true`, `false` and `null`\n\t - structure declarations if all their fields are values\n\t - array declarations if all their elements are values\n\t - unary operators `-`, `!` and `~` if the operand is a value\n\t - binary operators except `=>`, `...` and assignments\n\n\tParentheses, metadata and the `untyped` keyword are ignored.\n\n\tIf any non-value is encountered, an exception of type `String` is\n\tthrown.\n\n\tIf `e` is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.macro.Format": {
    "doc": "The actual macro implemented for Std.format",
    "path": "haxe\\std\\haxe\\macro\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MacroStringTools": {
    "doc": "This class provides some utility methods to work with strings in macro\ncontext.",
    "path": "haxe\\std\\haxe\\macro\\MacroStringTools.hx",
    "functions": {
      "isFormatExpr": "Tells if `e` is a format string, i.e. uses single quotes `'` as\n\tdelimiters.",
      "toFieldExpr": "Converts an array of Strings `sl` to a field expression.\n\n\tIf `sl` has no elements, the result is null.\n\n\tIf `sl` has one element, the result is `EConst(CIdent(sl[0])`.\n\n\tOtherwise the result is a chain of `EField` nodes.\n\n\tIf `sl` is null, the result is unspecified.",
      "toDotPath": "Converts a path given by package `pack` and name `name` to a `String`\n\tseparated by dots.\n\n\tIf `pack` has no elements, the result is `name`.\n\n\tIf `pack` is null, the result is unspecified.\n\n\tOtherwise the elements of `pack` are joined with a separating dot, with\n\tan appended dot separating the result from `name`."
    },
    "fields": {}
  },
  "haxe.macro.MacroType": {
    "doc": "This type is meant to be used to generate custom types using a macro.\nFor instance by doing MacroType<[my.Class.myMacro(55)]>",
    "path": "haxe\\std\\haxe\\macro\\MacroType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Printer": {
    "doc": "This class provides some utility methods to convert elements from the\nmacro context to a human-readable String representation.\n\nThis is only guaranteed to work with data that corresponds to valid Haxe\nsyntax.",
    "path": "haxe\\std\\haxe\\macro\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Type": {
    "doc": "Represents a reference to internal compiler structure. It exists to avoid\nexpensive encoding if it is not required and to ensure that physical\nequality remains intact.\n\nA structure is only encoded when user requests it through `ref.get()`.\n/\ntypedef Ref<T> = {\npublic function get():T;\npublic function toString():String;\n}\n\n/**\nRepresents a type.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.AnonStatus": {
    "doc": "Represents a monomorph.\n\n\t@see https://haxe.org/manual/types-monomorph.html\n*/\nTMono(t:Ref<Null<Type>>);\n\n/**\n\tRepresents an enum instance.\n\n\t@see https://haxe.org/manual/types-enum-instance.html\n*/\nTEnum(t:Ref<EnumType>, params:Array<Type>);\n\n/**\n\tRepresents a class instance.\n\n\t@see https://haxe.org/manual/types-class-instance.html\n*/\nTInst(t:Ref<ClassType>, params:Array<Type>);\n\n/**\n\tRepresents a typedef.\n\n\t@see https://haxe.org/manual/type-system-typedef.html\n*/\nTType(t:Ref<DefType>, params:Array<Type>);\n\n/**\n\tRepresents a function type.\n\n\t@see https://haxe.org/manual/types-function.html\n*/\nTFun(args:Array<{name:String, opt:Bool, t:Type}>, ret:Type);\n\n/**\n\tRepresents an anonymous structure type.\n\n\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(a:Ref<AnonType>);\n\n/**\n\tRepresents Dynamic.\n\n\t@see https://haxe.org/manual/types-dynamic.html\n*/\nTDynamic(t:Null<Type>);\n\n/**\n\tUsed internally by the compiler to delay some typing.\n*/\nTLazy(f:Void->Type);\n\n/**\n\tRepresents an abstract type.\n\n\t@see https://haxe.org/manual/types-abstract.html\n*/\nTAbstract(t:Ref<AbstractType>, params:Array<Type>);\n}\n\n/**\nRepresents information for anonymous structure types.\n/\ntypedef AnonType = {\n/**\n\tThe class fields of the structure.\n*/\nvar fields:Array<ClassField>;\n\n/**\n\tThe status/kind of the structure.\n*/\nvar status:AnonStatus;\n}\n\n/**\nRepresents the kind of the anonymous structure type.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "status": "The status/kind of the structure.",
      "name": "Represents the kind of the anonymous structure type.\n*/\nenum AnonStatus {\n/**\n\tA closed structure is considered complete. That is, no further fields\n\tcan be added to it.\n*/\nAClosed;\n\n/**\n\tAn open structure allows having additional fields added to it, which is\n\tused during type inference. It is closed upon unification.\n*/\nAOpened;\n\n/**\n\tA const structure is one that appears directly in syntax. It cannot be\n\tassigned to a smaller structure type (that is, it does not allow\n\tstructural sub-typing).\n*/\nAConst;\n\n/**\n\tRepresents a structure which extends one or multiple structures defined\n\tin `tl`.\n\n\t@see https://haxe.org/manual/type-system-extensions.html\n*/\nAExtend(tl:Ref<Array<Type>>);\n\n/**\n\tA structure that represents the static fields of a class.\n*/\nAClassStatics(t:Ref<ClassType>);\n\n/**\n\tA structure that represents the constructors of an enum.\n*/\nAEnumStatics(t:Ref<EnumType>);\n\n/**\n\tA structure that represents the static fields of an abstract.\n*/\nAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\nRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n/**\n\tThe name of the type parameter."
    }
  },
  "haxe.macro.ClassKind": {
    "doc": "A closed structure is considered complete. That is, no further fields\n\tcan be added to it.\n*/\nAClosed;\n\n/**\n\tAn open structure allows having additional fields added to it, which is\n\tused during type inference. It is closed upon unification.\n*/\nAOpened;\n\n/**\n\tA const structure is one that appears directly in syntax. It cannot be\n\tassigned to a smaller structure type (that is, it does not allow\n\tstructural sub-typing).\n*/\nAConst;\n\n/**\n\tRepresents a structure which extends one or multiple structures defined\n\tin `tl`.\n\n\t@see https://haxe.org/manual/type-system-extensions.html\n*/\nAExtend(tl:Ref<Array<Type>>);\n\n/**\n\tA structure that represents the static fields of a class.\n*/\nAClassStatics(t:Ref<ClassType>);\n\n/**\n\tA structure that represents the constructors of an enum.\n*/\nAEnumStatics(t:Ref<EnumType>);\n\n/**\n\tA structure that represents the static fields of an abstract.\n*/\nAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\nRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n/**\n\tThe name of the type parameter.\n*/\nvar name:String;\n\n/**\n\tThe type of the type parameter. It is guaranteed to be a `TInst` with a\n\t`KTypeParameter` kind.\n*/\nvar t:Type;\n\n/**\n\tThe default type for this type parameter.\n*/\nvar ?defaultType:Null<Type>;\n}\n\n/**\nRepresents a class field.\n/\ntypedef ClassField = {\n/**\n\tThe name of the class field.\n*/\nvar name:String;\n\n/**\n\tThe type of the class field.\n*/\nvar type:Type;\n\n/**\n\tWhether or not the class field is public.\n*/\nvar isPublic:Bool;\n\n/**\n\tWhether or not the class field is extern.\n*/\nvar isExtern:Bool;\n\n/**\n\tWhether or not the class field is final.\n*/\nvar isFinal:Bool;\n\n/**\n\tWhether or not the class field is abstract.\n*/\nvar isAbstract:Bool;\n\n/**\n\tThe type parameters of the class field.\n*/\nvar params:Array<TypeParameter>;\n\n/**\n\tThe metadata of the class field.\n*/\nvar meta:MetaAccess;\n\n/**\n\tThe class field kind.\n*/\nvar kind:FieldKind;\n\n/**\n\tReturns the typed expression of the class field.\n*/\nfunction expr():Null<TypedExpr>;\n\n/**\n\tThe position of the class field.\n*/\nvar pos:Expr.Position;\n\n/**\n\tThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\n\tThe overload fields of the class field.\n*/\nvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\nRepresents an enum constructor.\n/\ntypedef EnumField = {\n/**\n\tThe name of the enum constructor.\n*/\nvar name:String;\n\n/**\n\tThe type of the enum constructor.\n*/\nvar type:Type;\n\n/**\n\tThe position of the enum constructor.\n*/\nvar pos:Expr.Position;\n\n/**\n\tThe metadata of the enum constructor.\n*/\nvar meta:MetaAccess;\n\n/**\n\tThe index of the enum constructor, i.e. in which position it appears\n\tin the syntax.\n*/\nvar index:Int;\n\n/**\n\tThe associated documentation of the enum constructor.\n*/\nvar doc:Null<String>;\n\n/**\n\tThe type parameters of the enum constructor.\n*/\nvar params:Array<TypeParameter>;\n}\n\n/**\nRepresents the kind of a class.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "exclude": "The position of the class field.\n*/\nvar pos:Expr.Position;\n\n/**\n\tThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\n\tThe overload fields of the class field.\n*/\nvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\nRepresents an enum constructor.\n/\ntypedef EnumField = {\n/**\n\tThe name of the enum constructor.\n*/\nvar name:String;\n\n/**\n\tThe type of the enum constructor.\n*/\nvar type:Type;\n\n/**\n\tThe position of the enum constructor.\n*/\nvar pos:Expr.Position;\n\n/**\n\tThe metadata of the enum constructor.\n*/\nvar meta:MetaAccess;\n\n/**\n\tThe index of the enum constructor, i.e. in which position it appears\n\tin the syntax.\n*/\nvar index:Int;\n\n/**\n\tThe associated documentation of the enum constructor.\n*/\nvar doc:Null<String>;\n\n/**\n\tThe type parameters of the enum constructor.\n*/\nvar params:Array<TypeParameter>;\n}\n\n/**\nRepresents the kind of a class.\n/\nenum ClassKind {\n/**\n\tA normal class.\n*/\nKNormal;\n\n/**\n\tA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\n\tA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\n\tA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\n\tA `@:generic` base class.\n*/\nKGeneric;\n\n/**\n\tA concrete `@:generic` instance, referencing the original class and the\n\tapplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\n\tA special class for `haxe.macro.MacroType`.\n\n\t@deprecated\n*/\nKMacroType;\n\n/**\n\tAn implementation class of an abstract, i.e. where all its run-time code\n\tis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\n\tA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\n\tThe package of the type.\n*/\nvar pack:Array<String>;\n\n/**\n\tThe name of the type.\n*/\nvar name:String;\n\n/**\n\tThe module name of the type, which might be different.\n*/\nvar module:String;\n\n/**\n\tThe position of the type.\n*/\nvar pos:Expr.Position;\n\n/**\n\tWhether or not the type is private.\n*/\nvar isPrivate:Bool;\n\n/**\n\tWhether or not the type is extern.\n*/\nvar isExtern:Bool;\n\n/**\n\tThe type parameters of the type.\n*/\nvar params:Array<TypeParameter>;\n\n/**\n\tThe metadata of the type.\n*/\nvar meta:MetaAccess;\n\n/**\n\tThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\n\tAllows excluding the type from compilation."
    },
    "fields": {
      "t": "The type of the type parameter. It is guaranteed to be a `TInst` with a\n\t`KTypeParameter` kind.",
      "name": "Represents an enum constructor.\n/\ntypedef EnumField = {\n/**\n\tThe name of the enum constructor.",
      "type": "The type of the enum constructor.",
      "isPublic": "Whether or not the class field is public.",
      "isExtern": "Whether or not the class field is extern.",
      "isFinal": "Whether or not the class field is final.",
      "isAbstract": "Whether or not the class field is abstract.",
      "params": "The type parameters of the enum constructor.",
      "meta": "The metadata of the enum constructor.",
      "kind": "The class field kind.",
      "pos": "The position of the enum constructor.",
      "doc": "The associated documentation of the enum constructor.",
      "overloads": "The overload fields of the class field.",
      "index": "The index of the enum constructor, i.e. in which position it appears\n\tin the syntax.",
      "pack": "Represents the kind of a class.\n/\nenum ClassKind {\n/**\n\tA normal class.\n*/\nKNormal;\n\n/**\n\tA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\n\tA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\n\tA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\n\tA `@:generic` base class.\n*/\nKGeneric;\n\n/**\n\tA concrete `@:generic` instance, referencing the original class and the\n\tapplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\n\tA special class for `haxe.macro.MacroType`.\n\n\t@deprecated\n*/\nKMacroType;\n\n/**\n\tAn implementation class of an abstract, i.e. where all its run-time code\n\tis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\n\tA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\n\tThe package of the type."
    }
  },
  "haxe.macro.FieldKind": {
    "doc": "A normal class.\n*/\nKNormal;\n\n/**\n\tA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\n\tA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\n\tA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\n\tA `@:generic` base class.\n*/\nKGeneric;\n\n/**\n\tA concrete `@:generic` instance, referencing the original class and the\n\tapplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\n\tA special class for `haxe.macro.MacroType`.\n\n\t@deprecated\n*/\nKMacroType;\n\n/**\n\tAn implementation class of an abstract, i.e. where all its run-time code\n\tis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\n\tA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\n\tThe package of the type.\n*/\nvar pack:Array<String>;\n\n/**\n\tThe name of the type.\n*/\nvar name:String;\n\n/**\n\tThe module name of the type, which might be different.\n*/\nvar module:String;\n\n/**\n\tThe position of the type.\n*/\nvar pos:Expr.Position;\n\n/**\n\tWhether or not the type is private.\n*/\nvar isPrivate:Bool;\n\n/**\n\tWhether or not the type is extern.\n*/\nvar isExtern:Bool;\n\n/**\n\tThe type parameters of the type.\n*/\nvar params:Array<TypeParameter>;\n\n/**\n\tThe metadata of the type.\n*/\nvar meta:MetaAccess;\n\n/**\n\tThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\n\tAllows excluding the type from compilation.\n*/\nfunction exclude():Void;\n}\n\n/**\nRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\n\tThe kind of the class.\n*/\nvar kind:ClassKind;\n\n/**\n\tIf true the type is an interface, otherwise it is a class.\n*/\nvar isInterface:Bool;\n\n/**\n\tIf true the class is final and cannot be extended.\n*/\nvar isFinal:Bool;\n\n/**\n\tIf true the class is abstract and cannot be instantiated directly.\n*/\nvar isAbstract:Bool;\n\n/**\n\tThe parent class and its type parameters, if available.\n*/\nvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\n\tThe implemented interfaces and their type parameters.\n*/\nvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\n\tThe member fields of the class.\n*/\nvar fields:Ref<Array<ClassField>>;\n\n/**\n\tThe static fields of the class.\n*/\nvar statics:Ref<Array<ClassField>>;\n\n// var dynamic : Null<Type>;\n// var arrayAccess : Null<Type>;\n\n/**\n\tThe constructor of the class, if available.\n*/\nvar constructor:Null<Ref<ClassField>>;\n\n/**\n\tThe `__init__` expression of the class, if available.\n*/\nvar init:Null<TypedExpr>;\n\n/**\n\tThe list of fields that have override status.\n*/\nvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\nRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\n\tThe available enum constructors.\n*/\nvar constructs:Map<String, EnumField>;\n\n/**\n\tAn ordered list of enum constructor names.\n*/\nvar names:Array<String>;\n}\n\n/**\nRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n/**\n\tThe target type of the typedef.\n*/\nvar type:Type;\n}\n\n/**\nRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\n\tThe underlying type of the abstract.\n*/\nvar type:Type;\n\n/**\n\tThe implementation class of the abstract, if available.\n*/\nvar impl:Null<Ref<ClassType>>;\n\n/**\n\tThe defined binary operators of the abstract.\n*/\nvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n/**\n\tThe defined unary operators of the abstract.\n*/\nvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n/**\n\tThe available implicit from-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\n\tThe available implicit to-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\n\tThe defined array-access fields of the abstract.\n*/\nvar array:Array<ClassField>;\n\n/**\n\tThe method used for resolving unknown field access, if available.\n*/\nvar resolve:Null<ClassField>;\n\n/**\n\tThe method used for resolving unknown field access, if available.\n*/\nvar resolveWrite:Null<ClassField>;\n\n/**\n\tThe expression given as a default value for this abstract, if available.\n*/\nvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\nMetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\n\tReturn the wrapped `Metadata` array.\n\n\tModifying this array has no effect on the origin of `this` MetaAccess.\n\tThe `add` and `remove` methods can be used for that.\n*/\nfunction get():Expr.Metadata;\n\n/**\n\tExtract metadata entries by given `name`.\n\n\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n/**\n\tAdds the metadata specified by `name`, `params` and `pos` to the origin\n\tof `this` MetaAccess.\n\n\tMetadata names are not unique during compilation, so this method never\n\toverwrites a previous metadata.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `add` has no effect on that array.\n\n\tIf any argument is null, compilation fails with an error.\n*/\nfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n/**\n\tRemoves all `name` metadata entries from the origin of `this`\n\tMetaAccess.\n\n\tThis method might clear several metadata entries of the same name.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `remove` has no effect on that array.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction remove(name:String):Void;\n\n/**\n\tTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction has(name:String):Bool;\n}\n\n/**\nRepresents a field kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "get": "Represents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\n\tThe kind of the class.\n*/\nvar kind:ClassKind;\n\n/**\n\tIf true the type is an interface, otherwise it is a class.\n*/\nvar isInterface:Bool;\n\n/**\n\tIf true the class is final and cannot be extended.\n*/\nvar isFinal:Bool;\n\n/**\n\tIf true the class is abstract and cannot be instantiated directly.\n*/\nvar isAbstract:Bool;\n\n/**\n\tThe parent class and its type parameters, if available.\n*/\nvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\n\tThe implemented interfaces and their type parameters.\n*/\nvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\n\tThe member fields of the class.\n*/\nvar fields:Ref<Array<ClassField>>;\n\n/**\n\tThe static fields of the class.\n*/\nvar statics:Ref<Array<ClassField>>;\n\n// var dynamic : Null<Type>;\n// var arrayAccess : Null<Type>;\n\n/**\n\tThe constructor of the class, if available.\n*/\nvar constructor:Null<Ref<ClassField>>;\n\n/**\n\tThe `__init__` expression of the class, if available.\n*/\nvar init:Null<TypedExpr>;\n\n/**\n\tThe list of fields that have override status.\n*/\nvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\nRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\n\tThe available enum constructors.\n*/\nvar constructs:Map<String, EnumField>;\n\n/**\n\tAn ordered list of enum constructor names.\n*/\nvar names:Array<String>;\n}\n\n/**\nRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n/**\n\tThe target type of the typedef.\n*/\nvar type:Type;\n}\n\n/**\nRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\n\tThe underlying type of the abstract.\n*/\nvar type:Type;\n\n/**\n\tThe implementation class of the abstract, if available.\n*/\nvar impl:Null<Ref<ClassType>>;\n\n/**\n\tThe defined binary operators of the abstract.\n*/\nvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n/**\n\tThe defined unary operators of the abstract.\n*/\nvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n/**\n\tThe available implicit from-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\n\tThe available implicit to-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\n\tThe defined array-access fields of the abstract.\n*/\nvar array:Array<ClassField>;\n\n/**\n\tThe method used for resolving unknown field access, if available.\n*/\nvar resolve:Null<ClassField>;\n\n/**\n\tThe method used for resolving unknown field access, if available.\n*/\nvar resolveWrite:Null<ClassField>;\n\n/**\n\tThe expression given as a default value for this abstract, if available.\n*/\nvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\nMetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\n\tReturn the wrapped `Metadata` array.\n\n\tModifying this array has no effect on the origin of `this` MetaAccess.\n\tThe `add` and `remove` methods can be used for that.",
      "extract": "Extract metadata entries by given `name`.\n\n\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\tIf `name` is null, compilation fails with an error.",
      "add": "Adds the metadata specified by `name`, `params` and `pos` to the origin\n\tof `this` MetaAccess.\n\n\tMetadata names are not unique during compilation, so this method never\n\toverwrites a previous metadata.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `add` has no effect on that array.\n\n\tIf any argument is null, compilation fails with an error.",
      "remove": "Removes all `name` metadata entries from the origin of `this`\n\tMetaAccess.\n\n\tThis method might clear several metadata entries of the same name.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `remove` has no effect on that array.\n\n\tIf `name` is null, compilation fails with an error.",
      "has": "Tells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\tIf `name` is null, compilation fails with an error."
    },
    "fields": {
      "name": "The name of the type.",
      "module": "The module name of the type, which might be different.",
      "pos": "The position of the type.",
      "isPrivate": "Whether or not the type is private.",
      "isExtern": "Whether or not the type is extern.",
      "params": "The type parameters of the type.",
      "meta": "The metadata of the type.",
      "doc": "The associated documentation of the class field.",
      "kind": "Allows excluding the type from compilation.\n*/\nfunction exclude():Void;\n}\n\n/**\nRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\n\tThe kind of the class.",
      "isInterface": "If true the type is an interface, otherwise it is a class.",
      "isFinal": "If true the class is final and cannot be extended.",
      "isAbstract": "If true the class is abstract and cannot be instantiated directly.",
      "superClass": "The parent class and its type parameters, if available.",
      "interfaces": "The implemented interfaces and their type parameters.",
      "fields": "The member fields of the class.",
      "statics": "The static fields of the class.",
      "constructor": "The constructor of the class, if available.",
      "init": "The `__init__` expression of the class, if available.",
      "overrides": "The list of fields that have override status.",
      "constructs": "Represents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\n\tThe available enum constructors.",
      "names": "An ordered list of enum constructor names.",
      "type": "Represents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\n\tThe underlying type of the abstract.",
      "impl": "The implementation class of the abstract, if available.",
      "binops": "The defined binary operators of the abstract.",
      "unops": "The defined unary operators of the abstract.",
      "from": "The available implicit from-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html",
      "to": "The available implicit to-casts of the abstract.\n\n\t@see https://haxe.org/manual/types-abstract-implicit-casts.html",
      "array": "The defined array-access fields of the abstract.",
      "resolve": "The method used for resolving unknown field access, if available.",
      "resolveWrite": "The method used for resolving unknown field access, if available.",
      "defaultValue": "The expression given as a default value for this abstract, if available.",
      "args": "MetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\n\tReturn the wrapped `Metadata` array.\n\n\tModifying this array has no effect on the origin of `this` MetaAccess.\n\tThe `add` and `remove` methods can be used for that.\n*/\nfunction get():Expr.Metadata;\n\n/**\n\tExtract metadata entries by given `name`.\n\n\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n/**\n\tAdds the metadata specified by `name`, `params` and `pos` to the origin\n\tof `this` MetaAccess.\n\n\tMetadata names are not unique during compilation, so this method never\n\toverwrites a previous metadata.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `add` has no effect on that array.\n\n\tIf any argument is null, compilation fails with an error.\n*/\nfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n/**\n\tRemoves all `name` metadata entries from the origin of `this`\n\tMetaAccess.\n\n\tThis method might clear several metadata entries of the same name.\n\n\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\tcall to `remove` has no effect on that array.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction remove(name:String):Void;\n\n/**\n\tTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\tIf `name` is null, compilation fails with an error.\n*/\nfunction has(name:String):Bool;\n}\n\n/**\nRepresents a field kind.\n/\nenum FieldKind {\n/**\n\tA variable or property, depending on the `read` and `write` values.\n*/\nFVar(read:VarAccess, write:VarAccess);\n\n/**\n\tA method\n*/\nFMethod(k:MethodKind);\n}\n\n/**\nRepresents the variable accessor.\n/\nenum VarAccess {\n/**\n\tNormal access (`default`).\n*/\nAccNormal;\n\n/**\n\tPrivate access (`null`).\n*/\nAccNo;\n\n/**\n\tNo access (`never`).\n*/\nAccNever;\n\n/**\n\tUnused.\n*/\nAccResolve;\n\n/**\n\tAccess through accessor function (`get`, `set`, `dynamic`).\n*/\nAccCall;\n\n/**\n\tAccess through private accessor function (`private get`, `private set`).\n*/\nAccPrivateCall;\n\n/**\n\tInline access (`inline`).\n*/\nAccInline;\n\n/**\n\tFailed access due to a `@:require` metadata.\n*/\nAccRequire(r:String, ?msg:String);\n\n/**\n\tAccess is only allowed from the constructor.\n*/\nAccCtor;\n}\n\n/**\nRepresents the method kind.\n/\nenum MethodKind {\n/**\n\tA normal method.\n*/\nMethNormal;\n\n/**\n\tAn inline method.\n\n\t@see https://haxe.org/manual/class-field-inline.html\n*/\nMethInline;\n\n/**\n\tA dynamic, rebindable method.\n\n\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\nMethDynamic;\n\n/**\n\tA macro method.\n*/\nMethMacro;\n}\n\n/**\nRepresents typed constant.\n/\nenum TConstant {\n/**\n\tAn `Int` literal.\n*/\nTInt(i:Int);\n\n/**\n\tA `Float` literal, represented as String to avoid precision loss.\n*/\nTFloat(s:String);\n\n/**\n\tA `String` literal.\n*/\nTString(s:String);\n\n/**\n\tA `Bool` literal.\n*/\nTBool(b:Bool);\n\n/**\n\tThe constant `null`.\n*/\nTNull;\n\n/**\n\tThe constant `this`.\n*/\nTThis;\n\n/**\n\tThe constant `super`.\n*/\nTSuper;\n}\n\n/**\nRepresents a module type. These are the types that can be declared in a Haxe\nmodule and which are passed to the generators (except `TTypeDecl`).\n/\nenum ModuleType {\n/**\n\tA class.\n*/\nTClassDecl(c:Ref<ClassType>);\n\n/**\n\tAn enum.\n*/\nTEnumDecl(e:Ref<EnumType>);\n\n/**\n\tA typedef.\n*/\nTTypeDecl(t:Ref<DefType>);\n\n/**\n\tAn abstract.\n*/\nTAbstract(a:Ref<AbstractType>);\n}\n\n/**\nRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n/**\n\tA list of function arguments identified by an argument variable `v` and\n\tan optional initialization `value`."
    }
  },
  "haxe.macro.VarAccess": {
    "doc": "A variable or property, depending on the `read` and `write` values.\n*/\nFVar(read:VarAccess, write:VarAccess);\n\n/**\n\tA method\n*/\nFMethod(k:MethodKind);\n}\n\n/**\nRepresents the variable accessor.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MethodKind": {
    "doc": "Normal access (`default`).\n*/\nAccNormal;\n\n/**\n\tPrivate access (`null`).\n*/\nAccNo;\n\n/**\n\tNo access (`never`).\n*/\nAccNever;\n\n/**\n\tUnused.\n*/\nAccResolve;\n\n/**\n\tAccess through accessor function (`get`, `set`, `dynamic`).\n*/\nAccCall;\n\n/**\n\tAccess through private accessor function (`private get`, `private set`).\n*/\nAccPrivateCall;\n\n/**\n\tInline access (`inline`).\n*/\nAccInline;\n\n/**\n\tFailed access due to a `@:require` metadata.\n*/\nAccRequire(r:String, ?msg:String);\n\n/**\n\tAccess is only allowed from the constructor.\n*/\nAccCtor;\n}\n\n/**\nRepresents the method kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TConstant": {
    "doc": "A normal method.\n*/\nMethNormal;\n\n/**\n\tAn inline method.\n\n\t@see https://haxe.org/manual/class-field-inline.html\n*/\nMethInline;\n\n/**\n\tA dynamic, rebindable method.\n\n\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\nMethDynamic;\n\n/**\n\tA macro method.\n*/\nMethMacro;\n}\n\n/**\nRepresents typed constant.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ModuleType": {
    "doc": "An `Int` literal.\n*/\nTInt(i:Int);\n\n/**\n\tA `Float` literal, represented as String to avoid precision loss.\n*/\nTFloat(s:String);\n\n/**\n\tA `String` literal.\n*/\nTString(s:String);\n\n/**\n\tA `Bool` literal.\n*/\nTBool(b:Bool);\n\n/**\n\tThe constant `null`.\n*/\nTNull;\n\n/**\n\tThe constant `this`.\n*/\nTThis;\n\n/**\n\tThe constant `super`.\n*/\nTSuper;\n}\n\n/**\nRepresents a module type. These are the types that can be declared in a Haxe\nmodule and which are passed to the generators (except `TTypeDecl`).",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.FieldAccess": {
    "doc": "A class.\n*/\nTClassDecl(c:Ref<ClassType>);\n\n/**\n\tAn enum.\n*/\nTEnumDecl(e:Ref<EnumType>);\n\n/**\n\tA typedef.\n*/\nTTypeDecl(t:Ref<DefType>);\n\n/**\n\tAn abstract.\n*/\nTAbstract(a:Ref<AbstractType>);\n}\n\n/**\nRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n/**\n\tA list of function arguments identified by an argument variable `v` and\n\tan optional initialization `value`.\n*/\nvar args:Array<{v:TVar, value:Null<TypedExpr>}>;\n\n/**\n\tThe return type of the function.\n*/\nvar t:Type;\n\n/**\n\tThe expression of the function body.\n*/\nvar expr:TypedExpr;\n}\n\n/**\nRepresents the kind of field access in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "t": "The return type of the function.",
      "expr": "The expression of the function body.",
      "id": "Represents the kind of field access in the typed AST.\n/\nenum FieldAccess {\n/**\n\tAccess of field `cf` on a class instance `c` with type parameters\n\t`params`.\n*/\nFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n/**\n\tStatic access of a field `cf` on a class `c`.\n*/\nFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n/**\n\tAccess of field `cf` on an anonymous structure.\n*/\nFAnon(cf:Ref<ClassField>);\n\n/**\n\tDynamic field access of a field named `s`.\n*/\nFDynamic(s:String);\n\n/**\n\tClosure field access of field `cf` on a class instance `c` with type\n\tparameters `params`.\n*/\nFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n/**\n\tField access to an enum constructor `ef` of enum `e`.\n*/\nFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\nRepresents kind of a node in the typed AST.\n/\nenum TypedExprDef {\n/**\n\tA constant.\n*/\nTConst(c:TConstant);\n\n/**\n\tReference to a local variable `v`.\n*/\nTLocal(v:TVar);\n\n/**\n\tArray access `e1[e2]`.\n*/\nTArray(e1:TypedExpr, e2:TypedExpr);\n\n/**\n\tBinary operator `e1 op e2`.\n*/\nTBinop(op:Expr.Binop, e1:TypedExpr, e2:TypedExpr);\n\n/**\n\tField access on `e` according to `fa`.\n*/\nTField(e:TypedExpr, fa:FieldAccess);\n\n/**\n\tReference to a module type `m`.\n*/\nTTypeExpr(m:ModuleType);\n\n/**\n\tParentheses `(e)`.\n*/\nTParenthesis(e:TypedExpr);\n\n/**\n\tAn object declaration.\n*/\nTObjectDecl(fields:Array<{name:String, expr:TypedExpr}>);\n\n/**\n\tAn array declaration `[el]`.\n*/\nTArrayDecl(el:Array<TypedExpr>);\n\n/**\n\tA call `e(el)`.\n*/\nTCall(e:TypedExpr, el:Array<TypedExpr>);\n\n/**\n\tA constructor call `new c<params>(el)`.\n*/\nTNew(c:Ref<ClassType>, params:Array<Type>, el:Array<TypedExpr>);\n\n/**\n\tAn unary operator `op` on `e`:\n\ne++ (op = OpIncrement, postFix = true)\ne-- (op = OpDecrement, postFix = true)\n++e (op = OpIncrement, postFix = false)\n--e (op = OpDecrement, postFix = false)\n-e (op = OpNeg, postFix = false)\n!e (op = OpNot, postFix = false)\n~e (op = OpNegBits, postFix = false)\n*/\nTUnop(op:Expr.Unop, postFix:Bool, e:TypedExpr);\n\n/**\n\tA function declaration.\n*/\nTFunction(tfunc:TFunc);\n\n/**\n\tA variable declaration `var v` or `var v = expr`.\n*/\nTVar(v:TVar, expr:Null<TypedExpr>);\n\n/**\n\tA block declaration `{el}`.\n*/\nTBlock(el:Array<TypedExpr>);\n\n/**\n\tA `for` expression.\n*/\nTFor(v:TVar, e1:TypedExpr, e2:TypedExpr);\n\n/**\n\tAn `if(econd) eif` or `if(econd) eif else eelse` expression.\n*/\nTIf(econd:TypedExpr, eif:TypedExpr, eelse:Null<TypedExpr>);\n\n/**\n\tRepresents a `while` expression.\n\tWhen `normalWhile` is `true` it is `while (...)`.\n\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nTWhile(econd:TypedExpr, e:TypedExpr, normalWhile:Bool);\n\n/**\n\tRepresents a `switch` expression with related cases and an optional\n\t`default` case if edef != null.\n*/\nTSwitch(e:TypedExpr, cases:Array<{values:Array<TypedExpr>, expr:TypedExpr}>, edef:Null<TypedExpr>);\n\n/**\n\tRepresents a `try`-expression with related catches.\n*/\nTTry(e:TypedExpr, catches:Array<{v:TVar, expr:TypedExpr}>);\n\n/**\n\tA `return` or `return e` expression.\n*/\nTReturn(e:Null<TypedExpr>);\n\n/**\n\tA `break` expression.\n*/\nTBreak;\n\n/**\n\tA `continue` expression.\n*/\nTContinue;\n\n/**\n\tA `throw e` expression.\n*/\nTThrow(e:TypedExpr);\n\n/**\n\tA `cast e` or `cast (e, m)` expression.\n*/\nTCast(e:TypedExpr, m:Null<ModuleType>);\n\n/**\n\tA `@m e1` expression.\n*/\nTMeta(m:Expr.MetadataEntry, e1:TypedExpr);\n\n/**\n\tAccess to an enum parameter (generated by the pattern matcher).\n*/\nTEnumParameter(e1:TypedExpr, ef:EnumField, index:Int);\n\n/**\n\tAccess to an enum index (generated by the pattern matcher).\n*/\nTEnumIndex(e1:TypedExpr);\n\n/**\n\tAn unknown identifier.\n*/\nTIdent(s:String);\n}\n\n/**\nRepresents a variable in the typed AST.\n/\ntypedef TVar = {\n/**\n\tThe unique ID of the variable."
    }
  },
  "haxe.macro.TypedExprDef": {
    "doc": "Access of field `cf` on a class instance `c` with type parameters\n\t`params`.\n*/\nFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n/**\n\tStatic access of a field `cf` on a class `c`.\n*/\nFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n/**\n\tAccess of field `cf` on an anonymous structure.\n*/\nFAnon(cf:Ref<ClassField>);\n\n/**\n\tDynamic field access of a field named `s`.\n*/\nFDynamic(s:String);\n\n/**\n\tClosure field access of field `cf` on a class instance `c` with type\n\tparameters `params`.\n*/\nFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n/**\n\tField access to an enum constructor `ef` of enum `e`.\n*/\nFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\nRepresents kind of a node in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "name": "The name of the variable.",
      "t": "The type of the expression.",
      "capture": "Whether or not the variable has been captured by a closure.",
      "extra": "Special information which is internally used to keep track of closure.\n\tinformation",
      "meta": "The metadata of the variable.",
      "isStatic": "Whether the variable is a local static variable",
      "expr": "Represents a typed AST node.\n/\ntypedef TypedExpr = {\n/**\n\tThe expression kind.",
      "pos": "The position of the expression."
    }
  },
  "haxe.macro.TypedExprTools": {
    "doc": "This class provides some utility methods to work with typed expressions.\nIt is best used through 'using haxe.macro.TypedExprTools' syntax and then\nprovides additional methods on `haxe.macro.TypedExpr` instances.",
    "path": "haxe\\std\\haxe\\macro\\TypedExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\n\tSee `haxe.macro.ExprTools.iter` for details on iterating expressions in\n\tgeneral. This function works the same way, but with a different data\n\tstructure.",
      "mapWithType": "Transforms the sub-expressions of `e` by calling `f` on each of them.\n\tAdditionally, types are mapped using `ft` and variables are mapped using\n\t`fv`.\n\n\tSee `haxe.macro.ExprTools.map` for details on expression mapping in\n\tgeneral. This function works the same way, but with a different data\n\tstructure."
    },
    "fields": {}
  },
  "haxe.macro.TypeTools": {
    "doc": "This class provides some utility methods to work with types. It is\nbest used through 'using haxe.macro.TypeTools' syntax and then provides\nadditional methods on haxe.macro.Type instances.",
    "path": "haxe\\std\\haxe\\macro\\TypeTools.hx",
    "functions": {
      "follow": "Follows all typedefs of `t` to reach the actual type.\n\n\tIf `once` is true, this function does not call itself recursively,\n\totherwise it does. This can be useful in cases where intermediate\n\ttypedefs might be of interest.\n\n\tAffected types are monomorphs `TMono` and typedefs `TType(t,pl)`.\n\n\tIf `t` is null, an internal exception is thrown.\n\n\tUsage example with monomorphs:\n\t\tvar t = Context.typeof(macro null); // TMono(<mono>)\n\t\tvar ts = Context.typeof(macro \"foo\"); //TInst(String,[])\n\t\tContext.unify(t, ts);\n\t\ttrace(t); // TMono(<mono>)\n\t\ttrace(t.follow()); //TInst(String,[])\n\n\tUsage example with typedefs:\n\t\tvar t = Context.typeof(macro (\"foo\" :MyString)); // typedef MyString = String\n\t\ttrace(t); // TType(MyString,[])\n\t\ttrace(t.follow()); //TInst(String,[])",
      "followWithAbstracts": "Like `follow`, follows all typedefs of `t` to reach the actual type.\n\n\tWill however follow also abstracts to their underlying implementation,\n\tif they are not a @:coreType abstract\n\n\tIf `t` is null, an internal exception is thrown.\n\n\tUsage example:\n\t\tvar t = Context.typeof(macro new Map<String, String>());\n\t\ttrace(t); // TAbstract(Map,[TInst(String,[]),TInst(String,[])])\n\t\ttrace(t.followWithAbstracts()); // TInst(haxe.ds.StringMap, [TInst(String,[])])",
      "unify": "Returns true if `t1` and `t2` unify, false otherwise.",
      "getClass": "Tries to extract the class instance stored inside `t`.\n\n\tIf `t` is a class instance `TInst(c,pl)`, c is returned.\n\n\tIf `t` is of a different type, an exception of type String is thrown.\n\n\tIf `t` is null, the result is null.",
      "getEnum": "Tries to extract the enum instance stored inside `t`.\n\n\tIf `t` is an enum instance `TEnum(e,pl)`, e is returned.\n\n\tIf `t` is of a different type, an exception of type String is thrown.\n\n\tIf `t` is null, the result is null.",
      "applyTypeParameters": "Applies the type parameters `typeParameters` to type `t` with the given\n\ttypes `concreteTypes`.\n\n\tThis function replaces occurrences of type parameters in `t` if they are\n\tpart of `typeParameters`. The array index of such a type parameter is\n\tthen used to lookup the concrete type in `concreteTypes`.\n\n\tIf `typeParameters.length` is not equal to `concreteTypes.length`, an\n\texception of type `String` is thrown.\n\n\tIf `typeParameters.length` is 0, `t` is returned unchanged.\n\n\tIf either argument is `null`, the result is unspecified.",
      "map": "Transforms `t` by calling `f` on each of its subtypes.\n\n\tIf `t` is a compound type, `f` is called on each of its components.\n\n\tOtherwise `t` is returned unchanged.\n\n\tThe following types are considered compound:\n\t\t- TInst, TEnum, TType and TAbstract with type parameters\n\t\t- TFun\n\t\t- TAnonymous\n\n\tIf `t` or `f` are null, the result is unspecified.",
      "iter": "Calls function `f` on each component of type `t`.\n\n\tIf `t` is not a compound type, this operation has no effect.\n\n\tThe following types are considered compound:\n\t\t- TInst, TEnum, TType and TAbstract with type parameters\n\t\t- TFun\n\t\t- TAnonymous\n\n\tIf `t` or `f` are null, the result is unspecified.",
      "toString": "Converts type `t` to a human-readable String representation.",
      "setVarName": "Changes the name of the variable in the typed expression.",
      "toModuleType": "Converts type `t` to `haxe.macro.Type.ModuleType`.",
      "fromModuleType": "Creates a type from the `haxe.macro.Type.ModuleType` argument.",
      "toBaseType": "Converts type `t` to `haxe.macro.Type.BaseType`.",
      "resolveTypeParameters": "Calls `f` for each missing `TypeParameter` within Type `type`.\n\tThe `Type` returned from `f` fills the vacant parameter in a\n\tcopy returned by the function.\n\n\tIf `type` does not use type parameters, or all of the type\n\tparameters are defined, `type` is returned unchanged.\n\n\tExcessive type parameters are truncated.\n\n\tIf `recursive` is true, all subtypes are resolved.\n\n\tThe parameters provided to `f` are:\n\t\t- The `TypeParameter` being resolved.\n\t\t- The `Type` missing a type parameter.\n\t\t- The `Int` index of type parameter being resolved.\n\n\tMissing type parameters may cause fatal compiler errors.\n\tTherefore, this function should be called on user generated\n\t`Type`s prior to passing to macro API functions such as\n\t`Context.follow` or `Context.unify`.",
      "findField": "Resolves the field named `name` on class `c`.\n\n\tIf `isStatic` is true, the classes' static fields are checked. Otherwise\n\tthe classes' member fields are checked.\n\n\tIf the field is found, it is returned. Otherwise if `c` has a super\n\tclass, `findField` recursively checks that super class. Otherwise null\n\tis returned.\n\n\tIf any argument is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntArithmetic": {
    "doc": "A collection of static helper functions for performing arithmetic\non `BigInt_` objects.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntArithmetic.hx",
    "functions": {
      "compare": "Compare two big integers.\n\n\tReturns -1 if `a < b`; otherwise\n\treturns 1 if `a > b`; otherwise\n\treturns 0 (`a == b`).",
      "negate": "Perform the unary negation of big integer `operand` and put\n\tthe result into big integer `result`.\n\n\tOk for `result` and `operand` to be the same object.",
      "add": "Add big integer `operand2` to big integer `operand1` and put\n\tthe result into big integer `result`.\n\n\tOk for `result`, `operand1`, and `operand2` to be the same object.",
      "addInt": "Add integer `operand2` to big integer `operand1` and put the\n\tresult into big integer `result`.\n\n\tOk for `result` and `operand1` to be the same object.",
      "subtract": "Subtract big integer `operand2` from big integer `operand1`\n\tand put the result into big integer `result`.\n\n\tOk for `result`, `operand1`, and `operand2` to be the same object.",
      "subtractInt": "Subtract integer `operand2` from big integer `operand1` and\n\tput the result into big integer `result`.\n\n\tOk for `result` and `operand1` to be the same object.",
      "multiplyInt": "Multiply big integer `operand1` by integer `operand2` and put\n\tthe result into `result`.\n\n\t`result` may not refer the same object as either `operand1`\n\tor `operand2`; however, `operand1` and `operand2` may be the\n\tsame object.",
      "multiplyTraditional": "Multiply big integer `operand1` by big integer `operand2` and\n\tput the result into `result`.\n\n\t`result` may not refer the same object as either `operand1`\n\tor `operand2`; however, `operand1` and `operand2` may be the\n\tsame object.",
      "divideInt": "Divide the big integer `dividend` by the integer `divisor`.\n\tThe quotient of the division is put into `quotientOut`;\n\tthe remainder is the return value.\n\n\t`quotientOut` may refer to `dividend`.\n\n\t`work`, if supplied, must not refer to any of the inputs.",
      "divide": "Divide the big integer `dividend` by the big integer `divisor`.\n\tThe quotient of the division is put into `quotientOut`;\n\tthe remainder is put into `remainderOut`.\n\n\t`remainderOut` may be `null` if the remainder value is not\n\tneeded.\n\n\t`dividend` and `divisor` may refer to the same object.\n\n\t`quotientOut` and `remainderOut` must not refer to the same\n\tobject; but either may refer to the inputs.\n\n\t`work`, if supplied, must not refer to any of the inputs.",
      "arithmeticShiftLeft": "Shift big integer `operand1` to the left by `operand2` bits\n\tand put the result into big integer `result`.\n\n\tOk for `result` and `operand1` to be the same object.",
      "arithmeticShiftRight": "Shift big integer `operand1` to the right by `operand2` bits\n\tand put the result into big integer `result`.\n\n\tOk for `result` and `operand1` to be the same object.",
      "getBit": "Returns the value, 0 or 1, of the bit at 2^`index` place.",
      "bitwiseAndInt": "Returns the bitwise AND of `operand1` with `operand2`.",
      "bitwiseAnd": "Returns the bitwise AND of two big integers.\n\t@return A new `BigInt_` holding the result.",
      "bitwiseOr": "Returns the bitwise OR of `operand1` with `operand2`.",
      "bitwiseXor": "Returns the bitwise XOR of two big integers.\n\t@return A new `BigInt_` holding the result.",
      "bitwiseNot": "Returns the bitwise NOT (inversion) of a big integer.\n\t@return A new `BigInt_` holding the result.",
      "floorLog2": "Returns `floor(log2(input))`.\n\t@param input The `BigInt_` operand.\n\t@return The integer base-2 logarithm.",
      "square": "Squaring operation using power-of-two splitting.\n\t@param result The output BigInt for the square\n\t@param operand The operand to square"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntException": {
    "doc": "An exception thrown for errors during `BigInt` operations.\nIt wraps a `BigIntError` value to provide specific details.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.math.bigint.BigIntHelper": {
    "doc": "A collection of low-level, static Int manipulation helper functions.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntHelper.hx",
    "functions": {
      "bitLen": "Calculates the bit length of a signed 32-bit integer.\n\t@param x The integer value.\n\t@return The number of bits required to represent `x`.",
      "clp2": "\"Ceiling power of two\" -- round up to the least power of two\n\tgreater than or equal to input `x`, which is interpreted as\n\tunsigned.",
      "u32gtu32": "Unsigned greater than comparison.\n\n\tReturns `true` if `a > b` when both `a` and `b` are\n\tinterpreted as unsigned integers; `false` otherwise.",
      "u32divu16": "Integer division of unsigned 32-bit integer by unsigned 16-bit integer.\n\n\tResult is undefined when `divisor` <= 0 or `divisor` >= 2^16.",
      "u32geu32": "Unsigned greater than or equal comparison.\n\tReturns `true` if `a >= b` when both `a` and `b` are\n\tinterpreted as unsigned integers; `false` otherwise.",
      "ntz": "Number of trailing zeros - return the number of trailing\n\t0-value bits"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntTools": {
    "doc": "A collection of high-level static utility functions for `BigInt`.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntTools.hx",
    "functions": {
      "isBigInt": "Checks if a dynamic value is a `BigInt`.\n\t@param value The value to check.\n\t@return `true` if the value is of type `BigInt`.",
      "castFrom": "Casts a dynamic value to a `BigInt`.\n\t@param value The value to cast.\n\t@return The value as a `BigInt`.",
      "parseValueUnsigned": "Parses a dynamic value into an unsigned `BigInt`.\n\tSupports `String`, `Int`, and other `BigInt` types.\n\t@param value The value to parse.\n\t@return A new `BigInt` instance.",
      "parseStringUnsigned": "Parses a string representing an unsigned integer into a `BigInt`.\n\tThis internal helper handles decimal strings, and hexadecimal strings\n\tthat are prefixed with \"0x\".\n\t@param value The string to be parsed.\n\t@return A new `BigInt` instance representing the unsigned value."
    },
    "fields": {}
  },
  "haxe.rtti.CType": {
    "doc": "The (dot-)path of the runtime type.\n*/\ntypedef Path = String;\n\n/**\nA list of strings representing the targets where the type is available.\n*/\ntypedef Platforms = Array<String>;\n\n/**\nThe function argument runtime type information.\n*/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\nThe runtime member types.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.Rights": {
    "doc": "The type parameters in the runtime type information.\n*/\ntypedef PathParams = {\n/**\n\tThe path of the type.\n*/\nvar path:Path;\n\n/**\n\tThe array of parameters types.\n*/\nvar params:Array<CType>;\n};\n\n/**\nAn array of strings representing the names of the type parameters the type\nhas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\nRepresents the runtime rights of a type.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "params": "The array of parameters types.",
      "name": "An array of strings representing the names of the type parameters the type\nhas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\nRepresents the runtime rights of a type.\n*/\nenum Rights {\nRNormal;\nRNo;\nRCall(m:String);\nRMethod;\nRDynamic;\nRInline;\n}\n\n/**\nThe list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\nThe runtime class field information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n/**\n\tThe name of the field."
    }
  },
  "haxe.rtti.TypeTree": {
    "doc": "The list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\nThe runtime class field information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n/**\n\tThe name of the field.\n*/\nvar name:String;\n\n/**\n\tThe type of the field.\n*/\nvar type:CType;\n\n/**\n\tWhether or not the field is `public`.\n*/\nvar isPublic:Bool;\n\n/**\n\tWhether or not the field is `final`.\n*/\nvar isFinal:Bool;\n\n/**\n\tWhether or not the field overrides another field.\n*/\nvar isOverride:Bool;\n\n/**\n\tThe documentation of the field. This information is only available\n\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\n\tif the field has no documentation, the value is `null`.\n*/\nvar doc:Null<String>;\n\n/**\n\tThe [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\tbehavior of the field.\n*/\nvar get:Rights;\n\n/**\n\tThe [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\tbehavior of the field.\n*/\nvar set:Rights;\n\n/**\n\tAn array of strings representing the names of the type parameters\n\tthe field has.\n*/\nvar params:TypeParams;\n\n/**\n\tA list of strings representing the targets where the field is available.\n*/\nvar platforms:Platforms;\n\n/**\n\tThe meta data the field was annotated with.\n*/\nvar meta:MetaData;\n\n/**\n\tThe line number where the field is defined. This information is only\n\tavailable if the field has an expression.\n\tOtherwise the value is `null`.\n*/\nvar line:Null<Int>;\n\n/**\n\tThe list of available overloads for the fields or `null` if no overloads\n\texists.\n*/\nvar overloads:Null<Array<ClassField>>;\n\n/**\n\tThe actual expression of the field or `null` if there is no expression.\n*/\nvar expr:Null<String>;\n};\n\n/**\nThe general runtime type information.\n*/\ntypedef TypeInfos = {\n/**\n\tThe type path of the type.\n*/\nvar path:Path;\n\n/**\n\tThe type path of the module containing the type.\n*/\nvar module:Path;\n\n/**\n\tThe full slash path of the .hx file containing the type.\n\tThis might be `null` in case there is no such file, e.g. if the\n\ttype is defined through a macro.\n*/\nvar file:Null<String>;\n\n/**\n\tAn array of strings representing the names of the type parameters the\n\ttype has.\n*/\nvar params:TypeParams;\n\n/**\n\tThe documentation of the type. This information is only available\n\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\tthe constructor has no documentation, the value is `null`.\n*/\nvar doc:Null<String>;\n\n/**\n\tWhether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n*/\nvar isPrivate:Bool;\n\n/**\n\tA list of strings representing the targets where the type is available.\n*/\nvar platforms:Platforms;\n\n/**\n\tThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\n\tannotated with.\n*/\nvar meta:MetaData;\n};\n\n/**\nThe runtime class definition information.\n*/\ntypedef Classdef = TypeInfos & {\n/**\n\tWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n*/\nvar isExtern:Bool;\n\n/**\n\tWhether or not the class is `final`.\n*/\nvar isFinal:Bool;\n\n/**\n\tWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n*/\nvar isInterface:Bool;\n\n/**\n\tThe class' parent class defined by its type path and list of type\n\tparameters.\n*/\nvar superClass:Null<PathParams>;\n\n/**\n\tThe list of interfaces defined by their type path and list of type\n\tparameters.\n*/\nvar interfaces:Array<PathParams>;\n\n/**\n\tThe list of member [class fields](https://haxe.org/manual/class-field.html).\n*/\nvar fields:Array<ClassField>;\n\n/**\n\tThe list of static class fields.\n*/\nvar statics:Array<ClassField>;\n\n/**\n\tThe type which is dynamically implemented by the class or `null` if no\n\tsuch type exists.\n*/\nvar tdynamic:Null<CType>;\n};\n\n/**\nThe runtime enum constructor information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n/**\n\tThe name of the constructor.\n*/\nvar name:String;\n\n/**\n\tThe list of arguments the constructor has or `null` if no arguments are\n\tavailable.\n*/\nvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n/**\n\tThe documentation of the constructor. This information is only available\n\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\tthe constructor has no documentation, the value is `null`.\n*/\nvar doc:String;\n\n/**\n\tA list of strings representing the targets where the constructor is\n\tavailable.\n*/\nvar platforms:Platforms;\n\n/**\n\tThe meta data the constructor was annotated with.\n*/\nvar meta:MetaData;\n};\n\n/**\nThe enum runtime type information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n/**\n\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n*/\nvar isExtern:Bool;\n\n/**\n\tThe list of enum constructors.\n*/\nvar constructors:Array<EnumField>;\n};\n\n/**\nThe typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n/**\n\tThe type of the typedef.\n*/\nvar type:CType;\n\n/**\n\tThe types of the typedef, by platform.\n*/\nvar types:Map<String, CType>; // by platform\n\n};\n\n/**\nThe abstract type runtime information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n*/\ntypedef Abstractdef = TypeInfos & {\nvar to:Array<{t:CType, field:Null<String>}>;\nvar from:Array<{t:CType, field:Null<String>}>;\nvar impl:Classdef;\nvar athis:CType;\n};\n\n/**\nThe tree types of the runtime type.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "type": "The typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n/**\n\tThe type of the typedef.",
      "isPublic": "Whether or not the field is `public`.",
      "isFinal": "Whether or not the class is `final`.",
      "isOverride": "Whether or not the field overrides another field.",
      "doc": "The documentation of the constructor. This information is only available\n\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\tthe constructor has no documentation, the value is `null`.",
      "get": "The [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\tbehavior of the field.",
      "set": "The [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\tbehavior of the field.",
      "params": "An array of strings representing the names of the type parameters the\n\ttype has.",
      "platforms": "A list of strings representing the targets where the constructor is\n\tavailable.",
      "meta": "The meta data the constructor was annotated with.",
      "line": "The line number where the field is defined. This information is only\n\tavailable if the field has an expression.\n\tOtherwise the value is `null`.",
      "overloads": "The list of available overloads for the fields or `null` if no overloads\n\texists.",
      "expr": "The actual expression of the field or `null` if there is no expression.",
      "path": "The general runtime type information.\n*/\ntypedef TypeInfos = {\n/**\n\tThe type path of the type.",
      "module": "The type path of the module containing the type.",
      "file": "The full slash path of the .hx file containing the type.\n\tThis might be `null` in case there is no such file, e.g. if the\n\ttype is defined through a macro.",
      "isPrivate": "Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).",
      "isExtern": "The enum runtime type information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n/**\n\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).",
      "isInterface": "Whether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).",
      "superClass": "The class' parent class defined by its type path and list of type\n\tparameters.",
      "interfaces": "The list of interfaces defined by their type path and list of type\n\tparameters.",
      "fields": "The list of member [class fields](https://haxe.org/manual/class-field.html).",
      "statics": "The list of static class fields.",
      "tdynamic": "The type which is dynamically implemented by the class or `null` if no\n\tsuch type exists.",
      "name": "The runtime enum constructor information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n/**\n\tThe name of the constructor.",
      "args": "The list of arguments the constructor has or `null` if no arguments are\n\tavailable.",
      "constructors": "The list of enum constructors.",
      "types": "The types of the typedef, by platform."
    }
  },
  "haxe.rtti.TypeApi": {
    "doc": "Array of `TypeTree`.\n*/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\nContains type and equality checks functionalities for RTTI.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.CTypeTools": {
    "doc": "Returns `true` if the given `CType` is a variable or `false` if it is a\n\tfunction.\n*/\npublic static function isVar(t:CType) {\n\treturn switch (t) {\n\t\tcase CFunction(_, _): false;\n\t\tdefault: true;\n\t}\n}\n\nstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\n\tvar it = l2.iterator();\n\tfor (e1 in l1) {\n\t\tif (!it.hasNext())\n\t\t\treturn false;\n\t\tvar e2 = it.next();\n\t\tif (!f(e1, e2))\n\t\t\treturn false;\n\t}\n\tif (it.hasNext())\n\t\treturn false;\n\treturn true;\n}\n\n/**\n\tUnlike `r1 == r2`, this function performs a deep equality check on\n\tthe given `Rights` instances.\n\n\tIf `r1` or `r2` are `null`, the result is unspecified.\n*/\npublic static function rightsEq(r1:Rights, r2:Rights) {\n\tif (r1 == r2)\n\t\treturn true;\n\tswitch (r1) {\n\t\tcase RCall(m1):\n\t\t\tswitch (r2) {\n\t\t\t\tcase RCall(m2):\n\t\t\t\t\treturn m1 == m2;\n\t\t\t\tdefault:\n\t\t\t}\n\t\tdefault:\n\t}\n\treturn false;\n}\n\n/**\n\tUnlike `t1 == t2`, this function performs a deep equality check on\n\tthe given `CType` instances.\n\n\tIf `t1` or `t2` are `null`, the result is unspecified.\n*/\npublic static function typeEq(t1:CType, t2:CType) {\n\tswitch (t1) {\n\t\tcase CUnknown:\n\t\t\treturn t2 == CUnknown;\n\t\tcase CEnum(name, params):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CEnum(name2, params2):\n\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CClass(name, params):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CClass(name2, params2):\n\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CAbstract(name, params):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CAbstract(name2, params2):\n\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CTypedef(name, params):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CTypedef(name2, params2):\n\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CFunction(args, ret):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CFunction(args2, ret2):\n\t\t\t\t\treturn leq(function(a:FunctionArgument, b:FunctionArgument) {\n\t\t\t\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t\t\t\t}, args, args2) && typeEq(ret, ret2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CAnonymous(fields):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CAnonymous(fields2):\n\t\t\t\t\treturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\n\t\t\t\tdefault:\n\t\t\t}\n\t\tcase CDynamic(t):\n\t\t\tswitch (t2) {\n\t\t\t\tcase CDynamic(t2):\n\t\t\t\t\tif ((t == null) != (t2 == null))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\treturn t == null || typeEq(t, t2);\n\t\t\t\tdefault:\n\t\t\t}\n\t}\n\treturn false;\n}\n\n/**\n\tUnlike `f1 == f2`, this function performs a deep equality check on\n\tthe given `ClassField` instances.\n\n\tIf `f1` or `f2` are `null`, the result is unspecified.\n*/\npublic static function fieldEq(f1:ClassField, f2:ClassField) {\n\tif (f1.name != f2.name)\n\t\treturn false;\n\tif (!typeEq(f1.type, f2.type))\n\t\treturn false;\n\tif (f1.isPublic != f2.isPublic)\n\t\treturn false;\n\tif (f1.doc != f2.doc)\n\t\treturn false;\n\tif (!rightsEq(f1.get, f2.get))\n\t\treturn false;\n\tif (!rightsEq(f1.set, f2.set))\n\t\treturn false;\n\tif ((f1.params == null) != (f2.params == null))\n\t\treturn false;\n\tif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\n\t\treturn false;\n\treturn true;\n}\n\n/**\n\tUnlike `c1 == c2`, this function performs a deep equality check on\n\tthe arguments of the enum constructors, if exists.\n\n\tIf `c1` or `c2` are `null`, the result is unspecified.\n*/\npublic static function constructorEq(c1:EnumField, c2:EnumField) {\n\tif (c1.name != c2.name)\n\t\treturn false;\n\tif (c1.doc != c2.doc)\n\t\treturn false;\n\tif ((c1.args == null) != (c2.args == null))\n\t\treturn false;\n\tif (c1.args != null && !leq(function(a, b) {\n\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t}, c1.args, c2.args))\n\t\treturn false;\n\treturn true;\n}\n}\n\n/**\nThe `CTypeTools` class contains some extra functionalities for handling\n`CType` instances.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {
      "rightsEq": "Unlike `r1 == r2`, this function performs a deep equality check on\n\tthe given `Rights` instances.\n\n\tIf `r1` or `r2` are `null`, the result is unspecified.",
      "typeEq": "Unlike `t1 == t2`, this function performs a deep equality check on\n\tthe given `CType` instances.\n\n\tIf `t1` or `t2` are `null`, the result is unspecified.",
      "fieldEq": "Unlike `f1 == f2`, this function performs a deep equality check on\n\tthe given `ClassField` instances.\n\n\tIf `f1` or `f2` are `null`, the result is unspecified.",
      "constructorEq": "Unlike `c1 == c2`, this function performs a deep equality check on\n\tthe arguments of the enum constructors, if exists.\n\n\tIf `c1` or `c2` are `null`, the result is unspecified.",
      "toString": "The `CTypeTools` class contains some extra functionalities for handling\n`CType` instances.\n*/\nclass CTypeTools {\n/**\n\tGet the string representation of `CType`."
    },
    "fields": {}
  },
  "haxe.rtti.Meta": {
    "doc": "An API to access classes and enums metadata at runtime.\n\n@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\Meta.hx",
    "functions": {
      "getStatics": "Returns the metadata that were declared for the given class static fields",
      "getFields": "Returns the metadata that were declared for the given class fields or enum constructors"
    },
    "fields": {}
  },
  "haxe.rtti.Rtti": {
    "doc": "Rtti is a helper class which supplements the `@:rtti` metadata.\n\n@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\Rtti.hx",
    "functions": {
      "hasRtti": "Tells if `c` has runtime type information.\n\n\tIf `c` is `null`, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.rtti.XmlParser": {
    "doc": "XmlParser processes the runtime type information (RTTI) which\nis stored as a XML string in a static field `__rtti`.\n\n@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\XmlParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.xml.Access": {
    "doc": "The `haxe.xml.Access` API helps providing a fast dot-syntax access to the\nmost common `Xml` methods.",
    "path": "haxe\\std\\haxe\\xml\\Access.hx",
    "functions": {},
    "fields": {
      "innerData": "The inner PCDATA or CDATA of the node.\n\n\tAn exception is thrown if there is no data or if there not only data\n\tbut also other nodes.",
      "innerHTML": "The XML string built with all the sub nodes, excluding the current one.",
      "node": "Access to the first sub element with the given name.\n\n\tAn exception is thrown if the element doesn't exists.\n\tUse `hasNode` to check the existence of a node.\n\n\t```haxe\n\tvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\n\tvar user = access.node.user;\n\tvar name = user.node.name;\n\ttrace(name.innerData); // John\n\n\t// Uncaught Error: Document is missing element password\n\tvar password = user.node.password;\n\t```",
      "nodes": "Access to the List of elements with the given name.\n\t```haxe\n\tvar fast = new haxe.xml.Access(Xml.parse(\"\n\t\t<users>\n\t\t\t<user name='John'/>\n\t\t\t<user name='Andy'/>\n\t\t\t<user name='Dan'/>\n\t\t</users>\"\n\t));\n\n\tvar users = fast.node.users;\n\tfor (user in users.nodes.user) {\n\t\ttrace(user.att.name);\n\t}\n\t```",
      "att": "Access to a given attribute.\n\n\tAn exception is thrown if the attribute doesn't exists.\n\tUse `has` to check the existence of an attribute.\n\n\t```haxe\n\tvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\n\tvar user = f.node.user;\n\tif (user.has.name) {\n\t\ttrace(user.att.name); // Mark\n\t}\n\t```",
      "has": "Check the existence of an attribute with the given name.",
      "hasNode": "Check the existence of a sub node with the given name.\n\n\t```haxe\n\tvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\n\tvar user = f.node.user;\n\tif (user.hasNode.age) {\n\t\ttrace(user.node.age.innerData); // 31\n\t}\n\t```",
      "elements": "The list of all sub-elements which are the nodes with type `Xml.Element`."
    }
  },
  "haxe.xml.Printer": {
    "doc": "This class provides utility methods to convert Xml instances to\nString representation.",
    "path": "haxe\\std\\haxe\\xml\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.zip.InflateImpl": {
    "doc": "A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.",
    "path": "haxe\\std\\haxe\\zip\\InflateImpl.hx",
    "functions": {},
    "fields": {}
  },
  "hl.CArray": {
    "doc": "CArray is a compact array where all objects are memory aligned and stored as a single GC block.\nYou must hold a reference to the CArray while any of the objects it contains is still referenced somewhere.",
    "path": "haxe\\std\\hl\\CArray.hx",
    "functions": {},
    "fields": {}
  },
  "hl.Format": {
    "doc": "These are some bindings for the HL `fmt.hdll` library, which contains various low level formats handling.",
    "path": "haxe\\std\\hl\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "hl.UI": {
    "doc": "These are the bindings for the HL `ui.hdll` library, which contains some low level system access.",
    "path": "haxe\\std\\hl\\UI.hx",
    "functions": {},
    "fields": {}
  },
  "js.Lib": {
    "doc": "Platform-specific JavaScript Library. Provides some platform-specific functions\nfor the JavaScript target.",
    "path": "haxe\\std\\js\\Lib.hx",
    "functions": {
      "dynamicImport": "Inserts an `import` expression that loads JavaScript object from\n\ta module or file specified in the `module` argument.",
      "alert": "Display an alert message box containing the given message.\n\t@deprecated Use Browser.alert() instead.",
      "getOriginalException": "Inserts a `require` expression that loads JavaScript object from\n\ta module or file specified in the `module` argument.\n\n\tThis is only supported in environments where `require` function\n\tis available, such as Node.js or RequireJS.\n*/\nextern public static inline function require(module:String):Dynamic {\n\treturn js.Syntax.code(\"require\")(module);\n}\n\n/**\n\tNative JavaScript `parseInt` function.\n\n\tIts specification is different from `Std.parseInt`, so one\n\tmight want to access the native one.\n*/\npublic static var parseInt(get, never):(string:String, ?radix:Int) -> Float;\n\nextern static inline function get_parseInt():(string:String, ?radix:Int) -> Float {\n\treturn js.Syntax.code(\"parseInt\");\n}\n\n/**\n\tReturns JavaScript `undefined` value.\n\n\tNote that this is only needed in very rare cases when working with external JavaScript code.\n\n\tIn Haxe, `null` is used to represent the absence of a value.\n*/\npublic static var undefined(get, never):Dynamic;\n\nstatic inline function get_undefined():Dynamic {\n\treturn js.Syntax.code(\"undefined\");\n}\n\n/**\n\t`nativeThis` is the JavaScript `this`, which is semantically different\n\tfrom the Haxe `this`. Use `nativeThis` only when working with external\n\tJavaScript code.\n\n\tIn Haxe, `this` is always bound to a class instance.\n\tIn JavaScript, `this` in a function can be bound to an arbitrary\n\tvariable when the function is called using `func.call(thisObj, ...)` or\n\t`func.apply(thisObj, [...])`.\n\n\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n*/\npublic static var nativeThis(get, never):Dynamic;\n\nextern static inline function get_nativeThis():Dynamic {\n\treturn js.Syntax.code(\"this\");\n}\n\n/**\n\tCall JavaScript `typeof` operator on the `o` value\n\tand return a string representing the JavaScript type of a value.\n\n\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\nextern public static inline function typeof(o:Dynamic):String {\n\treturn js.Syntax.typeof(o);\n}\n\n/**\n\tAn alias of the JS \"global\" object.\n\n\tConcretely, it is set as the first defined value in the list of\n\t`window`, `global`, `self`, and `this` in the top-level of the compiled output.\n*/\npublic static var global(get, never):Dynamic;\n\nextern static inline function get_global():Dynamic {\n\treturn untyped __define_feature__(\"js.Lib.global\", js.Syntax.code(\"$global\")); // $global is generated by the compiler\n}\n\n/**\n\tRe-throw last caught exception, preserving original stack information.\n\n\tCalling this is only possible inside a catch statement.\n*/\n@:pure(false) public static function rethrow() {\n\t// function is implemented in the compiler\n}\n\n/**\n\tGet original caught exception object, before unwrapping the `js.Boot.HaxeError`.\n\n\tCan be useful if we want to redirect the original error into some external API (e.g. Promise or node.js callbacks).\n\n\tCalling this is only possible inside a catch statement.",
      "getNextHaxeUID": "Generate next unique id"
    },
    "fields": {
      "undefined": "Returns JavaScript `undefined` value.\n\n\tNote that this is only needed in very rare cases when working with external JavaScript code.\n\n\tIn Haxe, `null` is used to represent the absence of a value.",
      "nativeThis": "`nativeThis` is the JavaScript `this`, which is semantically different\n\tfrom the Haxe `this`. Use `nativeThis` only when working with external\n\tJavaScript code.\n\n\tIn Haxe, `this` is always bound to a class instance.\n\tIn JavaScript, `this` in a function can be bound to an arbitrary\n\tvariable when the function is called using `func.call(thisObj, ...)` or\n\t`func.apply(thisObj, [...])`.\n\n\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this",
      "global": "Call JavaScript `typeof` operator on the `o` value\n\tand return a string representing the JavaScript type of a value.\n\n\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\nextern public static inline function typeof(o:Dynamic):String {\n\treturn js.Syntax.typeof(o);\n}\n\n/**\n\tAn alias of the JS \"global\" object.\n\n\tConcretely, it is set as the first defined value in the list of\n\t`window`, `global`, `self`, and `this` in the top-level of the compiled output."
    }
  },
  "js.html.ConsoleInstance": {
    "doc": "The `Console` object provides access to the browser's debugging console (e.g. the Web Console in Firefox). The specifics of how it works varies from browser to browser, but there is a de facto set of features that are typically provided.\n\nDocumentation [Console](https://developer.mozilla.org/en-US/docs/Web/API/Console) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/Console$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/Console>",
    "path": "haxe\\std\\js\\html\\ConsoleInstance.hx",
    "functions": {
      "clear": "Clear the console.",
      "count": "Log the number of times this line has been called with the given label.",
      "countReset": "Resets the value of the counter with the given label.",
      "debug": "Outputs a message to the console with the log level `\"debug\"`.\n\t Note: Starting with Chromium 58 this method only appears in Chromium browser consoles when level \"Verbose\" is selected.",
      "error": "Outputs an error message. You may use string substitution and additional arguments with this method.",
      "info": "Informative logging of information. You may use string substitution and additional arguments with this method.",
      "log": "For general output of logging information. You may use string substitution and additional arguments with this method.",
      "table": "Displays tabular data as a table.",
      "trace": "Outputs a stack trace.",
      "warn": "Outputs a warning message. You may use string substitution and additional arguments with this method.",
      "dir": "Displays an interactive listing of the properties of a specified JavaScript object. This listing lets you use disclosure triangles to examine the contents of child objects.",
      "dirxml": "Displays an XML/HTML Element representation of the specified object if possible or the JavaScript Object view if it is not possible.",
      "group": "Creates a new inline group, indenting all following output by another level. To move back out a level, call `groupEnd()`.",
      "groupCollapsed": "Creates a new inline group, indenting all following output by another level. However, unlike `group()` this starts with the inline group collapsed requiring the use of a disclosure button to expand it. To move back out a level, call `groupEnd()`.",
      "groupEnd": "Exits the current inline group.",
      "time": "Starts a timer with a name specified as an input parameter. Up to 10,000 simultaneous timers can run on a given page.",
      "timeLog": "Logs the value of the specified timer to the console.",
      "timeEnd": "Stops the specified timer and logs the elapsed time in seconds since it started.",
      "exception": "An alias for `error()`.",
      "timeStamp": "Adds a marker to the browser's Timeline or Waterfall tool.",
      "profile": "Starts the browser's built-in profiler (for example, the Firefox performance tool). You can specify an optional name for the profile.",
      "profileEnd": "Stops the profiler. You can see the resulting profile in the browser's performance tool (for example, the Firefox performance tool)."
    },
    "fields": {}
  },
  "js.html.abstract": {
    "doc": "The `XMLHttpRequestResponseType` type is an enumerated set of strings which are used to specify the type of data contained in the `response` of an `XMLHttpRequest`.\n\nDocumentation [XMLHttpRequestResponseType](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType>",
    "path": "haxe\\std\\js\\html\\XMLHttpRequestResponseType.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.ArrayBufferView": {
    "doc": "`ArrayBufferView` is a helper type representing any of the following JavaScript `TypedArray` types:\n\nDocumentation [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>",
    "path": "haxe\\std\\js\\lib\\ArrayBufferView.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.BufferSource": {
    "doc": "`BufferSource` is a typedef used to represent objects that are either themselves an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer),\nor which are a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) providing an [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView).\n\nThis is a helper type to simplify the specification. It isn't an interface and there are no objects implementing it.\n\nDocumentation [BufferSource](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/BufferSource>",
    "path": "haxe\\std\\js\\lib\\BufferSource.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.HaxeIterator": {
    "doc": "`HaxeIterator` wraps a JavaScript native iterator object to enable for-in iteration in haxe.\nIt can be used directly: `new HaxeIterator(jsIterator)` or via using: `using HaxeIterator`.",
    "path": "haxe\\std\\js\\lib\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.KeyValue": {
    "doc": "Key/value access helper.",
    "path": "haxe\\std\\js\\lib\\KeyValue.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.NativeStringTools": {
    "doc": "Documentation [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).",
    "path": "haxe\\std\\js\\lib\\NativeStringTools.hx",
    "functions": {
      "localeCompare": "Returns a number indicating whether a reference string comes before or after or is\n\tthe same as the given string in sort order.",
      "toLocaleLowerCase": "The characters within a string are converted to lower case while respecting the current locale.\n\tFor most languages, this will return the same as toLowerCase().",
      "toLocaleUpperCase": "The characters within a string are converted to upper case while respecting the current locale.\n\tFor most languages, this will return the same as toUpperCase().",
      "charCodeAt": "The `charCodeAt()` method of String values returns an integer between 0\n\tand 65535 representing the UTF-16 code unit at the given index.\n\n\tIf `index` is out of range of `0` – `str.length - 1`, returns `NaN`.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt",
      "replace": "The `replace()` method of String values returns a new string with one,\n\tsome, or all matches of a pattern replaced by a replacement.\n\n\tThe pattern can be a `String` or a `js.lib.RegExp`, and the replacement\n\tcan be a string or a function called for each match.\n\n\tIf pattern is a string, only the first occurrence will be replaced. The\n\toriginal string is left unchanged.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
    },
    "fields": {
      "NFD": "Normalization Form Canonical Decomposition.",
      "NFKC": "Normalization Form Compatibility Composition.",
      "NFKD": "Normalization Form Compatibility Decomposition."
    }
  },
  "js.lib.ObjectEntry": {
    "doc": "The `js.lib.Object` constructor creates an object wrapper.\n\nDocumentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Object\")\nextern class Object {\n/**\n\tThe Object.assign() method is used to copy the values of all enumerable\n\town properties from one or more source objects to a target object. It\n\twill return the target object.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n*/\nstatic function assign<TSource:{}, TDest:{}>(target:TSource, sources:Rest<{}>):TDest;\n\n/**\n\tThe Object.create() method create a new object, using an existing object\n\tto provide the newly created object's __proto__ . (see browser console\n\tfor visual evidence.)\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\n\tThe Object.defineProperties() method defines new or modifies existing\n\tproperties directly on an object, returning the object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\n*/\nstatic function defineProperties<T:{}>(obj:T, props:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\n\tThe static method Object.defineProperty() defines a new property directly\n\ton an object, or modifies an existing property on an object, and returns\n\tthe object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n*/\n@:overload(function<T:{}, TProp>(obj:T, prop:Symbol, descriptor:ObjectPropertyDescriptor<TProp>):T {})\nstatic function defineProperty<T:{}, TProp>(obj:T, prop:String, descriptor:ObjectPropertyDescriptor<TProp>):T;\n\n/**\n\tThe Object.entries() method returns an array of a given object's own\n\tenumerable property [key, value] pairs, in the same order as that\n\tprovided by a for...in loop (the difference being that a for-in loop\n\tenumerates properties in the prototype chain as well).\n\n\tNote: this is an ES2017 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n/**\n\tThe Object.freeze() method freezes an object: that is, prevents new\n\tproperties from being added to it; prevents existing properties from\n\tbeing removed; and prevents existing properties, or their enumerability,\n\tconfigurability, or writability, from being changed, it also prevents the\n\tprototype from being changed.\n\tThe method returns the passed object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n*/\nstatic function freeze<T:{}>(obj:T):T;\n\n/**\n\tReturns a new object from an iterable of key-value pairs\n\t(reverses Object.entries).\n*/\n@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n/**\n\tThe Object.getOwnPropertyDescriptor() method returns a property\n\tdescriptor for an own property (that is, one directly present on an\n\tobject and not in the object's prototype chain) of a given object.\n\n\tIn ES5, if the first argument to this method is not an object (a\n\tprimitive), then it will cause a TypeError. In ES2015, a non-object\n\tfirst argument will be coerced to an object at first.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n/**\n\tThe Object.getOwnPropertyDescriptors() method returns all own property\n\tdescriptors of a given object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n/**\n\tThe Object.getOwnPropertyNames() method returns an array of all\n\tproperties (including non-enumerable properties except for those which\n\tuse Symbol) found directly upon a given object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n/**\n\tThe Object.getOwnPropertySymbols() method returns an array of all symbol\n\tproperties found directly upon a given object.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n/**\n\tThe Object.getPrototypeOf() method returns the prototype (i.e. the value\n\tof the internal [[Prototype]] property) of the specified object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n/**\n\tThe Object.is() method determines whether two values are the same value.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\n\tThe Object.is() method determines whether two values are the same value.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:deprecated(\"Use Object.isSame()\")\n@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\n\tThe Object.isExtensible() method determines if an object is extensible\n\t(whether it can have new properties added to it).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.isFrozen() determines if an object is frozen.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.isSealed() method determines if an object is sealed.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.keys() method returns an array of a given object's own\n\tenumerable properties, in the same order as that provided by a for...in\n\tloop (the difference being that a for-in loop enumerates properties in\n\tthe prototype chain as well).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n/**\n\tThe Object.preventExtensions() method prevents new properties from ever\n\tbeing added to an object (i.e. prevents future extensions to the object).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\n*/\nstatic function preventExtensions<T:{}>(obj:T):T;\n\n/**\n\tThe Object.seal() method seals an object, preventing new properties from\n\tbeing added to it and marking all existing properties as\n\tnon-configurable. Values of present properties can still be changed as\n\tlong as they are writable.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\n*/\nstatic function seal<T:{}>(obj:T):T;\n\n/**\n\tThe Object.setPrototypeOf() method sets the prototype (i.e., the internal\n\t[[Prototype]] property) of a specified object to another object or null.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\n*/\nstatic function setPrototypeOf<T:{}, TProto:{}>(obj:T, proto:Null<TProto>):T;\n\n/**\n\tThe Object.values() method returns an array of a given object's own\n\tenumerable property values, in the same order as that provided by a\n\tfor...in loop (the difference being that a for-in loop enumerates\n\tproperties in the prototype chain as well).\n\n\tNote: this is an ES2017 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n*/\n@:pure static function values<T:{}>(obj:T):Array<Any>;\n\n/**\n\tAllows the addition of properties to all objects of type Object.\n*/\nstatic var prototype(default, never):ObjectPrototype;\n\n/**\n\tThe Object constructor creates an object wrapper.\n*/\n@:pure function new(?value:Any);\n}\n\n/**\nType for\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n/**\n\tReturns a boolean indicating whether an object contains the specified\n\tproperty as a direct property of that object and not inherited through\n\tthe prototype chain.\n*/\nvar hasOwnProperty(default, never):Function;\n\n/**\n\tReturns a boolean indicating whether the object this method is called\n\tupon is in the prototype chain of the specified object.\n*/\nvar isPrototypeOf(default, never):Function;\n\n/**\n\tReturns a boolean indicating if the internal enumerable attribute is set.\n*/\nvar propertyIsEnumerable(default, never):Function;\n\n/**\n\tCalls `toString()`.\n*/\nvar toLocaleString(default, never):Function;\n\n/**\n\tReturns a string representation of the object.\n*/\nvar toString(default, never):Function;\n\n/**\n\tReturns the primitive value of the specified object.\n*/\nvar valueOf(default, never):Function;\n}\n\n/**\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>\n*/\ntypedef ObjectPropertyDescriptor<TProp> = {\n/**\n\t`true` if and only if the type of this property descriptor may be\n\tchanged and if the property may be deleted from the corresponding object.\n\tDefaults to `false`.\n*/\nvar ?configurable:Bool;\n\n/**\n\t`true` if and only if this property shows up during enumeration of the\n\tproperties on the corresponding object.\n\tDefaults to `false`.\n*/\nvar ?enumerable:Bool;\n\n/**\n\tThe value associated with the property.\n\tCan be any valid JavaScript value (number, object, function, etc).\n*/\nvar ?value:TProp;\n\n/**\n\t`true` if and only if the value associated with the property may be\n\tchanged with an assignment operator.\n\tDefaults to `false`.\n*/\nvar ?writable:Bool;\n\n/**\n\tA function which serves as a getter for the property, or `undefined` if\n\tthere is no getter. When the property is accessed, this function is\n\tcalled without arguments and with `this` set to the object through which\n\tthe property is accessed (this may not be the object on which the\n\tproperty is defined due to inheritance).\n\tThe return value will be used as the value of the property.\n*/\nvar ?get:Void->TProp;\n\n/**\n\tA function which serves as a setter for the property, or undefined if\n\tthere is no setter. When the property is assigned to, this function\n\tis called with one argument (the value being assigned to the property)\n\tand with `this` set to the object through which the property is assigned.\n*/\nvar ?set:TProp->Void;\n}\n\n/**\nKey/value access helper for `js.lib.Object.entries()`.",
    "path": "haxe\\std\\js\\lib\\Object.hx",
    "functions": {
      "defineProperties": "The Object.create() method create a new object, using an existing object\n\tto provide the newly created object's __proto__ . (see browser console\n\tfor visual evidence.)\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\n\tThe Object.defineProperties() method defines new or modifies existing\n\tproperties directly on an object, returning the object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties",
      "defineProperty": "The static method Object.defineProperty() defines a new property directly\n\ton an object, or modifies an existing property on an object, and returns\n\tthe object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "freeze": "The Object.entries() method returns an array of a given object's own\n\tenumerable property [key, value] pairs, in the same order as that\n\tprovided by a for...in loop (the difference being that a for-in loop\n\tenumerates properties in the prototype chain as well).\n\n\tNote: this is an ES2017 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n/**\n\tThe Object.freeze() method freezes an object: that is, prevents new\n\tproperties from being added to it; prevents existing properties from\n\tbeing removed; and prevents existing properties, or their enumerability,\n\tconfigurability, or writability, from being changed, it also prevents the\n\tprototype from being changed.\n\tThe method returns the passed object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze",
      "preventExtensions": "Returns a new object from an iterable of key-value pairs\n\t(reverses Object.entries).\n*/\n@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n/**\n\tThe Object.getOwnPropertyDescriptor() method returns a property\n\tdescriptor for an own property (that is, one directly present on an\n\tobject and not in the object's prototype chain) of a given object.\n\n\tIn ES5, if the first argument to this method is not an object (a\n\tprimitive), then it will cause a TypeError. In ES2015, a non-object\n\tfirst argument will be coerced to an object at first.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n/**\n\tThe Object.getOwnPropertyDescriptors() method returns all own property\n\tdescriptors of a given object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n/**\n\tThe Object.getOwnPropertyNames() method returns an array of all\n\tproperties (including non-enumerable properties except for those which\n\tuse Symbol) found directly upon a given object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n/**\n\tThe Object.getOwnPropertySymbols() method returns an array of all symbol\n\tproperties found directly upon a given object.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n/**\n\tThe Object.getPrototypeOf() method returns the prototype (i.e. the value\n\tof the internal [[Prototype]] property) of the specified object.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n/**\n\tThe Object.is() method determines whether two values are the same value.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\n\tThe Object.is() method determines whether two values are the same value.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:deprecated(\"Use Object.isSame()\")\n@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\n\tThe Object.isExtensible() method determines if an object is extensible\n\t(whether it can have new properties added to it).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.isFrozen() determines if an object is frozen.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.isSealed() method determines if an object is sealed.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n/**\n\tThe Object.keys() method returns an array of a given object's own\n\tenumerable properties, in the same order as that provided by a for...in\n\tloop (the difference being that a for-in loop enumerates properties in\n\tthe prototype chain as well).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n/**\n\tThe Object.preventExtensions() method prevents new properties from ever\n\tbeing added to an object (i.e. prevents future extensions to the object).\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions",
      "seal": "The Object.seal() method seals an object, preventing new properties from\n\tbeing added to it and marking all existing properties as\n\tnon-configurable. Values of present properties can still be changed as\n\tlong as they are writable.\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal",
      "setPrototypeOf": "The Object.setPrototypeOf() method sets the prototype (i.e., the internal\n\t[[Prototype]] property) of a specified object to another object or null.\n\n\tNote: this is an ES2015 feature\n\n\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
    },
    "fields": {
      "hasOwnProperty": "The Object constructor creates an object wrapper.\n*/\n@:pure function new(?value:Any);\n}\n\n/**\nType for\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n/**\n\tReturns a boolean indicating whether an object contains the specified\n\tproperty as a direct property of that object and not inherited through\n\tthe prototype chain.",
      "isPrototypeOf": "Returns a boolean indicating whether the object this method is called\n\tupon is in the prototype chain of the specified object.",
      "propertyIsEnumerable": "Returns a boolean indicating if the internal enumerable attribute is set.",
      "toLocaleString": "Calls `toString()`.",
      "toString": "Returns a string representation of the object.",
      "valueOf": "Returns the primitive value of the specified object."
    }
  },
  "js.lib.PromiseHandler": {
    "doc": "The Promise object represents the eventual completion (or failure) of an\nasynchronous operation and its resulting value.\n\nDocumentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Promise\")\nextern class Promise<T> {\n/**\n\tReturns a Promise object that is resolved with the given value. If the\n\tvalue is Thenable, the returned promise will \"follow\" that\n\tthenable, adopting its eventual state;\n\totherwise the returned promise will be fulfilled with the value.\n\tGenerally, when it's unknown when value is a promise or not,\n\tuse `Promise.resolve(value)` instead and work with the return value as\n\ta promise.\n*/\n@:overload(function<T>(?value:T):Promise<T> {})\nstatic function resolve<T>(thenable:Thenable<T>):Promise<T>;\n\n/**\n\tReturns a Promise object that is rejected with the given reason.\n*/\nstatic function reject<T>(?reason:Dynamic):Promise<T>;\n\n/**\n\tReturns a promise that either fulfills when all of the promises in the\n\titerable argument have fulfilled or rejects as soon as one of the\n\tpromises in the iterable argument rejects. If the returned promise\n\tfulfills, it is fulfilled with an array of the values from the\n\tfulfilled promises in the same order as defined in the iterable.\n\tIf the returned promise rejects, it is rejected with the reason from\n\tthe first promise in the iterable that rejected. This method can be\n\tuseful for aggregating results of multiple promises.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Array<Dynamic>> {})\nstatic function all<T>(iterable:Array<Promise<T>>):Promise<Array<T>>;\n\n/**\n\tReturns a promise that resolves after all of the given promises have either fulfilled or rejected,\n\twith an array of objects that each describes the outcome of each promise.\n\n\tIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\n\tto complete successfully, or you'd always like to know the result of each promise.\n\n\tIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\n\ton each other / if you'd like to immediately reject upon any of them rejecting.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Array<PromiseSettleOutcome<Dynamic>>> {})\nstatic function allSettled<T>(iterable:Array<Promise<T>>):Promise<Array<PromiseSettleOutcome<T>>>;\n\n/**\n\tReturns a promise that fulfills or rejects as soon as one of the\n\tpromises in the iterable fulfills or rejects, with the value or reason\n\tfrom that promise.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Dynamic> {})\nstatic function race<T>(iterable:Array<Promise<T>>):Promise<T>;\n\n/** @throws DOMError */\nfunction new(init:(resolve:(value:T) -> Void, reject:(reason:Dynamic) -> Void) -> Void):Void;\n\n/**\n\tAppends fulfillment and rejection handlers to the promise and returns a\n\tnew promise resolving to the return value of the called handler, or to\n\tits original settled value if the promise was not handled\n\t(i.e. if the relevant handler onFulfilled or onRejected is not a function).\n*/\nfunction then<TOut>(onFulfilled:Null<PromiseHandler<T, TOut>>, ?onRejected:PromiseHandler<Dynamic, TOut>):Promise<TOut>;\n\n/**\n\tAppends a rejection handler callback to the promise, and returns a new\n\tpromise resolving to the return value of the callback if it is called,\n\tor to its original fulfillment value if the promise is instead fulfilled.\n*/\n@:native(\"catch\")\n@:overload(function<TOut>(onRejected:PromiseHandler<Dynamic, TOut>):Promise<EitherType<T, TOut>> {})\nfunction catchError(onRejected:PromiseHandler<Dynamic, T>):Promise<T>;\n\n/**\n\tReturns a Promise. When the promise is settled, i.e either fulfilled or rejected,\n\tthe specified callback function is executed. This provides a way for code to be run\n\twhether the promise was fulfilled successfully or rejected once the Promise has been dealt with.\n*/\nfunction finally(onFinally:() -> Void):Promise<T>;\n}\n\n/**\nHandler type for the Promise object.",
    "path": "haxe\\std\\js\\lib\\Promise.hx",
    "functions": {
      "reject": "Returns a Promise object that is rejected with the given reason.",
      "all": "Returns a promise that either fulfills when all of the promises in the\n\titerable argument have fulfilled or rejects as soon as one of the\n\tpromises in the iterable argument rejects. If the returned promise\n\tfulfills, it is fulfilled with an array of the values from the\n\tfulfilled promises in the same order as defined in the iterable.\n\tIf the returned promise rejects, it is rejected with the reason from\n\tthe first promise in the iterable that rejected. This method can be\n\tuseful for aggregating results of multiple promises.",
      "allSettled": "Returns a promise that resolves after all of the given promises have either fulfilled or rejected,\n\twith an array of objects that each describes the outcome of each promise.\n\n\tIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\n\tto complete successfully, or you'd always like to know the result of each promise.\n\n\tIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\n\ton each other / if you'd like to immediately reject upon any of them rejecting.",
      "race": "Returns a promise that fulfills or rejects as soon as one of the\n\tpromises in the iterable fulfills or rejects, with the value or reason\n\tfrom that promise.",
      "new": "@throws DOMError",
      "then": "Appends fulfillment and rejection handlers to the promise and returns a\n\tnew promise resolving to the return value of the called handler, or to\n\tits original settled value if the promise was not handled\n\t(i.e. if the relevant handler onFulfilled or onRejected is not a function).",
      "catchError": "Appends a rejection handler callback to the promise, and returns a new\n\tpromise resolving to the return value of the callback if it is called,\n\tor to its original fulfillment value if the promise is instead fulfilled.",
      "finally": "Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,\n\tthe specified callback function is executed. This provides a way for code to be run\n\twhether the promise was fulfilled successfully or rejected once the Promise has been dealt with."
    },
    "fields": {}
  },
  "js.lib.RegExpMatch": {
    "doc": "Native JavaScript regular expressions.\n\nFor cross-platform regular expressions, use Haxe `EReg` class or\n[regexp literals](https://haxe.org/manual/std-regex.html).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>\n*/\n@:native(\"RegExp\")\nextern class RegExp {\n/**\n\tIndicates whether or not the \"g\" flag is used with the regular expression.\n*/\nvar global(default, null):Bool;\n\n/**\n\tIndicates whether or not the \"i\" flag is used with the regular expression.\n*/\nvar ignoreCase(default, null):Bool;\n\n/**\n\tIndicates whether or not the \"m\" flag is used with the regular expression.\n*/\nvar multiline(default, null):Bool;\n\n/**\n\tThe source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.\n*/\nvar source(default, null):String;\n\n/**\n\tThe index at which to start the next match.\n*/\nvar lastIndex:Int;\n\n/**\n\tCreate a regular expression object for matching text with a pattern.\n*/\nfunction new(pattern:String, ?flags:String);\n\n/**\n\tExecute a search for a match in a specified string.\n\tReturns a result array, or null.\n*/\nfunction exec(str:String):Null<RegExpMatch>;\n\n/**\n\tExecute a search for a match between a regular expression and a specified string.\n\tReturns true or false.\n*/\nfunction test(str:String):Bool;\n\n/**\n\tReturn a string representing the regular expression.\n*/\nfunction toString():String;\n}\n\n/**\nA return value of the `RegExp.exec` method.",
    "path": "haxe\\std\\js\\lib\\RegExp.hx",
    "functions": {
      "exec": "Execute a search for a match in a specified string.\n\tReturns a result array, or null.",
      "test": "Execute a search for a match between a regular expression and a specified string.\n\tReturns true or false.",
      "toString": "Return a string representing the regular expression."
    },
    "fields": {
      "ignoreCase": "Indicates whether or not the \"i\" flag is used with the regular expression.",
      "multiline": "Indicates whether or not the \"m\" flag is used with the regular expression.",
      "source": "The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.",
      "lastIndex": "The index at which to start the next match.",
      "index": "Create a regular expression object for matching text with a pattern.\n*/\nfunction new(pattern:String, ?flags:String);\n\n/**\n\tExecute a search for a match in a specified string.\n\tReturns a result array, or null.\n*/\nfunction exec(str:String):Null<RegExpMatch>;\n\n/**\n\tExecute a search for a match between a regular expression and a specified string.\n\tReturns true or false.\n*/\nfunction test(str:String):Bool;\n\n/**\n\tReturn a string representing the regular expression.\n*/\nfunction toString():String;\n}\n\n/**\nA return value of the `RegExp.exec` method.\n*/\nextern class RegExpMatch extends Array<String> {\n/**\n\tThe index of the search at which the result was found.",
      "input": "A copy of the search string.",
      "groups": "Named capturing groups or undefined if no named capturing groups were defined.\n\tSee [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.\n\n\tNote: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility)."
    }
  },
  "js.lib.SetKeyValueIterator": {
    "doc": "The `js.Set` object lets you store unique values of any type, whether\nprimitive values or object references.\n\nDocumentation [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Set\")\nextern class Set<T> {\n/**\n\tThe number of values in the `js.Set` object.\n*/\nvar size(default, null):Int;\n\n/**\n\tIf an iterable object is passed, all of its elements will be added to\n\tthe new `js.Set`.\n*/\n@:pure function new(?iterable:Any);\n\n/**\n\tReturns a boolean asserting whether an element is present with the given\n\tvalue in the `js.Set` object or not.\n*/\n@:pure function has(value:T):Bool;\n\n/**\n\tAppends a new element with the given value to the `js.Set` object.\n\tReturns the `js.Set` object.\n*/\nfunction add(value:T):Set<T>;\n\n/**\n\tRemoves the element associated to the value and returns the value that\n\t`has(value)` would have previously returned.\n\t`has(value)` will return `false` afterwards.\n*/\nfunction delete(value:T):Bool;\n\n/**\n\tRemoves all elements from the `js.Set` object.\n*/\nfunction clear():Void;\n\n/**\n\tCalls `callback` once for each key-value pair present in the `js.Set`\n\tobject, in insertion order.\n\n\tIf a `thisArg` parameter is provided to forEach, it will be used as the\n\t`this` value for each callback.\n*/\nfunction forEach(callback:(value:T, key:T, set:Set<T>) -> Void, ?thisArg:Any):Void;\n\n/**\n\tReturns a new `js.lib.Iterator` object that contains the keys for each element\n\tin the `js.Set` object in insertion order.\n*/\nfunction keys():js.lib.Iterator<T>;\n\n/**\n\tReturns a new `js.lib.Iterator` object that contains the values for each\n\telement in the `js.Set` object in insertion order.\n*/\nfunction values():js.lib.Iterator<T>;\n\n/**\n\tReturns a new `js.lib.Iterator` object that contains an array of\n\t`[value, value]` for each element in the `js.Set` object, in insertion\n\torder.\n\tThis is kept similar to the `js.Map` object, so that each entry has the\n\tsame value for its key and value here.\n*/\nfunction entries():js.lib.Iterator<KeyValue<T, T>>;\n\ninline function iterator():HaxeIterator<T> {\n\treturn new HaxeIterator(this.values());\n}\n\ninline function keyValueIterator():SetKeyValueIterator<T> {\n\treturn new SetKeyValueIterator(this);\n}\n}\n\n/**\nkey => value iterator for js.lib.Set, tracking the entry index for the key to match the behavior of haxe.ds.List",
    "path": "haxe\\std\\js\\lib\\Set.hx",
    "functions": {
      "delete": "Removes the element associated to the value and returns the value that\n\t`has(value)` would have previously returned.\n\t`has(value)` will return `false` afterwards.",
      "clear": "Removes all elements from the `js.Set` object.",
      "forEach": "Calls `callback` once for each key-value pair present in the `js.Set`\n\tobject, in insertion order.\n\n\tIf a `thisArg` parameter is provided to forEach, it will be used as the\n\t`this` value for each callback.",
      "keys": "Returns a new `js.lib.Iterator` object that contains the keys for each element\n\tin the `js.Set` object in insertion order.",
      "values": "Returns a new `js.lib.Iterator` object that contains the values for each\n\telement in the `js.Set` object in insertion order.",
      "entries": "Returns a new `js.lib.Iterator` object that contains an array of\n\t`[value, value]` for each element in the `js.Set` object, in insertion\n\torder.\n\tThis is kept similar to the `js.Map` object, so that each entry has the\n\tsame value for its key and value here."
    },
    "fields": {}
  },
  "lua.abstract": {
    "doc": "These are all global static methods within Lua.\n*/\n@:native(\"_G\")\nextern class Lua {\n/**\n\tA global variable that holds a string containing the current interpreter\n\tversion.\n*/\nstatic var _VERSION:String;\n\nstatic var arg:Table<Int, String>;\n\n/**\n\tPushes onto the stack the metatable in the registry.\n*/\nstatic function getmetatable(tbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n/**\n\tPops a table from the stack and sets it as the new metatable for the value\n\tat the given acceptable index.\n*/\nstatic function setmetatable(tbl:Table<Dynamic, Dynamic>, mtbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n/**\n\tPops a table from the stack and sets it as the new environment for the value\n\tat the given index. If the value at the given index is neither a function nor\n\ta thread nor a userdata, lua_setfenv returns `0`.\n\tOtherwise it returns `1`.\n*/\nstatic function setfenv(i:Int, tbl:Table<Dynamic, Dynamic>):Void;\n\n/**\n\tAllows a program to traverse all fields of a table.\n\tIts first argument is a table and its second argument is an index in this\n\ttable. `next` returns the next index of the table and its associated value.\n\tWhen `i` is `null`, `next` returns an initial index and its associated value.\n\tWhen called with the last index, or with `null` in an empty table, `next`\n\treturns `null`.  In particular, you can use `next(t)` to check whether a\n\ttable is empty.\n\n\tThe order in which the indices are enumerated is not specified, even for\n\tnumeric indices. (To traverse a table in numeric order, use a numerical for\n\tor the `ipairs` function).\n\n\tThe behavior of next is undefined if, during the traversal, any value\n\tto a non-existent field in the table is assigned. Existing fields may\n\thowever be modified. In particular, existing fields may be cleared.\n*/\nstatic function next<K, V>(k:Table<K, V>, ?i:K):NextResult<K, V>;\n\n/**\n\tReceives an argument of any type and converts it to a string in a reasonable\n\tformat.\n\n\tFor complete control of how numbers are converted, use`NativeStringTools.format`.\n*/\nstatic function tostring(v:Dynamic):String;\n\nstatic function ipairs<K, V>(t:Table<K, V>):IPairsResult<K, V>;\n\nstatic function pairs<K, V>(t:Table<K, V>):PairsResult<K, V>;\n\nstatic function require(module:String):Dynamic;\n\n/**\n\tConverts the Lua value at the given acceptable base to `Int`.\n\tThe Lua value must be a number or a string convertible to a number,\n\totherwise `tonumber` returns `0`.\n*/\nstatic function tonumber(str:String, ?base:Int):Int;\n\n/**\n\tReturns the Lua type of its only argument as a string.\n\tThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`\n*/\nstatic function type(v:Dynamic):String;\n\n/**\n\tReceives any number of arguments, and prints their values to stdout,\n\tusing the tostring function to convert them to strings.\n\t`print` is not intended for formatted output, but only as a quick way to show\n\ta value, typically for debugging.\n\n\tFor complete control of how numbers are converted, use `NativeStringTools.format`.\n*/\nstatic function print(v:haxe.extern.Rest<Dynamic>):Void;\n\n/**\n\tIf `n` is a number, returns all arguments after argument number `n`.\n\tOtherwise, `n` must be the string `\"#\"`, and select returns the total\n\tnumber of extra arguments it received.\n*/\nstatic function select(n:Dynamic, rest:Rest<Dynamic>):Dynamic;\n\n/**\n\tGets the real value of `table[index]`, without invoking any metamethod.\n*/\nstatic function rawget<K, V>(t:Table<K, V>, k:K):V;\n\n/**\n\tSets the real value of `table[index]` to value, without invoking any metamethod.\n*/\nstatic function rawset<K, V>(t:Table<K, V>, k:K, v:V):Void;\n\n/**\n\tThis function is a generic interface to the garbage collector.\n\tIt performs different functions according to its first argument.\n*/\nstatic function collectgarbage(opt:CollectGarbageOption, ?arg:Int):Int;\n\n/**\n\tIssues an error when the value of its argument `v` is `false` (i.e., `null`\n\tor `false`) otherwise, returns all its arguments. message is an error message.\n\twhen absent, it defaults to \"assertion failed!\"\n*/\nstatic function assert<T>(v:T, ?message:String):T;\n\n/**\n\tLoads and runs the given file.\n*/\nstatic function dofile(filename:String):Void;\n\n/**\n\tGenerates a Lua error. The error message (which can actually be a Lua value\n\tof any type) must be on the stack top. This function does a long jump,\n\tand therefore never returns.\n*/\nstatic function error(message:String, ?level:Int):Void;\n\n/**\n\tCalls a function in protected mode.\n*/\nstatic function pcall(f:Function, rest:Rest<Dynamic>):PCallResult;\n\n/**\n\tReturns `true` if the two values in acceptable indices `v1` and `v2` are\n\tprimitively equal (that is, without calling metamethods).\n\tOtherwise returns `false`.\n\tAlso returns `false` if any of the indices are non valid.\n*/\nstatic function rawequal(v1:Dynamic, v2:Dynamic):Bool;\n\n/**\n\tThis function is similar to pcall, except that you can set a new error\n\thandler.\n*/\nstatic function xpcall(f:Function, msgh:Function, rest:Rest<Dynamic>):PCallResult;\n\n/**\n\tLoads the chunk from file filename or from the standard input if no filename\n\tis given.\n*/\nstatic function loadfile(filename:String):LoadResult;\n\n/**\n\tLoads the chunk from given string.\n*/\nstatic function load(code:haxe.extern.EitherType<String, Void->String>):LoadResult;\n}\n\n/**\nEnum for describing garbage collection options",
    "path": "haxe\\std\\lua\\Lua.hx",
    "functions": {
      "setmetatable": "Pops a table from the stack and sets it as the new metatable for the value\n\tat the given acceptable index.",
      "setfenv": "Pops a table from the stack and sets it as the new environment for the value\n\tat the given index. If the value at the given index is neither a function nor\n\ta thread nor a userdata, lua_setfenv returns `0`.\n\tOtherwise it returns `1`.",
      "next": "Allows a program to traverse all fields of a table.\n\tIts first argument is a table and its second argument is an index in this\n\ttable. `next` returns the next index of the table and its associated value.\n\tWhen `i` is `null`, `next` returns an initial index and its associated value.\n\tWhen called with the last index, or with `null` in an empty table, `next`\n\treturns `null`.  In particular, you can use `next(t)` to check whether a\n\ttable is empty.\n\n\tThe order in which the indices are enumerated is not specified, even for\n\tnumeric indices. (To traverse a table in numeric order, use a numerical for\n\tor the `ipairs` function).\n\n\tThe behavior of next is undefined if, during the traversal, any value\n\tto a non-existent field in the table is assigned. Existing fields may\n\thowever be modified. In particular, existing fields may be cleared.",
      "tostring": "Receives an argument of any type and converts it to a string in a reasonable\n\tformat.\n\n\tFor complete control of how numbers are converted, use`NativeStringTools.format`.",
      "tonumber": "Converts the Lua value at the given acceptable base to `Int`.\n\tThe Lua value must be a number or a string convertible to a number,\n\totherwise `tonumber` returns `0`.",
      "type": "Returns the Lua type of its only argument as a string.\n\tThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`",
      "print": "Receives any number of arguments, and prints their values to stdout,\n\tusing the tostring function to convert them to strings.\n\t`print` is not intended for formatted output, but only as a quick way to show\n\ta value, typically for debugging.\n\n\tFor complete control of how numbers are converted, use `NativeStringTools.format`.",
      "select": "If `n` is a number, returns all arguments after argument number `n`.\n\tOtherwise, `n` must be the string `\"#\"`, and select returns the total\n\tnumber of extra arguments it received.",
      "rawget": "Gets the real value of `table[index]`, without invoking any metamethod.",
      "rawset": "Sets the real value of `table[index]` to value, without invoking any metamethod.",
      "collectgarbage": "This function is a generic interface to the garbage collector.\n\tIt performs different functions according to its first argument.",
      "assert": "Issues an error when the value of its argument `v` is `false` (i.e., `null`\n\tor `false`) otherwise, returns all its arguments. message is an error message.\n\twhen absent, it defaults to \"assertion failed!\"",
      "dofile": "Loads and runs the given file.",
      "error": "Generates a Lua error. The error message (which can actually be a Lua value\n\tof any type) must be on the stack top. This function does a long jump,\n\tand therefore never returns.",
      "pcall": "Calls a function in protected mode.",
      "rawequal": "Returns `true` if the two values in acceptable indices `v1` and `v2` are\n\tprimitively equal (that is, without calling metamethods).\n\tOtherwise returns `false`.\n\tAlso returns `false` if any of the indices are non valid.",
      "xpcall": "This function is similar to pcall, except that you can set a new error\n\thandler.",
      "loadfile": "Loads the chunk from file filename or from the standard input if no filename\n\tis given.",
      "load": "Loads the chunk from given string."
    },
    "fields": {}
  },
  "lua.HaxeIterator": {
    "doc": "An implementation of the Haxe iterator data structure needed for identical\nlua iterator behavior.",
    "path": "haxe\\std\\lua\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Lib": {
    "doc": "Platform-specific Lua Library. Provides some platform-specific functions\nfor the Lua target, such as conversion from Haxe types to native types\nand vice-versa.",
    "path": "haxe\\std\\lua\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.",
      "patternQuote": "Perform Lua-style pattern quoting on a given string.",
      "fillArray": "Fills an array with the result of a simple iterator.",
      "isShellAvailable": "Simple test for the presence of an available shell."
    },
    "fields": {}
  },
  "lua.PairTools": {
    "doc": "A set of utility methods for working with the Lua table extern.",
    "path": "haxe\\std\\lua\\PairTools.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Thread": {
    "doc": "The sole purpose of this extern is to provide a concrete type for\nbasic reflection purposes.",
    "path": "haxe\\std\\lua\\Thread.hx",
    "functions": {},
    "fields": {}
  },
  "neko.Lib": {
    "doc": "Platform-specific Neko Library. Provides some platform-specific functions\nfor the Neko target, such as conversion from Haxe types to native types\nand vice-versa.",
    "path": "haxe\\std\\neko\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.",
      "println": "Print the specified value on the default output followed by a newline character.",
      "rethrow": "Rethrow an exception. This is useful when manually filtering an exception in order\n\tto keep the previous exception stack.",
      "serialize": "Serialize using native Neko serialization. This will return a Binary string that can be\n\tstored for long term usage. The serialized data is optimized for speed and not for size.",
      "unserialize": "Unserialize a string using native Neko serialization. See `serialize`.",
      "localUnserialize": "Unserialize a string using native Neko serialization. See `serialize`.\n\tThis function assume that all the serialized data was serialized with current\n\tmodule, even if the module name was different. This can happen if you are unserializing\n\tsome data into mod_neko that was serialized on a different server using a different\n\tfile path.",
      "nekoToHaxe": "Converts a Neko value to its Haxe equivalent. Used for wrapping String and Arrays raw values into Haxe Objects.",
      "haxeToNeko": "Converts a Haxe value to its Neko equivalent. Used to unwrap String and Arrays Objects into raw Neko values.",
      "getClasses": "Returns an object containing all compiled packages and classes.",
      "stringReference": "Returns a string referencing the data contains in bytes.",
      "bytesReference": "Returns bytes referencing the content of a string."
    },
    "fields": {}
  },
  "neko.Random": {
    "doc": "A seeded pseudo-random generator.",
    "path": "haxe\\std\\neko\\Random.hx",
    "functions": {
      "setSeed": "Set the generator seed.",
      "int": "Return a random integer modulo max.",
      "float": "Return a random float."
    },
    "fields": {}
  },
  "neko.vm.Gc": {
    "doc": "Neko garbage collector utility.",
    "path": "haxe\\std\\neko\\vm\\Gc.hx",
    "functions": {
      "stats": "Return the size of the GC heap and the among of free space,\n\tin bytes."
    },
    "fields": {}
  },
  "neko.vm.Loader": {
    "doc": "The Neko object that implements the loader.\n*/\n@:callable\n@:coreType\nabstract LoaderHandle {}\n\n/**\nLoaders can be used to dynamically load Neko primitives stored in NDLL libraries.\n\n\nLoaders can be used to dynamically load other Neko modules (.n bytecode files).\nModules are referenced by names. To lookup the corresponding bytecode file, the\ndefault loader first look in its cache, then eventually adds the .n extension\nto the name and lookup the bytecode in its path.\n\n\nLoaders can be used for sandbox security. When a Module is loaded with a given\nLoader, this loader can manager the module security by filtering which\nprimitives can be loaded by this module or by rewrapping them at loading-time\nwith custom secured versions. Loaders are inherited in loaded submodules.",
    "path": "haxe\\std\\neko\\vm\\Loader.hx",
    "functions": {
      "addPath": "Adds a directory to the search path. See `getPath`.",
      "getCache": "The default loader contains a cache of already loaded modules. It's\n\tensuring that the same module does not get loaded twice when circular\n\treferences are occurring. The same module can eventually be loaded twice\n\tbut with different names, for example with two relative paths representing\n\tthe same file, since the cache is done on a by-name basic.",
      "setCache": "Set a module in the loader cache.",
      "backupCache": "Change the cache value and returns the old value. This can be used\n\tto backup the loader cache and restore it later.",
      "loadPrimitive": "Loads a neko primitive. By default, the name is of the form `[library@method]`.\n\tThe primitive might not be used directly in Haxe since some of the Neko values\n\tneeds an object wrapper in Haxe.",
      "loadModule": "Loads a Module with the given name. If `loader` is defined, this will be\n\tthis Module loader, else this loader will be inherited. When loaded this\n\tway, the module is directly executed.",
      "local": "Returns the local Loader. This is the loader that was used to load the\n\tmodule in which the code is defined.",
      "make": "Creates a loader using two methods. This loader will not have an accessible cache or path,\n\talthough you can implement such mechanism in the methods body."
    },
    "fields": {}
  },
  "neko.vm.Module": {
    "doc": "The abstract Neko module handle.\n*/\n@:callable\n@:coreType\nabstract ModuleHandle {}\n\n/**\nA Neko Module represent a execution unit for the Neko Virtual Machine.\nEach compiled `.n` bytecode file is a module once loaded by the NekoVM.",
    "path": "haxe\\std\\neko\\vm\\Module.hx",
    "functions": {
      "loader": "Returns the Loader that this Module was loaded with.",
      "codeSize": "Returns the codeSize of the Module.",
      "globalsCount": "Returns the number of globals in this Module global table.",
      "getGlobal": "Get a Module global value.",
      "setGlobal": "Set a Module global value.",
      "getExports": "Each Module has an export table which can be useful to transfer\n\tvalues between modules.",
      "exportsTable": "The raw export table.",
      "setExport": "Set a value in the Module export table.",
      "local": "Returns the local Module, which is the one in which this\n\tmethod is included.",
      "read": "Reads a module from an Input by using the given Loader.\n\tThe module is initialized but has not yet been executed.",
      "readBytes": "Reads a module from Bytes using the given Loader.\n\tThe module is initialized but has not yet been executed.",
      "readPath": "Reads a module from a name and using the specified search path and loader.\n\tThe module is initialized but has not yet been executed.",
      "readGlobalsNames": "Extract the globals names from the given module"
    },
    "fields": {}
  },
  "neko.vm.Ui": {
    "doc": "Core native User Interface support. This API uses native WIN32 API\non Windows, Carbon API on OSX, and GTK2 on Linux.",
    "path": "haxe\\std\\neko\\vm\\Ui.hx",
    "functions": {
      "loop": "Starts the native UI event loop. This method can only be called\n\tfrom the main thread.",
      "stopLoop": "Stop the native UI event loop. This method can only be called\n\tfrom the main thread.",
      "sync": "Queue a method call callb to be executed by the main thread while\n\trunning the UI event loop. This can be used to perform UI updates\n\tin the UI thread using results processed by another thread."
    },
    "fields": {}
  },
  "php.Lib": {
    "doc": "Platform-specific PHP Library. Provides some platform-specific functions\nfor the PHP target, such as conversion from Haxe types to native types\nand vice-versa.",
    "path": "haxe\\std\\php\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by\n\ta newline character.",
      "dump": "Displays structured information about one or more expressions\n\tthat includes its type and value. Arrays and objects are\n\texplored recursively with values indented to show structure.",
      "serialize": "Serialize using native PHP serialization. This will return a binary\n\t`String` that can be stored for long term usage.",
      "unserialize": "Unserialize a `String` using native PHP serialization. See `php.Lib.serialize()`.",
      "extensionLoaded": "Find out whether an extension is loaded.",
      "printFile": "Output file content from the given file name.",
      "mail": "See the documentation for the equivalent PHP function for details on usage:\n\t<http://php.net/manual/en/function.mail.php>",
      "getClasses": "Rethrows an exception.\n\tIf `e` is not a value caught in `try...catch` or if called outside of `catch` block, then `e` is thrown as\n\ta new exception.\n*/\nextern public static inline function rethrow(e:Dynamic) {\n\tif (Syntax.code(\"isset($__hx__caught_e, $__hx__real_e)\") && e == Syntax.code(\"$__hx__real_e\")) {\n\t\tSyntax.code(\"throw $__hx__caught_e\");\n\t}\n\tthrow e;\n}\n\n/**\n\tTries to load all compiled php files and returns list of types.",
      "loadLib": "Loads types defined in the specified directory."
    },
    "fields": {}
  },
  "php.Resource": {
    "doc": "PHP native `resource` type\n@see http://php.net/manual/en/language.types.resource.php",
    "path": "haxe\\std\\php\\Resource.hx",
    "functions": {},
    "fields": {}
  },
  "php.Session": {
    "doc": "Session consists of a way to preserve certain data across\nsubsequent accesses.",
    "path": "haxe\\std\\php\\Session.hx",
    "functions": {},
    "fields": {}
  },
  "python.KwArgs": {
    "doc": "This type represents python `**kwargs` feature, supporting\npassing named arguments to a function.\n\nExample:\n\n```haxe\nfunction f(kwargs:KwArgs<{a:Int}>) {}\nf({a: 10});\n```",
    "path": "haxe\\std\\python\\KwArgs.hx",
    "functions": {},
    "fields": {}
  },
  "python.Lib": {
    "doc": "Platform-specific Python Library. Provides some platform-specific functions\nfor the Python target, such as conversion from Haxe types to native types\nand vice-versa.",
    "path": "haxe\\std\\python\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by a newline character.",
      "dictToAnon": "Returns an anonymous Object which holds the same data as the Dictionary `v`.",
      "anonToDict": "Returns a flat copy of the underlying Dictionary of `o`.",
      "anonAsDict": "Returns the underlying Dictionary of the anonymous object `o`.\n\tModifications to this dictionary are reflected in the anonymous Object too.",
      "dictAsAnon": "Returns the Dictionary `d` as an anonymous Object.\n\tModifications to the object are reflected in the Dictionary too.",
      "toPythonIterable": "Return Python native iterable from Haxe iterable.",
      "toHaxeIterable": "Return Haxe iterable from Python native iterable.",
      "toHaxeIterator": "Return Haxe iterator instance from Python native iterable."
    },
    "fields": {}
  },
  "python.NativeIterable": {
    "doc": "This type represents native Python iterables (objects that implement `__iter__()` method).\nIt supports Haxe iteration and conversion to `Iterable` by creating wrapper objects.",
    "path": "haxe\\std\\python\\NativeIterable.hx",
    "functions": {},
    "fields": {}
  },
  "python.NativeIterator": {
    "doc": "This type represents native Python iterators.\nIt supports automatic conversion to Haxe `Iterator` by creating wrapper object.",
    "path": "haxe\\std\\python\\NativeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "python.internal.UBuiltins": {
    "doc": "This class provides unqualified access to python builtins that are safe to use in haxe/python code.\nFields listed here must be synchronized with genpy's KeywordHandler.kwds2 list to be properly escaped.",
    "path": "haxe\\std\\python\\internal\\UBuiltins.hx",
    "functions": {},
    "fields": {}
  },
  "sys.FileSystem": {
    "doc": "This class provides information about files and directories.\n\nIf `null` is passed as a file path to any function in this class, the\nresult is unspecified, and may differ from target to target.\n\nSee `sys.io.File` for the complementary file API.",
    "path": "haxe\\std\\sys\\FileSystem.hx",
    "functions": {
      "rename": "Renames/moves the file or directory specified by `path` to `newPath`.\n\n\tIf `path` is not a valid file system entry, or if it is not accessible,\n\tor if `newPath` is not accessible, an exception is thrown.",
      "stat": "Returns `FileStat` information for the file or directory specified by\n\t`path`.",
      "fullPath": "Returns the full path of the file or directory specified by `relPath`,\n\twhich is relative to the current working directory. Symlinks will be\n\tfollowed and the path will be normalized.",
      "absolutePath": "Returns the full path of the file or directory specified by `relPath`,\n\twhich is relative to the current working directory. The path doesn't\n\thave to exist.",
      "isDirectory": "Returns `true` if the file or directory specified by `path` is a directory.\n\n\tIf `path` is not a valid file system entry or if its destination is not\n\taccessible, an exception is thrown.",
      "createDirectory": "Creates a directory specified by `path`.\n\n\tThis method is recursive: The parent directories don't have to exist.\n\n\tIf the directory cannot be created, an exception is thrown.",
      "deleteFile": "Deletes the file specified by `path`.\n\n\tIf `path` does not denote a valid file, or if that file cannot be\n\tdeleted, an exception is thrown.",
      "deleteDirectory": "Deletes the directory specified by `path`. Only empty directories can\n\tbe deleted.\n\n\tIf `path` does not denote a valid directory, or if that directory cannot\n\tbe deleted, an exception is thrown.",
      "readDirectory": "Returns the names of all files and directories in the directory specified\n\tby `path`. `\".\"` and `\"..\"` are not included in the output.\n\n\tIf `path` does not denote a valid directory, an exception is thrown."
    },
    "fields": {}
  },
  "sys.io.File": {
    "doc": "API for reading and writing files.\n\nSee `sys.FileSystem` for the complementary file system API.",
    "path": "haxe\\std\\sys\\io\\File.hx",
    "functions": {
      "saveContent": "Stores `content` in the file specified by `path`.\n\n\tIf the file cannot be written to, an exception is thrown.\n\n\tIf `path` or `content` are null, the result is unspecified.",
      "getBytes": "Retrieves the binary content of the file specified by `path`.\n\n\tIf the file does not exist or can not be read, an exception is thrown.\n\n\t`sys.FileSystem.exists` can be used to check for existence.\n\n\tIf `path` is null, the result is unspecified.",
      "saveBytes": "Stores `bytes` in the file specified by `path` in binary mode.\n\n\tIf the file cannot be written to, an exception is thrown.\n\n\tIf `path` or `bytes` are null, the result is unspecified.",
      "read": "Returns an `FileInput` handle to the file specified by `path`.\n\n\tIf `binary` is true, the file is opened in binary mode. Otherwise it is\n\topened in non-binary mode.\n\n\tIf the file does not exist or can not be read, an exception is thrown.\n\n\tOperations on the returned `FileInput` handle read on the opened file.\n\n\tFile handles should be closed via `FileInput.close` once the operation\n\tis complete.\n\n\tIf `path` is null, the result is unspecified.",
      "write": "Returns an `FileOutput` handle to the file specified by `path`.\n\n\tIf `binary` is true, the file is opened in binary mode. Otherwise it is\n\topened in non-binary mode.\n\n\tIf the file cannot be written to, an exception is thrown.\n\n\tOperations on the returned `FileOutput` handle write to the opened file.\n\tIf the file existed, its previous content is overwritten.\n\n\tFile handles should be closed via `FileOutput.close` once the operation\n\tis complete.\n\n\tIf `path` is null, the result is unspecified.",
      "append": "Similar to `sys.io.File.write`, but appends to the file if it exists\n\tinstead of overwriting its contents.",
      "update": "Similar to `sys.io.File.append`. While `append` can only seek or write\n\tstarting from the end of the file's previous contents, `update` can\n\tseek to any position, so the file's previous contents can be\n\tselectively overwritten.",
      "copy": "Copies the contents of the file specified by `srcPath` to the file\n\tspecified by `dstPath`.\n\n\tIf the `srcPath` does not exist or cannot be read, or if the `dstPath`\n\tfile cannot be written to, an exception is thrown.\n\n\tIf the file at `dstPath` exists, its contents are overwritten.\n\n\tIf `srcPath` or `dstPath` are null, the result is unspecified."
    },
    "fields": {}
  },
  "sys.io.FileInput": {
    "doc": "Use `sys.io.File.read` to create a `FileInput`.",
    "path": "haxe\\std\\sys\\io\\FileInput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.io.FileOutput": {
    "doc": "Use `sys.io.File.write` to create a `FileOutput`.",
    "path": "haxe\\std\\sys\\io\\FileOutput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Address": {
    "doc": "An address is used to represent a port on a given host ip.\nIt is used by `sys.net.UdpSocket`.",
    "path": "haxe\\std\\sys\\net\\Address.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Host": {
    "doc": "A given IP host name.",
    "path": "haxe\\std\\sys\\net\\Host.hx",
    "functions": {
      "toString": "Returns the IP representation of the host",
      "reverse": "Perform a reverse-DNS query to resolve a host name from an IP.",
      "localhost": "Returns the local computer host name"
    },
    "fields": {
      "ip": "The actual IP corresponding to the host."
    }
  },
  "sys.net.Socket": {
    "doc": "A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.",
    "path": "haxe\\std\\sys\\net\\Socket.hx",
    "functions": {
      "close": "Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.",
      "read": "Read the whole data available on the socket.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`,\n\tas it will always throw `haxe.io.Error.Blocked`. `input` methods should be used directly instead.",
      "write": "Write the whole data to the socket output.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`, as\n\t`haxe.io.Error.Blocked` may be thrown mid-write with no indication of how many bytes have been written.\n\t`output.writeBytes()` should be used instead as it returns this information.",
      "connect": "Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.",
      "listen": "Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.",
      "shutdown": "Shutdown the socket, either for reading or writing.",
      "bind": "Bind the socket to the given host/port so it can afterwards listen for connections there.",
      "accept": "Accept a new connected client. This will return a connected socket on which you can read/write some data.",
      "peer": "Return the information about the other side of a connected socket.",
      "host": "Return the information about our side of a connected socket.",
      "setTimeout": "Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.",
      "waitForRead": "Block until some data is available for read on the socket.",
      "setBlocking": "Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.",
      "setFastSend": "Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.",
      "select": "Wait until one of the sockets group is ready for the given operation:\n\n\t - `read` contains sockets on which we want to wait for available data to be read,\n\t - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,\n\t - `others` contains sockets on which we want to wait for exceptional conditions.\n\t - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.\n\n\tIn case a `timeout` (in seconds) is specified, select might wait at worst until the timeout expires."
    },
    "fields": {
      "output": "The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.",
      "custom": "A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.\n*"
    }
  },
  "sys.net.UdpSocket": {
    "doc": "A UDP socket class",
    "path": "haxe\\std\\sys\\net\\UdpSocket.hx",
    "functions": {
      "sendTo": "Sends data to the specified target host/port address.",
      "readFrom": "Reads data from any incoming address and store the receiver address into the address parameter."
    },
    "fields": {}
  },
  "sys.ssl.Socket": {
    "doc": "A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.",
    "path": "haxe\\std\\sys\\ssl\\Socket.hx",
    "functions": {
      "setCA": "Configure the certificate chain for peer certificate verification.",
      "setHostname": "Configure the hostname for Server Name Indication TLS extension.",
      "setCertificate": "Configure own certificate and private key.",
      "addSNICertificate": "Configure additional certificates and private keys for Server Name Indication extension.\n\tThe callback may be called during handshake to determine the certificate to use.",
      "peerCertificate": "Return the certificate received from the other side of a connection."
    },
    "fields": {}
  },
  "sys.thread.NextEventTime": {
    "doc": "When an event loop has an available event to execute.",
    "path": "haxe\\std\\sys\\thread\\EventLoop.hx",
    "functions": {
      "cancel": "Prevent execution of a previously scheduled event in current loop.",
      "promise": "Notify this loop about an upcoming event.\n\tThis makes the thread stay alive and wait for as many events as the number of\n\ttimes `.promise()` was called. These events should be added via `.runPromised()`.",
      "run": "Execute `event` as soon as possible.",
      "runPromised": "Add previously promised `event` for execution.",
      "progress": "Executes all pending events.\n\n\tThe returned time stamps can be used with `Sys.time()` for calculations.\n\n\tDepending on a target platform this method may be non-reentrant. It must\n\tnot be called from event callbacks.",
      "wait": "Blocks until a new event is added or `timeout` (in seconds) to expires.\n\n\tDepending on a target platform this method may also automatically execute arriving\n\tevents while waiting. However if any event is executed it will stop waiting.\n\n\tReturns `true` if more events are expected.\n\tReturns `false` if no more events expected.\n\n\tDepending on a target platform this method may be non-reentrant. It must\n\tnot be called from event callbacks.",
      "loop": "Execute all pending events.\n\tWait and execute as many events as the number of times `promise()` was called.\n\tRuns until all repeating events are cancelled and no more events are expected.\n\n\tDepending on a target platform this method may be non-reentrant. It must\n\tnot be called from event callbacks.",
      "__progress": "`.progress` implementation with a reusable array for internal usage.\n\tThe `nextEventAt` field of the return value denotes when the next event\n\tis expected to run:\n-1 - never\n-2 - now\nother values - at specified time"
    },
    "fields": {}
  },
  "sys.thread.IThreadPool": {
    "doc": "A thread pool interface.",
    "path": "haxe\\std\\sys\\thread\\IThreadPool.hx",
    "functions": {
      "shutdown": "Initiates a shutdown.\n\tAll previously submitted tasks will be executed, but no new tasks will\n\tbe accepted.\n\n\tMultiple calls to this method have no effect."
    },
    "fields": {
      "isShutdown": "Indicates if `shutdown` method of this pool has been called."
    }
  },
  "sys.thread.Lock": {
    "doc": "A Lock allows blocking execution until it has been unlocked. It keeps track\nof how often `release` has been called, and blocks exactly as many `wait`\ncalls.\n\nThe order of the `release` and `wait` calls is irrelevant. That is, a Lock\ncan be released before anyone waits for it. In that case, the `wait` call\nwill execute immediately.\n\nUsage example:\n\n```haxe\nvar lock = new Lock();\nvar elements = [1, 2, 3];\nfor (element in elements) {\n\t// Create one thread per element\n\tnew Thread(function() {\n\t\ttrace(element);\n\t\tSys.sleep(1);\n\t\t// Release once per thread = 3 times\n\t\tlock.release();\n\t});\n}\nfor (_ in elements) {\n\t// Wait 3 times\n\tlock.wait();\n}\ntrace(\"All threads finished\");\n```",
    "path": "haxe\\std\\sys\\thread\\Lock.hx",
    "functions": {
      "wait": "Waits for the lock to be released, or `timeout` (in seconds)\n\tto expire. Returns `true` if the lock is released and `false`\n\tif a time-out occurs.",
      "release": "Releases the lock once.\n\n\tThe thread does not need to own the lock in order to release\n\tit. Each call to `release` allows exactly one call to `wait`\n\tto execute."
    },
    "fields": {}
  },
  "sys.thread.Mutex": {
    "doc": "Creates a mutex, which can be used to acquire a temporary lock\nto access some resource. The main difference with a lock is\nthat a mutex must always be released by the owner thread.",
    "path": "haxe\\std\\sys\\thread\\Mutex.hx",
    "functions": {
      "acquire": "The current thread acquire the mutex or wait if not available.\n\tThe same thread can acquire several times the same mutex but\n\tmust release it as many times it has been acquired.",
      "tryAcquire": "Try to acquire the mutex, returns true if acquire or false\n\tif it's already locked by another thread.",
      "release": "Release a mutex that has been acquired by the current thread.\n\tThe behavior is undefined if the current thread does not own\n\tthe mutex."
    },
    "fields": {}
  },
  "sys.thread.Tls": {
    "doc": "Creates thread local storage.\n\n(hl) Warning: At the moment `Tls` does not protect the value from being\ngarbage collected. Keep the value reachable to avoid crashes.",
    "path": "haxe\\std\\sys\\thread\\Tls.hx",
    "functions": {},
    "fields": {}
  }
}