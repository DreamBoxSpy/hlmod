{
  "Date": {
    "doc": "The Date class provides a basic structure for date and time related\n\tinformation. Date instances can be created by\n\n\t- `new Date()` for a specific date,\n\t- `Date.now()` to obtain information about the current time,\n\t- `Date.fromTime()` with a given timestamp or\n\t- `Date.fromString()` by parsing from a String.\n\n\tThere are some extra functions available in the `DateTools` class.\n\n\tIn the context of Haxe dates, a timestamp is defined as the number of\n\tmilliseconds elapsed since 1st January 1970 UTC.\n\n\t## Supported range\n\n\tDue to platform limitations, only dates in the range 1970 through 2038 are\n\tsupported consistently. Some targets may support dates outside this range,\n\tdepending on the OS at runtime. The `Date.fromTime` method will not work with\n\ttimestamps outside the range on any target.",
    "path": "haxe\\std\\Date.hx",
    "functions": {
      "getTime": "Returns the timestamp (in milliseconds) of `this` date.\n\t\tOn cpp and neko, this function only has a second resolution, so the\n\t\tresult will always be a multiple of `1000.0`, e.g. `1454698271000.0`.\n\t\tTo obtain the current timestamp with better precision on cpp and neko,\n\t\tsee the `Sys.time` API.\n\n\t\tFor measuring time differences with millisecond accuracy on\n\t\tall platforms, see `haxe.Timer.stamp`.",
      "getHours": "Returns the hours of `this` Date (0-23 range) in the local timezone.",
      "getMinutes": "Returns the minutes of `this` Date (0-59 range) in the local timezone.",
      "getSeconds": "Returns the seconds of `this` Date (0-59 range) in the local timezone.",
      "getFullYear": "Returns the full year of `this` Date (4 digits) in the local timezone.",
      "getMonth": "Returns the month of `this` Date (0-11 range) in the local timezone.\n\t\tNote that the month number is zero-based.",
      "getDate": "Returns the day of `this` Date (1-31 range) in the local timezone.",
      "getDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\n\t\tin the local timezone.",
      "getUTCHours": "Returns the hours of `this` Date (0-23 range) in UTC.",
      "getUTCMinutes": "Returns the minutes of `this` Date (0-59 range) in UTC.",
      "getUTCSeconds": "Returns the seconds of `this` Date (0-59 range) in UTC.",
      "getUTCFullYear": "Returns the full year of `this` Date (4 digits) in UTC.",
      "getUTCMonth": "Returns the month of `this` Date (0-11 range) in UTC.\n\t\tNote that the month number is zero-based.",
      "getUTCDate": "Returns the day of `this` Date (1-31 range) in UTC.",
      "getUTCDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\n\t\tin UTC.",
      "getTimezoneOffset": "Returns the time zone difference of `this` Date in the current locale\n\t\tto UTC, in minutes.\n\n\t\tAssuming the function is executed on a machine in a UTC+2 timezone,\n\t\t`Date.now().getTimezoneOffset()` will return `-120`.",
      "toString": "Returns a string representation of `this` Date in the local timezone\n\t\tusing the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for\n\t\tother formatting rules.",
      "now": "Returns a Date representing the current local time.",
      "fromTime": "Creates a Date from the timestamp (in milliseconds) `t`.",
      "fromString": "Creates a Date from the formatted string `s`. The following formats are\n\t\taccepted by the function:\n\n\t\t- `\"YYYY-MM-DD hh:mm:ss\"`\n\t\t- `\"YYYY-MM-DD\"`\n\t\t- `\"hh:mm:ss\"`\n\n\t\tThe first two formats expressed a date in local time. The third is a time\n\t\trelative to the UTC epoch.\n\n\t\tIf `s` does not match these formats, the result is unspecified."
    },
    "fields": {}
  },
  "DateTools": {
    "doc": "The DateTools class contains some extra functionalities for handling `Date`\n\tinstances and timestamps.\n\n\tIn the context of Haxe dates, a timestamp is defined as the number of\n\tmilliseconds elapsed since 1st January 1970.",
    "path": "haxe\\std\\DateTools.hx",
    "functions": {
      "delta": "Returns the result of adding timestamp `t` to Date `d`.\n\n\t\tThis is a convenience function for calling\n\t\t`Date.fromTime(d.getTime() + t)`.",
      "getMonthDays": "Returns the number of days in the month of Date `d`.\n\n\t\tThis method handles leap years.",
      "seconds": "Converts a number of seconds to a timestamp.",
      "minutes": "Converts a number of minutes to a timestamp.",
      "hours": "Converts a number of hours to a timestamp.",
      "days": "Converts a number of days to a timestamp.",
      "parse": "Separate a date-time into several components",
      "make": "Build a date-time from several components"
    },
    "fields": {}
  },
  "EReg": {
    "doc": "The EReg class represents regular expressions.\n\n\tWhile basic usage and patterns consistently work across platforms, some more\n\tcomplex operations may yield different results. This is a necessary trade-\n\toff to retain a certain level of performance.\n\n\tEReg instances can be created by calling the constructor, or with the\n\tspecial syntax `~/pattern/modifier`\n\n\tEReg instances maintain an internal state, which is affected by several of\n\tits methods.\n\n\tA detailed explanation of the supported operations is available at\n\t<https://haxe.org/manual/std-regex.html>",
    "path": "haxe\\std\\EReg.hx",
    "functions": {
      "match": "Tells if `this` regular expression matches String `s`.\n\n\t\tThis method modifies the internal state.\n\n\t\tIf `s` is `null`, the result is unspecified.",
      "matched": "Returns the matched sub-group `n` of `this` EReg.\n\n\t\tThis method should only be called after `this.match` or\n\t\t`this.matchSub`, and then operates on the String of that operation.\n\n\t\tThe index `n` corresponds to the n-th set of parentheses in the pattern\n\t\tof `this` EReg. If no such sub-group exists, the result is unspecified.\n\n\t\tIf `n` equals 0, the whole matched substring is returned.",
      "matchedLeft": "Returns the part to the left of the last matched substring.\n\n\t\tIf the most recent call to `this.match` or `this.matchSub` did not\n\t\tmatch anything, the result is unspecified.\n\n\t\tIf the global g modifier was in place for the matching, only the\n\t\tsubstring to the left of the leftmost match is returned.\n\n\t\tThe result does not include the matched part.",
      "matchedRight": "Returns the part to the right of the last matched substring.\n\n\t\tIf the most recent call to `this.match` or `this.matchSub` did not\n\t\tmatch anything, the result is unspecified.\n\n\t\tIf the global g modifier was in place for the matching, only the\n\t\tsubstring to the right of the leftmost match is returned.\n\n\t\tThe result does not include the matched part.",
      "matchedPos": "Returns the position and length of the last matched substring, within\n\t\tthe String which was last used as argument to `this.match` or\n\t\t`this.matchSub`.\n\n\t\tIf the most recent call to `this.match` or `this.matchSub` did not\n\t\tmatch anything, the result is unspecified.\n\n\t\tIf the global g modifier was in place for the matching, the position and\n\t\tlength of the leftmost substring is returned.",
      "matchSub": "Tells if `this` regular expression matches a substring of String `s`.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.match(s.substr(pos,len))` can be used instead.\n\n\t\tThis method modifies the internal state.\n\n\t\tIf `s` is null, the result is unspecified.",
      "matchedNum": "Returns the total number of groups captures by the last matched substring.\n\n\t\tTo stay consistent with `this.matched`, the matched substring is also\n\t\tcounted as a group.\n\n\t\tReturns `0` if no substring has been matched.",
      "split": "Splits String `s` at all substrings `this` EReg matches.\n\n\t\tIf a match is found at the start of `s`, the result contains a leading\n\t\tempty String \"\" entry.\n\n\t\tIf a match is found at the end of `s`, the result contains a trailing\n\t\tempty String \"\" entry.\n\n\t\tIf two matching substrings appear next to each other, the result\n\t\tcontains the empty String `\"\"` between them.\n\n\t\tBy default, this method splits `s` into two parts at the first matched\n\t\tsubstring. If the global g modifier is in place, `s` is split at each\n\t\tmatched substring.\n\n\t\tIf `s` is null, the result is unspecified.",
      "replace": "Replaces the first substring of `s` which `this` EReg matches with `by`.\n\n\t\tIf `this` EReg does not match any substring, the result is `s`.\n\n\t\tBy default, this method replaces only the first matched substring. If\n\t\tthe global g modifier is in place, all matched substrings are replaced.\n\n\t\tIf `by` contains `$1` to `$9`, the digit corresponds to number of a\n\t\tmatched sub-group and its value is used instead. If no such sub-group\n\t\texists, the replacement is unspecified. The string `$$` becomes `$`.\n\n\t\tIf `s` or `by` are null, the result is unspecified.",
      "map": "Calls the function `f` for the substring of `s` which `this` EReg matches\n\t\tand replaces that substring with the result of `f` call.\n\n\t\tThe `f` function takes `this` EReg object as its first argument and should\n\t\treturn a replacement string for the substring matched.\n\n\t\tIf `this` EReg does not match any substring, the result is `s`.\n\n\t\tBy default, this method replaces only the first matched substring. If\n\t\tthe global g modifier is in place, all matched substrings are replaced.\n\n\t\tIf `s` or `f` are null, the result is unspecified.",
      "escape": "Escape the string `s` for use as a part of regular expression.\n\n\t\tIf `s` is null, the result is unspecified."
    },
    "fields": {}
  },
  "IntIterator": {
    "doc": "IntIterator is used for implementing interval iterations.\n\n\tIt is usually not used explicitly, but through its special syntax:\n\t`min...max`\n\n\tWhile it is possible to assign an instance of IntIterator to a variable or\n\tfield, it is worth noting that IntIterator does not reset after being used\n\tin a for-loop. Subsequent uses of the same instance will then have no\n\teffect.\n\n\t@see https://haxe.org/manual/lf-iterators.html",
    "path": "haxe\\std\\IntIterator.hx",
    "functions": {
      "hasNext": "Returns true if the iterator has other items, false otherwise.",
      "next": "Moves to the next item of the iterator.\n\n\t\tIf this is called while hasNext() is false, the result is unspecified."
    },
    "fields": {}
  },
  "Lambda": {
    "doc": "The `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with `using Lambda` and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n\n\t@see https://haxe.org/manual/std-Lambda.html",
    "path": "haxe\\std\\Lambda.hx",
    "functions": {
      "list": "Creates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.",
      "map": "Creates a new Array by applying function `f` to all elements of `it`.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.",
      "mapi": "Similar to map, but also passes the index of each element to `f`.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.",
      "flatten": "Concatenate a list of iterables.\n\t\tThe order of elements is preserved.",
      "flatMap": "A composition of map and flatten.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.",
      "has": "Tells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.",
      "exists": "Tells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.",
      "foreach": "Tells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.",
      "iter": "Calls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.",
      "filter": "Returns a Array containing those elements of `it` for which `f` returned\n\t\ttrue.\n\t\tIf `it` is empty, the result is the empty Array even if `f` is null.\n\t\tOtherwise if `f` is null, the result is unspecified.",
      "fold": "Functional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.",
      "foldi": "Similar to fold, but also passes the index of each element to `f`.\n\n\t\tIf `it` or `f` are null, the result is unspecified.",
      "count": "Returns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.",
      "empty": "Tells if Iterable `it` does not contain any element.",
      "indexOf": "Returns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.",
      "find": "Returns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.",
      "findIndex": "Returns the index of the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is -1.\n\n\t\tIf `f` is null, the result is unspecified.",
      "concat": "Returns a new Array containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified."
    },
    "fields": {}
  },
  "Reflect": {
    "doc": "The Reflect API is a way to manipulate values dynamically through an\n\tabstract interface in an untyped manner. Use with care.\n\n\t@see https://haxe.org/manual/std-reflection.html",
    "path": "haxe\\std\\Reflect.hx",
    "functions": {
      "field": "Returns the value of the field named `field` on object `o`.\n\n\t\tIf `o` is not an object or has no field named `field`, the result is\n\t\tnull.\n\n\t\tIf the field is defined as a property, its accessors are ignored. Refer\n\t\tto `Reflect.getProperty` for a function supporting property accessors.\n\n\t\tIf `field` is null, the result is unspecified.",
      "setField": "Sets the field named `field` of object `o` to value `value`.\n\n\t\tIf `o` has no field named `field`, this function is only guaranteed to\n\t\twork for anonymous structures.\n\n\t\tIf `o` or `field` are null, the result is unspecified.",
      "getProperty": "Returns the value of the field named `field` on object `o`, taking\n\t\tproperty getter functions into account.\n\n\t\tIf the field is not a property, this function behaves like\n\t\t`Reflect.field`, but might be slower.\n\n\t\tIf `o` or `field` are null, the result is unspecified.",
      "setProperty": "Sets the field named `field` of object `o` to value `value`, taking\n\t\tproperty setter functions into account.\n\n\t\tIf the field is not a property, this function behaves like\n\t\t`Reflect.setField`, but might be slower.\n\n\t\tIf `field` is null, the result is unspecified.",
      "callMethod": "Call a method `func` with the given arguments `args`.\n\n\t\tThe object `o` is ignored in most cases. It serves as the `this`-context in the following\n\t\tsituations:\n\n(neko) Allows switching the context to `o` in all cases.\n(macro) Same as neko for Haxe 3. No context switching in Haxe 4.\n(js, lua) Require the `o` argument if `func` does not, but should have a context.\n\t\t\tThis can occur by accessing a function field natively, e.g. through `Reflect.field`\n\t\t\tor by using `(object : Dynamic).field`. However, if `func` has a context, `o` is\n\t\t\tignored like on other targets.",
      "fields": "Returns the fields of structure `o`.\n\n\t\tThis method is only guaranteed to work on anonymous structures. Refer to\n\t\t`Type.getInstanceFields` for a function supporting class instances.\n\n\t\tIf `o` is null, the result is unspecified.",
      "isFunction": "Returns true if `f` is a function, false otherwise.\n\n\t\tIf `f` is null, the result is false.",
      "compare": "Compares `a` and `b`.\n\n\t\tIf `a` is less than `b`, the result is negative. If `b` is less than\n\t\t`a`, the result is positive. If `a` and `b` are equal, the result is 0.\n\n\t\tThis function is only defined if `a` and `b` are of the same type.\n\n\t\tIf that type is a function, the result is unspecified and\n\t\t`Reflect.compareMethods` should be used instead.\n\n\t\tFor all other types, the result is 0 if `a` and `b` are equal. If they\n\t\tare not equal, the result depends on the type and is negative if:\n\n\t\t- Numeric types: a is less than b\n\t\t- String: a is lexicographically less than b\n\t\t- Other: unspecified\n\n\t\tIf `a` and `b` are null, the result is 0. If only one of them is null,\n\t\tthe result is unspecified.",
      "compareMethods": "Compares the functions `f1` and `f2`.\n\n\t\tIf `f1` or `f2` are null, the result is false.\n\t\tIf `f1` or `f2` are not functions, the result is unspecified.\n\n\t\tOtherwise the result is true if `f1` and the `f2` are physically equal,\n\t\tfalse otherwise.\n\n\t\tIf `f1` or `f2` are member method closures, the result is true if they\n\t\tare closures of the same method on the same object value, false otherwise.",
      "isObject": "Tells if `v` is an object.\n\n\t\tThe result is true if `v` is one of the following:\n\n\t\t- class instance\n\t\t- structure\n\t\t- `Class<T>`\n\t\t- `Enum<T>`\n\n\t\tOtherwise, including if `v` is null, the result is false.",
      "isEnumValue": "Tells if `v` is an enum value.\n\n\t\tThe result is true if `v` is of type EnumValue, i.e. an enum\n\t\tconstructor.\n\n\t\tOtherwise, including if `v` is null, the result is false.",
      "deleteField": "Removes the field named `field` from structure `o`.\n\n\t\tThis method is only guaranteed to work on anonymous structures.\n\n\t\tIf `o` or `field` are null, the result is unspecified.",
      "copy": "Copies the fields of structure `o`.\n\n\t\tThis is only guaranteed to work on anonymous structures.\n\n\t\tIf `o` is null, the result is `null`.",
      "makeVarArgs": "Transform a function taking an array of arguments into a function that can\n\t\tbe called with any number of arguments."
    },
    "fields": {}
  },
  "Std": {
    "doc": "The Std class provides standard methods for manipulating basic types.",
    "path": "haxe\\std\\Std.hx",
    "functions": {
      "isOfType": "Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.\n\n\t\tIf `t` is a class or interface with `@:generic` meta, the result is `false`.",
      "downcast": "Checks if object `value` is an instance of class or interface `c`.\n\n\t\tCompiles only if the type specified by `c` can be assigned to the type\n\t\tof `value`.\n\n\t\tThis method checks if a downcast is possible. That is, if the runtime\n\t\ttype of `value` is assignable to the type specified by `c`, `value` is\n\t\treturned. Otherwise null is returned.\n\n\t\tThis method is not guaranteed to work with core types such as `String`,\n\t\t`Array` and `Date`.\n\n\t\tIf `value` is null, the result is null. If `c` is null, the result is\n\t\tunspecified.",
      "string": "Converts any value to a String.\n\n\t\tIf `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.\n\n\t\tIf `s` is an instance of a class and that class or one of its parent classes has\n\t\ta `toString` method, that method is called. If no such method is present, the result\n\t\tis unspecified.\n\n\t\tIf `s` is an enum constructor without argument, the constructor's name is returned. If\n\t\targuments exists, the constructor's name followed by the String representations of\n\t\tthe arguments is returned.\n\n\t\tIf `s` is a structure, the field names along with their values are returned. The field order\n\t\tand the operator separating field names and values are unspecified.\n\n\t\tIf s is null, \"null\" is returned.",
      "int": "Converts a `Float` to an `Int`, rounded towards 0.\n\n\t\tIf `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.",
      "parseInt": "Converts a `String` to an `Int`.\n\n\t\tLeading whitespaces are ignored.\n\n\t\t`x` may optionally start with a + or - to denote a positive or negative value respectively.\n\n\t\tIf the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following\n\t\tdigits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.\n\n\t\tOtherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary\n\t\tnotations are not supported.\n\n\t\tParsing continues until an invalid character is detected, in which case the result up to\n\t\tthat point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.\n\n\t\tIf `x` is `null`, the result is `null`.\n\t\tIf `x` cannot be parsed as integer or is empty, the result is `null`.\n\n\t\tIf `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal\n\t\tdigit, the result is unspecified.",
      "parseFloat": "Converts a `String` to a `Float`.\n\n\t\tThe parsing rules for `parseInt` apply here as well, with the exception of invalid input\n\t\tresulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.\n\n\t\tAdditionally, decimal notation may contain a single `.` to denote the start of the fractions.\n\n\t\tIt may also end with `e` or `E` followed by optional minus or plus sign and a sequence of\n\t\tdigits (defines exponent to base 10).",
      "random": "Return a random integer between 0 included and `x` excluded.\n\n\t\tIf `x <= 1`, the result is always 0."
    },
    "fields": {}
  },
  "ArrayAccess": {
    "doc": "The standard `Void` type. Only `null` values can be of the type `Void`.\n\n\t@see https://haxe.org/manual/types-void.html\n*/\n#if jvm\n@:runtimeValue\n#end\n@:coreType abstract Void {}\n\n/**\n\tThe standard `Float` type, this is a double-precision IEEE 64bit float.\n\n\tOn static targets, `null` cannot be assigned to Float. If this is necessary,\n\t`Null<Float>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseFloat` converts a `String` to a `Float`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0.0)\n@:coreType @:notNull @:runtimeValue abstract Float {}\n\n/**\n\tThe standard `Int` type. Its precision depends on the platform.\n\n\tOn static targets, `null` cannot be assigned to `Int`. If this is necessary,\n\t`Null<Int>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseInt` converts a `String` to an `Int`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/std-math-integer-math.html\n\t@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0)\n@:coreType @:notNull @:runtimeValue abstract Int to Float {}\n\n#if (java || hl || cpp)\n/**\n\tSingle-precision IEEE 32bit float (4-byte).\n*/\n@:coreType @:notNull @:runtimeValue abstract Single to Float from Float {}\n#end\n\n/**\n\t`Null<T>` is a wrapper that can be used to make the basic types `Int`,\n\t`Float` and `Bool` nullable on static targets.\n\n\tIf null safety is enabled, only types wrapped in `Null<T>` are nullable.\n\n\tOtherwise, it has no effect on non-basic-types, but it can be useful as a way to document\n\tthat `null` is an acceptable value for a method argument, return value or variable.\n\n\t@see https://haxe.org/manual/types-nullability.html\n*/\n@:forward\n@:coreType\nabstract Null<T> from T to T {}\n\n/**\n\tThe standard Boolean type, which can either be `true` or `false`.\n\n\tOn static targets, `null` cannot be assigned to `Bool`. If this is necessary,\n\t`Null<Bool>` can be used instead.\n\n\t@see https://haxe.org/manual/types-bool.html\n\t@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(false)\n@:coreType @:notNull @:runtimeValue abstract Bool {}\n\n/**\n\t`Dynamic` is a special type which is compatible with all other types.\n\n\tUse of `Dynamic` should be minimized as it prevents several compiler\n\tchecks and optimizations. See `Any` type for a safer alternative for\n\trepresenting values of any type.\n\n\t@see https://haxe.org/manual/types-dynamic.html\n*/\n@:coreType @:runtimeValue abstract Dynamic<T> {}\n\n/**\n\tAn `Iterator` is a structure that permits iteration over elements of type `T`.\n\n\tAny class with matching `hasNext()` and `next()` fields is considered an `Iterator`\n\tand can then be used e.g. in `for`-loops. This makes it easy to implement\n\tcustom iterators.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterator<T> = {\n\t/**\n\t\tReturns `false` if the iteration is complete, `true` otherwise.\n\n\t\tUsually iteration is considered to be complete if all elements of the\n\t\tunderlying data structure were handled through calls to `next()`. However,\n\t\tin custom iterators any logic may be used to determine the completion\n\t\tstate.\n*/\n\tfunction hasNext():Bool;\n\n\t/**\n\t\tReturns the current item of the `Iterator` and advances to the next one.\n\n\t\tThis method is not required to check `hasNext()` first. A call to this\n\t\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\t\tOn the other hand, iterators should not require a call to `hasNext()`\n\t\tbefore the first call to `next()` if an element is available.\n*/\n\tfunction next():T;\n}\n\n/**\n\tAn `Iterable` is a data structure which has an `iterator()` method.\n\tSee `Lambda` for generic functions on iterable structures.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterable<T> = {\n\tfunction iterator():Iterator<T>;\n}\n\n/**\n\tA `KeyValueIterator` is an `Iterator` that has a key and a value.\n*/\ntypedef KeyValueIterator<K, V> = Iterator<{key:K, value:V}>;\n\n/**\n\tA `KeyValueIterable` is a data structure which has a `keyValueIterator()`\n\tmethod to iterate over key-value-pairs.\n*/\ntypedef KeyValueIterable<K, V> = {\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n}\n\n/**\n\t`ArrayAccess` is used to indicate a class that can be accessed using brackets.\n\tThe type parameter represents the type of the elements stored.\n\n\tThis interface should be used for externs only. Haxe does not support custom\n\tarray access on classes. However, array access can be implemented for\n\tabstract types.\n\n\t@see https://haxe.org/manual/types-abstract-array-access.html",
    "path": "haxe\\std\\StdTypes.hx",
    "functions": {
      "next": "Returns the current item of the `Iterator` and advances to the next one.\n\n\t\tThis method is not required to check `hasNext()` first. A call to this\n\t\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\t\tOn the other hand, iterators should not require a call to `hasNext()`\n\t\tbefore the first call to `next()` if an element is available."
    },
    "fields": {}
  },
  "String": {
    "doc": "The basic String class.\n\n\tA Haxe String is immutable, it is not possible to modify individual\n\tcharacters. No method of this class changes the state of `this` String.\n\n\tStrings can be constructed using the String literal syntax `\"string value\"`.\n\n\tString can be concatenated by using the `+` operator. If an operand is not a\n\tString, it is passed through `Std.string()` first.\n\n\t@see https://haxe.org/manual/std-String.html",
    "path": "haxe\\std\\String.hx",
    "functions": {
      "toUpperCase": "Returns a String where all characters of `this` String are upper case.",
      "toLowerCase": "Returns a String where all characters of `this` String are lower case.",
      "charAt": "Returns the character at position `index` of `this` String.\n\n\t\tIf `index` is negative or exceeds `this.length`, the empty String `\"\"`\n\t\tis returned.",
      "charCodeAt": "Returns the character code at position `index` of `this` String.\n\n\t\tIf `index` is negative or exceeds `this.length`, `null` is returned.\n\n\t\tTo obtain the character code of a single character, `\"x\".code` can be\n\t\tused instead to inline the character code at compile time. Note that\n\t\tthis only works on String literals of length 1.",
      "indexOf": "Returns the position of the leftmost occurrence of `str` within `this` String.\n\n\t\tIf `str` is the empty String `\"\"`, then:\nIf `startIndex` is not specified or < 0, 0 is returned.\nIf `startIndex >= this.length`, `this.length` is returned.\nOtherwise, `startIndex` is returned,\n\n\t\tOtherwise, if `startIndex` is not specified or < 0, it is treated as 0.\n\n\t\tIf `startIndex >= this.length`, -1 is returned.\n\n\t\tOtherwise the search is performed within the substring of `this` String starting\n\t\tat `startIndex`. If `str` is found, the position of its first character in `this`\n\t\tString relative to position 0 is returned.\n\n\t\tIf `str` cannot be found, -1 is returned.",
      "lastIndexOf": "Returns the position of the rightmost occurrence of `str` within `this`\n\t\tString.\n\n\t\tIf `startIndex` is given, the search is performed within the substring\n\t\tof `this` String from 0 to `startIndex + str.length`. Otherwise the search\n\t\tis performed within `this` String. In either case, the returned position\n\t\tis relative to the beginning of `this` String.\n\n\t\tIf `startIndex` is negative, the result is unspecified.\n\n\t\tIf `str` cannot be found, -1 is returned.",
      "split": "Splits `this` String at each occurrence of `delimiter`.\n\n\t\tIf `this` String is the empty String `\"\"`, the result is not consistent\n\t\tacross targets and may either be `[]` (on Js, Cpp) or `[\"\"]`.\n\n\t\tIf `delimiter` is the empty String `\"\"`, `this` String is split into an\n\t\tArray of `this.length` elements, where the elements correspond to the\n\t\tcharacters of `this` String.\n\n\t\tIf `delimiter` is not found within `this` String, the result is an Array\n\t\twith one element, which equals `this` String.\n\n\t\tIf `delimiter` is null, the result is unspecified.\n\n\t\tOtherwise, `this` String is split into parts at each occurrence of\n\t\t`delimiter`. If `this` String starts (or ends) with `delimiter`, the\n\t\tresult `Array` contains a leading (or trailing) empty String `\"\"` element.\n\t\tTwo subsequent delimiters also result in an empty String `\"\"` element.",
      "substr": "Returns `len` characters of `this` String, starting at position `pos`.\n\n\t\tIf `len` is omitted, all characters from position `pos` to the end of\n\t\t`this` String are included.\n\n\t\tIf `pos` is negative, its value is calculated from the end of `this`\n\t\tString by `this.length + pos`. If this yields a negative value, 0 is\n\t\tused instead.\n\n\t\tIf the calculated position + `len` exceeds `this.length`, the characters\n\t\tfrom that position to the end of `this` String are returned.\n\n\t\tIf `len` is negative, the result is unspecified.",
      "substring": "Returns the part of `this` String from `startIndex` to but not including `endIndex`.\n\n\t\tIf `startIndex` or `endIndex` are negative, 0 is used instead.\n\n\t\tIf `startIndex` exceeds `endIndex`, they are swapped.\n\n\t\tIf the (possibly swapped) `endIndex` is omitted or exceeds\n\t\t`this.length`, `this.length` is used instead.\n\n\t\tIf the (possibly swapped) `startIndex` exceeds `this.length`, the empty\n\t\tString `\"\"` is returned.",
      "toString": "Returns the String itself."
    },
    "fields": {}
  },
  "StringBuf": {
    "doc": "A String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues.",
    "path": "haxe\\std\\StringBuf.hx",
    "functions": {
      "add": "Appends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.",
      "addChar": "Appends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.",
      "addSub": "Appends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.",
      "clear": "Removes all characters from `this` StringBuf, making it possible to reuse it.",
      "toString": "Returns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation."
    },
    "fields": {}
  },
  "StringTools": {
    "doc": "This class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.",
    "path": "haxe\\std\\StringTools.hx",
    "functions": {
      "htmlUnescape": "Unescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`",
      "contains": "Returns `true` if `s` contains `value` and  `false` otherwise.\n\n\t\tWhen `value` is `null`, the result is unspecified.",
      "isSpace": "Tells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n*/\n\tpublic static #if (java || python || (js && js_es >= 6)) inline #end function startsWith(s:String, start:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).startsWith(start);\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.startswith(s, start);\n\t\t#elseif (js && js_es >= 6)\n\t\treturn (cast s).startsWith(start);\n\t\t#elseif lua\n\t\treturn untyped __lua__(\"{0}:sub(1, #{1}) == {1}\", s, start);\n\t\t#else\n\t\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n*/\n\tpublic static #if (java || python || (js && js_es >= 6)) inline #end function endsWith(s:String, end:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).endsWith(end);\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.endswith(s, end);\n\t\t#elseif (js && js_es >= 6)\n\t\treturn (cast s).endsWith(end);\n\t\t#elseif lua\n\t\treturn end == \"\" || untyped __lua__(\"{0}:sub(-#{1}) == {1}\", s, end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.",
      "ltrim": "Removes leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.",
      "rtrim": "Removes trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.",
      "lpad": "Removes leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n*/\n\tpublic #if java inline #end static function trim(s:String):String {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.",
      "rpad": "Appends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.",
      "replace": "Replace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\t\tremains unchanged.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.",
      "hex": "Encodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.",
      "iterator": "Returns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n*/\n\tpublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif js\n\t\treturn js.lib.NativeStringTools.charCodeAt(s, index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n*/\n\tpublic static #if !eval inline #end function unsafeCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn cast(_charAt(s, index), Int);\n\t\t#elseif js\n\t\treturn js.lib.NativeStringTools.charCodeAt(s, index);\n\t\t#elseif python\n\t\treturn python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an iterator of the char codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.",
      "keyValueIterator": "Returns an iterator of the char indexes and codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different of runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.",
      "quoteUnixArg": "Tells if `c` represents the end-of-file (EOF) character.\n*/\n\t@:noUsing public static inline function isEof(c:Int):Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua || eval)\n\t\treturn c == null;\n\t\t#elseif (java || python)\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.",
      "quoteWinArg": "Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n*/\n\t@:noCompletion\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```haxe\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```"
    },
    "fields": {}
  },
  "Type": {
    "doc": "The Haxe Reflection API allows retrieval of type information at runtime.\n\n\tThis class complements the more lightweight Reflect class, with a focus on\n\tclass and enum instances.\n\n\t@see https://haxe.org/manual/types.html\n\t@see https://haxe.org/manual/std-reflection.html",
    "path": "haxe\\std\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "ValueType": {
    "doc": "Returns the class of `o`, if `o` is a class instance.\n\n\t\tIf `o` is null or of a different type, null is returned.\n\n\t\tIn general, type parameter information cannot be obtained at runtime.\n*/\n\tstatic function getClass<T>(o:T):Null<Class<T>>;\n\n\t/**\n\t\tReturns the enum of enum instance `o`.\n\n\t\tAn enum instance is the result of using an enum constructor. Given an\n\t\t`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\n\t\tIf `o` is null, null is returned.\n\n\t\tIn general, type parameter information cannot be obtained at runtime.\n*/\n\tstatic function getEnum(o:EnumValue):Null<Enum<Dynamic>>;\n\n\t/**\n\t\tReturns the super-class of class `c`.\n\n\t\tIf `c` has no super class, null is returned.\n\n\t\tIf `c` is null, the result is unspecified.\n\n\t\tIn general, type parameter information cannot be obtained at runtime.\n*/\n\tstatic function getSuperClass(c:Class<Dynamic>):Null<Class<Dynamic>>;\n\n\t/**\n\t\tReturns the name of class `c`, including its path.\n\n\t\tIf `c` is inside a package, the package structure is returned dot-\n\t\tseparated, with another dot separating the class name:\n\t\t`pack1.pack2.(...).packN.ClassName`\n\t\tIf `c` is a sub-type of a Haxe module, that module is not part of the\n\t\tpackage structure.\n\n\t\tIf `c` has no package, the class name is returned.\n\n\t\tIf `c` is null, the result is unspecified.\n\n\t\tThe class name does not include any type parameters.\n*/\n\tstatic function getClassName(c:Class<Dynamic>):String;\n\n\t/**\n\t\tReturns the name of enum `e`, including its path.\n\n\t\tIf `e` is inside a package, the package structure is returned dot-\n\t\tseparated, with another dot separating the enum name:\n\t\t`pack1.pack2.(...).packN.EnumName`\n\t\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\t\tpackage structure.\n\n\t\tIf `e` has no package, the enum name is returned.\n\n\t\tIf `e` is null, the result is unspecified.\n\n\t\tThe enum name does not include any type parameters.\n*/\n\tstatic function getEnumName(e:Enum<Dynamic>):String;\n\n\t/**\n\t\tResolves a class by name.\n\n\t\tIf `name` is the path of an existing class, that class is returned.\n\n\t\tOtherwise null is returned.\n\n\t\tIf `name` is null or the path to a different type, the result is\n\t\tunspecified.\n\n\t\tThe class name must not include any type parameters.\n*/\n\tstatic function resolveClass(name:String):Null<Class<Dynamic>>;\n\n\t/**\n\t\tResolves an enum by name.\n\n\t\tIf `name` is the path of an existing enum, that enum is returned.\n\n\t\tOtherwise null is returned.\n\n\t\tIf `name` is null the result is unspecified.\n\n\t\tIf `name` is the path to a different type, null is returned.\n\n\t\tThe enum name must not include any type parameters.\n*/\n\tstatic function resolveEnum(name:String):Null<Enum<Dynamic>>;\n\n\t/**\n\t\tCreates an instance of class `cl`, using `args` as arguments to the\n\t\tclass constructor.\n\n\t\tThis function guarantees that the class constructor is called.\n\n\t\tDefault values of constructors arguments are not guaranteed to be\n\t\ttaken into account.\n\n\t\tIf `cl` or `args` are null, or if the number of elements in `args` does\n\t\tnot match the expected number of constructor arguments, or if any\n\t\targument has an invalid type,  or if `cl` has no own constructor, the\n\t\tresult is unspecified.\n\n\t\tIn particular, default values of constructor arguments are not\n\t\tguaranteed to be taken into account.\n*/\n\tstatic function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T;\n\n\t/**\n\t\tCreates an instance of class `cl`.\n\n\t\tThis function guarantees that the class constructor is not called.\n\n\t\tIf `cl` is null, the result is unspecified.\n*/\n\tstatic function createEmptyInstance<T>(cl:Class<T>):T;\n\n\t/**\n\t\tCreates an instance of enum `e` by calling its constructor `constr` with\n\t\targuments `params`.\n\n\t\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.\n*/\n\tstatic function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T;\n\n\t/**\n\t\tCreates an instance of enum `e` by calling its constructor number\n\t\t`index` with arguments `params`.\n\n\t\tThe constructor indices are preserved from Haxe syntax, so the first\n\t\tdeclared is index 0, the next index 1 etc.\n\n\t\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.\n*/\n\tstatic function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T;\n\n\t/**\n\t\tReturns a list of the instance fields of class `c`, including\n\t\tinherited fields.\n\n\t\tThis only includes fields which are known at compile-time. In\n\t\tparticular, using `getInstanceFields(getClass(obj))` will not include\n\t\tany fields which were added to `obj` at runtime.\n\n\t\tThe order of the fields in the returned Array is unspecified.\n\n\t\tIf `c` is null, the result is unspecified.\n*/\n\tstatic function getInstanceFields(c:Class<Dynamic>):Array<String>;\n\n\t/**\n\t\tReturns a list of static fields of class `c`.\n\n\t\tThis does not include static fields of parent classes.\n\n\t\tThe order of the fields in the returned Array is unspecified.\n\n\t\tIf `c` is null, the result is unspecified.\n*/\n\tstatic function getClassFields(c:Class<Dynamic>):Array<String>;\n\n\t/**\n\t\tReturns a list of the names of all constructors of enum `e`.\n\n\t\tThe order of the constructor names in the returned Array is preserved\n\t\tfrom the original syntax.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic function getEnumConstructs(e:Enum<Dynamic>):Array<String>;\n\n\t/**\n\t\tReturns the runtime type of value `v`.\n\n\t\tThe result corresponds to the type `v` has at runtime, which may vary\n\t\tper platform. Assumptions regarding this should be minimized to avoid\n\t\tsurprises.\n*/\n\tstatic function typeof(v:Dynamic):ValueType;\n\n\t/**\n\t\tRecursively compares two enum instances `a` and `b` by value.\n\n\t\tUnlike `a == b`, this function performs a deep equality check on the\n\t\targuments of the constructors, if exists.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n*/\n\tstatic function enumEq<T:EnumValue>(a:T, b:T):Bool;\n\n\t/**\n\t\tReturns the constructor name of enum instance `e`.\n\n\t\tThe result String does not contain any constructor arguments.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic function enumConstructor(e:EnumValue):String;\n\n\t/**\n\t\tReturns a list of the constructor arguments of enum instance `e`.\n\n\t\tIf `e` has no arguments, the result is [].\n\n\t\tOtherwise the result are the values that were used as arguments to `e`,\n\t\tin the order of their declaration.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic function enumParameters(e:EnumValue):Array<Dynamic>;\n\n\t/**\n\t\tReturns the index of enum instance `e`.\n\n\t\tThis corresponds to the original syntactic position of `e`. The index of\n\t\tthe first declared constructor is 0, the next one is 1 etc.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic function enumIndex(e:EnumValue):Int;\n\n\t/**\n\t\tReturns a list of all constructors of enum `e` that require no\n\t\targuments.\n\n\t\tThis may return the empty Array `[]` if all constructors of `e` require\n\t\targuments.\n\n\t\tOtherwise an instance of `e` constructed through each of its non-\n\t\targument constructors is returned, in the order of the constructor\n\t\tdeclaration.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic function allEnums<T>(e:Enum<T>):Array<T>;\n}\n\n/**\n\tThe different possible runtime types of a value.",
    "path": "haxe\\std\\Type.hx",
    "functions": {
      "getEnum": "Returns the enum of enum instance `o`.\n\n\t\tAn enum instance is the result of using an enum constructor. Given an\n\t\t`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\n\t\tIf `o` is null, null is returned.\n\n\t\tIn general, type parameter information cannot be obtained at runtime.",
      "getSuperClass": "Returns the super-class of class `c`.\n\n\t\tIf `c` has no super class, null is returned.\n\n\t\tIf `c` is null, the result is unspecified.\n\n\t\tIn general, type parameter information cannot be obtained at runtime.",
      "getClassName": "Returns the name of class `c`, including its path.\n\n\t\tIf `c` is inside a package, the package structure is returned dot-\n\t\tseparated, with another dot separating the class name:\n\t\t`pack1.pack2.(...).packN.ClassName`\n\t\tIf `c` is a sub-type of a Haxe module, that module is not part of the\n\t\tpackage structure.\n\n\t\tIf `c` has no package, the class name is returned.\n\n\t\tIf `c` is null, the result is unspecified.\n\n\t\tThe class name does not include any type parameters.",
      "getEnumName": "Returns the name of enum `e`, including its path.\n\n\t\tIf `e` is inside a package, the package structure is returned dot-\n\t\tseparated, with another dot separating the enum name:\n\t\t`pack1.pack2.(...).packN.EnumName`\n\t\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\t\tpackage structure.\n\n\t\tIf `e` has no package, the enum name is returned.\n\n\t\tIf `e` is null, the result is unspecified.\n\n\t\tThe enum name does not include any type parameters.",
      "resolveClass": "Resolves a class by name.\n\n\t\tIf `name` is the path of an existing class, that class is returned.\n\n\t\tOtherwise null is returned.\n\n\t\tIf `name` is null or the path to a different type, the result is\n\t\tunspecified.\n\n\t\tThe class name must not include any type parameters.",
      "resolveEnum": "Resolves an enum by name.\n\n\t\tIf `name` is the path of an existing enum, that enum is returned.\n\n\t\tOtherwise null is returned.\n\n\t\tIf `name` is null the result is unspecified.\n\n\t\tIf `name` is the path to a different type, null is returned.\n\n\t\tThe enum name must not include any type parameters.",
      "createInstance": "Creates an instance of class `cl`, using `args` as arguments to the\n\t\tclass constructor.\n\n\t\tThis function guarantees that the class constructor is called.\n\n\t\tDefault values of constructors arguments are not guaranteed to be\n\t\ttaken into account.\n\n\t\tIf `cl` or `args` are null, or if the number of elements in `args` does\n\t\tnot match the expected number of constructor arguments, or if any\n\t\targument has an invalid type,  or if `cl` has no own constructor, the\n\t\tresult is unspecified.\n\n\t\tIn particular, default values of constructor arguments are not\n\t\tguaranteed to be taken into account.",
      "createEmptyInstance": "Creates an instance of class `cl`.\n\n\t\tThis function guarantees that the class constructor is not called.\n\n\t\tIf `cl` is null, the result is unspecified.",
      "createEnum": "Creates an instance of enum `e` by calling its constructor `constr` with\n\t\targuments `params`.\n\n\t\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.",
      "createEnumIndex": "Creates an instance of enum `e` by calling its constructor number\n\t\t`index` with arguments `params`.\n\n\t\tThe constructor indices are preserved from Haxe syntax, so the first\n\t\tdeclared is index 0, the next index 1 etc.\n\n\t\tIf `e` or `constr` is null, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.",
      "getInstanceFields": "Returns a list of the instance fields of class `c`, including\n\t\tinherited fields.\n\n\t\tThis only includes fields which are known at compile-time. In\n\t\tparticular, using `getInstanceFields(getClass(obj))` will not include\n\t\tany fields which were added to `obj` at runtime.\n\n\t\tThe order of the fields in the returned Array is unspecified.\n\n\t\tIf `c` is null, the result is unspecified.",
      "getClassFields": "Returns a list of static fields of class `c`.\n\n\t\tThis does not include static fields of parent classes.\n\n\t\tThe order of the fields in the returned Array is unspecified.\n\n\t\tIf `c` is null, the result is unspecified.",
      "getEnumConstructs": "Returns a list of the names of all constructors of enum `e`.\n\n\t\tThe order of the constructor names in the returned Array is preserved\n\t\tfrom the original syntax.\n\n\t\tIf `e` is null, the result is unspecified.",
      "typeof": "Returns the runtime type of value `v`.\n\n\t\tThe result corresponds to the type `v` has at runtime, which may vary\n\t\tper platform. Assumptions regarding this should be minimized to avoid\n\t\tsurprises.",
      "enumEq": "Recursively compares two enum instances `a` and `b` by value.\n\n\t\tUnlike `a == b`, this function performs a deep equality check on the\n\t\targuments of the constructors, if exists.\n\n\t\tIf `a` or `b` are null, the result is unspecified.",
      "enumConstructor": "Returns the constructor name of enum instance `e`.\n\n\t\tThe result String does not contain any constructor arguments.\n\n\t\tIf `e` is null, the result is unspecified.",
      "enumParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\n\t\tIf `e` has no arguments, the result is [].\n\n\t\tOtherwise the result are the values that were used as arguments to `e`,\n\t\tin the order of their declaration.\n\n\t\tIf `e` is null, the result is unspecified.",
      "enumIndex": "Returns the index of enum instance `e`.\n\n\t\tThis corresponds to the original syntactic position of `e`. The index of\n\t\tthe first declared constructor is 0, the next one is 1 etc.\n\n\t\tIf `e` is null, the result is unspecified.",
      "allEnums": "Returns a list of all constructors of enum `e` that require no\n\t\targuments.\n\n\t\tThis may return the empty Array `[]` if all constructors of `e` require\n\t\targuments.\n\n\t\tOtherwise an instance of `e` constructed through each of its non-\n\t\targument constructors is returned, in the order of the constructor\n\t\tdeclaration.\n\n\t\tIf `e` is null, the result is unspecified."
    },
    "fields": {}
  },
  "abstract": {
    "doc": "Xml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html",
    "path": "haxe\\std\\Xml.hx",
    "functions": {},
    "fields": {}
  },
  "Xml": {
    "doc": "Represents an XML element type.\n*/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n*/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n*/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n*/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n*/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n*/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n*/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html",
    "path": "haxe\\std\\Xml.hx",
    "functions": {
      "createElement": "Returns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n*/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n*/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n*/\n\tpublic var parent(default, null):Null<Xml>;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.",
      "createPCData": "Creates a node of the given type.",
      "createCData": "Creates a node of the given type.",
      "createComment": "Creates a node of the given type.",
      "createDocType": "Creates a node of the given type.",
      "createProcessingInstruction": "Creates a node of the given type.",
      "createDocument": "Creates a node of the given type.",
      "get": "Get the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.",
      "set": "Set the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.",
      "remove": "Removes an attribute for an Element node.\n\t\tAttributes are case-sensitive.",
      "exists": "Tells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.",
      "attributes": "Returns an `Iterator` on all the attribute names.",
      "elements": "Returns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n*/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.",
      "elementsNamed": "Returns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.",
      "firstElement": "Returns the first child node.\n*/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.",
      "addChild": "Adds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.",
      "removeChild": "Removes a child from the Document or Element.\n\t\tReturns true if the child was successfully removed.",
      "insertChild": "Inserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element."
    },
    "fields": {
      "PCData": "XML parsed character data type.",
      "CData": "XML character data type.",
      "Comment": "XML comment type.",
      "DocType": "XML doctype element type.",
      "ProcessingInstruction": "XML processing instruction type.",
      "Document": "XML document type.",
      "Element": "Cross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n*/\nclass Xml {\n\t/**\n\t\tXML element type.",
      "nodeType": "Parses the String into an Xml document.\n*/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.",
      "parent": "Returns the node name of an Element.\n*/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document."
    }
  },
  "cpp.Finalizable": {
    "doc": "This is just a helper class. It is not actually required to inherit from this\n\tto use `NativeGc.addFinalizable(this,inPin)`, only a function called\n\t`finalize` is needed.",
    "path": "haxe\\std\\cpp\\Finalizable.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.Lib": {
    "doc": "Platform-specific Cpp Library. Provides some platform-specific functions\n\tfor the C++ target, such as conversion from Haxe types to native types\n\tand vice-versa.",
    "path": "haxe\\std\\cpp\\Lib.hx",
    "functions": {
      "unloadAllLibraries": "Unloaded all dynamic libraries in reverse order of loading.\n\t\tReturns the number of libraries unloaded.",
      "loadLazy": "Tries to load, and always returns a valid function, but the function may throw\n\t\tif called.",
      "bytesReference": "Returns bytes referencing the content of a string.\n\t\tUse with extreme caution - changing constant strings will crash.\n\t\tChanging one string can cause others to change unexpectedly.\n\t\tOnly really safe if you are using it read-only or if it comes from stringReference above",
      "print": "Print the specified value on the default output.",
      "haxeToNeko": "This function is used to make porting from neko to cpp easy.\n\t\tIt does not need to do anything because the c-code can work with any Dynamic",
      "nekoToHaxe": "This function is used to make porting from neko to cpp easy.\n\t\tIt does not need to do anything because the c-code can work with any Dynamic",
      "println": "Print the specified value on the default output followed by a newline character."
    },
    "fields": {}
  },
  "cpp.net.Poll": {
    "doc": "A wrapper around native socket polling functionality for monitoring multiple sockets for I/O readiness.\nThis class provides a high-level abstraction over native `poll` operations, allowing you to monitor sockets for read and write events.",
    "path": "haxe\\std\\cpp\\net\\Poll.hx",
    "functions": {
      "prepare": "Prepares the poll structure for monitoring read and write events on the given sockets.\n\n@param read  An array of sockets to monitor for readability.\n@param write An array of sockets to monitor for writability.",
      "events": "Waits for events on the prepared sockets.\n\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.",
      "poll": "Polls the given sockets for any events (e.g., readability or writability).\n\n@param a An array of sockets to monitor for events.\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.\n@return An array of sockets that are ready for I/O operations."
    },
    "fields": {
      "writeIndexes": "An array of indices corresponding to sockets ready for writing after polling."
    }
  },
  "cpp.net.ThreadServer": {
    "doc": "The ThreadServer can be used to easily create a multithreaded server where each thread polls multiple connections.\n\tTo use it, at a minimum you must override or rebind clientConnected, readClientMessage, and clientMessage and you must define your Client and Message.",
    "path": "haxe\\std\\cpp\\net\\ThreadServer.hx",
    "functions": {
      "work": "Internally used to delegate something to the worker thread.",
      "addSocket": "Called when the server gets a new connection.",
      "run": "Start the server at the specified host and port.",
      "sendData": "Send data to a client.",
      "stopClient": "Shutdown a client's connection and remove them from the server."
    },
    "fields": {
      "nthreads": "Number of server threads.",
      "connectLag": "Polling timeout.",
      "errorOutput": "Stream to send error messages.",
      "initialBufferSize": "Space allocated to buffers when they are created.",
      "maxBufferSize": "Maximum size of buffered data read from a socket. An exception is thrown if the buffer exceeds this value.",
      "messageHeaderSize": "Minimum message size.",
      "updateTime": "Time between calls to update.",
      "maxSockPerThread": "The most sockets a thread will handle."
    }
  },
  "cpp.rtti.FieldIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\n\tallows fast dynamic access to fields by integer id.  This should speed up the CFFI.",
    "path": "haxe\\std\\cpp\\rtti\\FieldIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.rtti.FieldNumericIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\n\tallows fast numeric access to fields by integer id.  This should speed up the CFFI.",
    "path": "haxe\\std\\cpp\\rtti\\FieldNumericIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Parameter": {
    "doc": "Parameter describes a function parameter. Instances of this class are\n\tembedded in stack frame objects to describe the function parameters that\n\twere used in the invocation of the function that defines that stack frame.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.StackFrame": {
    "doc": "`StackFrame` describes one call stack frame.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.ThreadInfo": {
    "doc": "`ThreadInfo` describes the state of a single thread.",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Debugger": {
    "doc": "0 is never a valid thread number **/\n\tpublic var number(default, null):Int;\n\n\tpublic var status(default, null):Int;\n\n\t/** If status is \"stopped breakpoint\", this is the breakpoint number **/\n\tpublic var breakpoint(default, null):Int;\n\n\t/** If status is \"critical error\", this describes the error **/\n\tpublic var criticalErrorDescription(default, null):String;\n\n\t/** Stack will be listed with the lowest frame first **/\n\tpublic var stack(default, null):Array<StackFrame>;\n\n\tpublic function new(number:Int, status:Int, breakpoint:Int = -1, criticalErrorDescription:String = null) {\n\t\tthis.number = number;\n\t\tthis.status = status;\n\t\tthis.breakpoint = breakpoint;\n\t\tthis.criticalErrorDescription = criticalErrorDescription;\n\t\tthis.stack = new Array<StackFrame>();\n\t}\n}\n\n/**\n\tThis class wraps the hxcpp C++ implementation to provide a Haxe interface\n\tto the low level debugging features",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {
      "enableCurrentThreadDebugging": "This can be called to turn off (and then back on) all stopping of\n\t\tdebugged threads temporarily. It should only be used by classes that\n\t\tactually implement the debugger to hide themselves from the debugger as\n\t\tnecessary.",
      "getCurrentThreadNumber": "Returns the thread number of the calling thread.\n\n\t\t@return the thread number of the calling thread.",
      "getFiles": "Returns the set of source files known to the debugger. This is a copy\n\t\tof the original array and could be quite large. The caller should\n\t\tcache this value to avoid multiple copies needing to be made.\n\n\t\t@return the set of source files known to the debugger.",
      "getFilesFullPath": "Returns the full paths of the set of source files known to the debugger.\n\t\tThis is a copy of the original array and could be quite large.\n\t\tIt is possible that this set will be empty, in which case the full paths are not known.\n\t\tThe index of these files matches the index from `getFiles()`, so the full path for\n\t\ta given short path can be calculated.\n\n\t\t@return the known full paths of the set of source files",
      "getClasses": "Returns the set of class names of all classes known to the debugger.\n\t\tThis is a copy of the original array and could be quite large. The\n\t\tcaller should cache this value to avoid multiple copies needing to be\n\t\tmade.\n\n\t\t@return the set of class names of all classes known to the debugger.",
      "getThreadInfos": "Returns a `ThreadInfo` object describing every thread that existed at the\n\t\tmoment that the call was made, except for the debugger thread.",
      "getThreadInfo": "Returns a `ThreadInfo` object describing a single thread, or `null` if\n\t\tthere is no such thread or the thread queried about was the debugger\n\t\tthread and `unsafe` was not `true`.",
      "addFileLineBreakpoint": "Adds a new `file:line` breakpoint. The breakpoint number of the newly\n\t\tadded breakpoint is returned.",
      "addClassFunctionBreakpoint": "Adds a new `class:function` breakpoint. The breakpoint number of the\n\t\tnewly added breakpoint is returned.",
      "deleteBreakpoint": "Deletes a breakpoint, or all breakpoints.",
      "breakNow": "Breaks all threads except the debugger thread (which should be the same\n\t\tas the calling thread!).\n\n\t\tIf `wait` is `true`, waits up to 2 seconds for all threads to be broken.\n\t\tThreads which are in blocking system calls and cannot break after 2\n\t\tseconds remain running when this function returns.",
      "continueThreads": "Continue execution of all stopped threads. If `specialThreadNumber`\n\t\tis a valid thread number, then it will be continued past\n\t\t`continueCount` breakpoints instead of just 1 like all of the other\n\t\tthreads.",
      "stepThread": "Single steps the given thread.",
      "getStackVariables": "Returns the list of local variables (including `this`, function\n\t\targuments, and local variables) visible to the given thread at the\n\t\tgiven stack frame.\n\n\t\tReturns a list with a single entry, `THREAD_NOT_STOPPED`, if the\n\t\tthread is not stopped and thus variables cannot be fetched and\n\t\t`unsafe` is not `true`.\n\n\t\t@return the list of local variables (including `this`, function\n\t\t\t\targuments, and local variables) visible to the given thread at\n\t\t\t\tthe given stack frame.",
      "getStackVariableValue": "Returns the value of a stack variable, or `NONEXISTENT_VALUE` if the\n\t\trequested value does not exist.  If the thread is actively running\n\t\tand `unsafe` is not `true`, returns `THREAD_NOT_STOPPED`.",
      "setStackVariableValue": "Sets the value of a stack variable and returns that value. If the\n\t\tvariable does not exist, on the stack, this function returns\n\t\t`NONEXISTENT_VALUE`. If the thread is actively running and `unsafe` is not\n\t\t`true`, returns `THREAD_NOT_STOPPED`, and the value is not set.",
      "setOnScriptLoadedFunction": "Sets the callback to run whenever a new CPPIA script is loaded.\n\n\t\tThis can be helpful for adding breakpoints to a script."
    },
    "fields": {
      "breakpoint": "If status is \"stopped breakpoint\", this is the breakpoint number *",
      "criticalErrorDescription": "If status is \"critical error\", this describes the error *",
      "stack": "Stack will be listed with the lowest frame first *",
      "NONEXISTENT_VALUE": "This class wraps the hxcpp C++ implementation to provide a Haxe interface\n\tto the low level debugging features\n*/\nclass Debugger {\n\tpublic static inline var THREAD_CREATED = 1;\n\tpublic static inline var THREAD_TERMINATED = 2;\n\tpublic static inline var THREAD_STARTED = 3;\n\tpublic static inline var THREAD_STOPPED = 4;\n\n\tpublic static inline var STEP_INTO = 1;\n\tpublic static inline var STEP_OVER = 2;\n\tpublic static inline var STEP_OUT = 3;\n\n\t/**\n\t\tThis tagging value is returned by `getStackVariableValue()` and\n\t\t`setStackVariableValue()` if the requested value does not exist at the\n\t\trequested stack frame",
      "THREAD_NOT_STOPPED": "This tagging value is returned by `getStackVariableValue()` and\n\t\t`setStackVariableValue()` if the stack variable that is being set is on a\n\t\tthread that is running, in which case the set does not take place."
    }
  },
  "eval.luv.DirSync": {
    "doc": "Retrieves the next directory entry.\n*/\n\tfunction next():Null<Dirent>;\n\n\t/**\n\t\tCleans up after a directory scan.\n*/\n\tfunction end():Void;\n}\n\n/**\n\t@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n\t/**\n\t\tOpens the directory at the given path for listing.\n*/\n\tstatic public function open(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Dir>)->Void):Void;\n\n\t/**\n\t\tCloses the directory.\n*/\n\tpublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tRetrieves a directory entry.\n*/\n\tpublic function read(loop:Loop, ?numberOfEntries:Int, ?request:FileRequest, callback:(result:Result<Array<Dirent>>)->Void):Void;\n\n\t/**\n\t\tBegins directory listing.\n*/\n\tstatic public function scan(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<DirectoryScan>)->Void):Void;\n}\n\n/**\n\tSynchronous version of `eval.luv.Dir` API",
    "path": "haxe\\std\\eval\\luv\\Dir.hx",
    "functions": {
      "end": "Cleans up after a directory scan.",
      "open": "@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n\t/**\n\t\tOpens the directory at the given path for listing.",
      "close": "Closes the directory.",
      "read": "Retrieves a directory entry.",
      "scan": "Begins directory listing."
    },
    "fields": {}
  },
  "eval.luv.Dns": {
    "doc": "DNS queries.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Dns",
    "path": "haxe\\std\\eval\\luv\\Dns.hx",
    "functions": {
      "getNameInfo": "Retrieves host names."
    },
    "fields": {}
  },
  "eval.luv.Env": {
    "doc": "Environment variables.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Env",
    "path": "haxe\\std\\eval\\luv\\Env.hx",
    "functions": {
      "setEnv": "Sets an environment variable.",
      "unsetEnv": "Deletes an environment variable.",
      "environ": "Retrieves all environment variables."
    },
    "fields": {}
  },
  "eval.luv.FileMode": {
    "doc": "Permission bits.\n\t@see https://aantron.github.io/luv/luv/Luv/File/Mode",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.FileSync": {
    "doc": "Abstract type for a bit field of permissions bits, i.e., an `int` in which\n\tmultiple bits may be set. These bit fields are returned by operations such\n\tas `eval.luv.File.stat`\n*/\n@:coreType abstract FileModeNumeric {}\n\ntypedef FileStatTimeSpec = {\n\tvar sec:Int64;\n\tvar nsec:Int64;\n}\n\ntypedef FileStat = {\n\tvar dev:UInt64;\n\tvar mode:FileModeNumeric;\n\tvar nlink:UInt64;\n\tvar uid:UInt64;\n\tvar gid:UInt64;\n\tvar rdev:UInt64;\n\tvar ino:UInt64;\n\tvar size:UInt64;\n\tvar blksize:UInt64;\n\tvar blocks:UInt64;\n\tvar flags:UInt64;\n\tvar gen:UInt64;\n\tvar atim:FileStatTimeSpec;\n\tvar mtim:FileStatTimeSpec;\n\tvar ctim:FileStatTimeSpec;\n\tvar birthtim:FileStatTimeSpec;\n}\n\ntypedef FileStatFs = {\n\tvar type:UInt64;\n\tvar bsize:UInt64;\n\tvar blocks:UInt64;\n\tvar bfree:UInt64;\n\tvar bavail:UInt64;\n\tvar files:UInt64;\n\tvar ffree:UInt64;\n\tvar fspare:Array<UInt64>;\n}\n\nenum abstract FileCopyFlag(Int) {\n\tvar COPYFILE_EXCL = 0;\n\tvar COPYFILE_FICLONE = 1;\n\tvar COPYFILE_FICLONE_FORCE = 2;\n}\n\nenum abstract FileAccessFlag(Int) {\n\tvar F_OK = 0;\n\tvar R_OK = 1;\n\tvar W_OK = 2;\n\tvar X_OK = 3;\n}\n\nenum abstract FileSymlinkFlag(Int) {\n\tvar SYMLINK_DIR = 0;\n\tvar SYMLINK_JUNCTION = 1;\n}\n\n/**\n\tFiles.\n\n\t@see https://aantron.github.io/luv/luv/Luv/File\n*/\n@:using(eval.luv.Handle)\n@:coreType abstract File to Handle {\n\n\textern static public final stdin:File;\n\textern static public final stdout:File;\n\textern static public final stderr:File;\n\n\tstatic public function createRequest():FileRequest;\n\n\t/**\n\t\tChecks whether all the bits in `mask` are set in `bits`.\n\n\t\tFor example, if `bits` is equal to octal 0o644, then\n\t\t`eval.luv.File.testMode [IRUSR] bits` evaluates to `true`.\n*/\n\tstatic public function testMode(mask:Array<FileMode>, bits:FileModeNumeric):Bool;\n\n\t/**\n\t\tOpens the file at the given path.\n\t\tThe default value of the `mode` argument is equal to octal `0o644`.\n*/\n\tstatic public function open(loop:Loop, path:NativeString, flags:Array<FileOpenFlag>, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<File>)->Void):Void;\n\n\t/**\n\t\tCloses the file.\n*/\n\tpublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tReads from the file.\n\n\t\tThe incoming data is written consecutively to into the given buffers.\n\t\tThe number of bytes that the operation tries to read is the total length\n\t\tof the buffers.\n\n\t\tEnd of file is indicated by `Result.Ok(0)`. Note that this is different\n\t\tfrom `eval.luv.Stream.readStart`.\n*/\n\tpublic function read(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n\t/**\n\t\tWrites to the file.\n*/\n\tpublic function write(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n\t/**\n\t\tDeletes the file at the given path.\n*/\n\tstatic public function unlink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tMoves the file at the given path to the path given by `toPath`\n*/\n\tstatic public function rename(loop:Loop, path:NativeString, toPath:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tCreates a temporary file with name based on the given pattern.\n*/\n\tstatic public function mkstemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<{name:NativeString,file:File}>)->Void):Void;\n\n\t/**\n\t\tCreates a temporary directory with name based on the given pattern.\n*/\n\tstatic public function mkdtemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n\t/**\n\t\tCreates a directory.\n*/\n\tstatic public function mkdir(loop:Loop, path:NativeString, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tDeletes a directory.\n*/\n\tstatic public function rmdir(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tRetrieves status information for the file at the given path.\n*/\n\tstatic public function stat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n\t/**\n\t\tLike `eval.luv.File.stat`, but does not dereference symlinks.\n*/\n\tstatic public function lstat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n\t/**\n\t\tRetrieves status information for this file.\n*/\n\tpublic function fstat(loop:Loop, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n\t/**\n\t\tRetrieves status information for the filesystem containing the given path.\n*/\n\tstatic public function statFs(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStatFs>)->Void):Void;\n\n\t/**\n\t\tFlushes file changes to storage.\n*/\n\tpublic function fsync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tLike `eval.luv.File.fsync`, but may omit some metadata.\n*/\n\tpublic function fdataSync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tTruncates the given file to the given length.\n*/\n\tpublic function ftruncate(loop:Loop, length:Int64, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tCopies the file at the given path to the path given by `toPath`.\n*/\n\tstatic public function copyFile(loop:Loop, path:NativeString, toPath:NativeString, ?flags:Array<FileCopyFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tTransfers data between file descriptors.\n*/\n\tpublic function sendFile(loop:Loop, toFile:File, offset:Int64, length:UInt64, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n\t/**\n\t\tChecks whether the calling process can access the file at the given path.\n*/\n\tstatic public function access(loop:Loop, path:NativeString, flags:Array<FileAccessFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tChanges permissions of the file at the given path.\n*/\n\tstatic public function chmod(loop:Loop, path:NativeString, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tChanges permissions of the file.\n*/\n\tpublic function fchmod(loop:Loop, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tSets timestamps of the file at the given path.\n*/\n\tstatic public function utime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tSets timestamps of the file.\n*/\n\tpublic function futime(loop:Loop, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tSets timestamps of the file at the given path without dereferencing symlinks.\n*/\n\tstatic public function lutime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tHardlinks a file at the location given by `link`.\n*/\n\tstatic public function link(loop:Loop, path:NativeString, link:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tSymlinks a file at the location given by `link`.\n*/\n\tstatic public function symlink(loop:Loop, path:NativeString, link:NativeString, ?flags:Array<FileSymlinkFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tReads the target path of a symlink.\n*/\n\tstatic public function readLink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n\t/**\n\t\tResolves a real absolute path to the given file.\n*/\n\tstatic public function realPath(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n\t/**\n\t\tChanges ownership of the file at the given path.\n*/\n\tstatic public function chown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tChanges ownership of the file at the given path. without dereferencing symlinks.\n*/\n\tstatic public function lchown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tChanges ownership of the file.\n*/\n\tpublic function fchown(loop:Loop, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n\t/**\n\t\tReturns the integer representation of `eval.luv.File`.\n\n\t\t`eval.luv.File` is defined as an integer file descriptor by libuv on all\n\t\tplatforms at the moment. This is a convenience function for interoperability\n\t\twith `eval.luv.Process`, the API of which assumes that files are represented\n\t\tby integers.\n*/\n\tpublic function toInt():Int;\n}\n\n/**\n\tSynchronous version of `eval.luv.File` API",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {
      "open": "Opens the file at the given path.\n\t\tThe default value of the `mode` argument is equal to octal `0o644`.",
      "close": "Closes the file.",
      "read": "Reads from the file.\n\n\t\tThe incoming data is written consecutively to into the given buffers.\n\t\tThe number of bytes that the operation tries to read is the total length\n\t\tof the buffers.\n\n\t\tEnd of file is indicated by `Result.Ok(0)`. Note that this is different\n\t\tfrom `eval.luv.Stream.readStart`.",
      "write": "Writes to the file.",
      "unlink": "Deletes the file at the given path.",
      "rename": "Moves the file at the given path to the path given by `toPath`",
      "mkstemp": "Creates a temporary file with name based on the given pattern.",
      "mkdtemp": "Creates a temporary directory with name based on the given pattern.",
      "mkdir": "Creates a directory.",
      "rmdir": "Deletes a directory.",
      "stat": "Retrieves status information for the file at the given path.",
      "lstat": "Like `eval.luv.File.stat`, but does not dereference symlinks.",
      "fstat": "Retrieves status information for this file.",
      "statFs": "Retrieves status information for the filesystem containing the given path.",
      "fsync": "Flushes file changes to storage.",
      "fdataSync": "Like `eval.luv.File.fsync`, but may omit some metadata.",
      "ftruncate": "Truncates the given file to the given length.",
      "copyFile": "Copies the file at the given path to the path given by `toPath`.",
      "sendFile": "Transfers data between file descriptors.",
      "access": "Checks whether the calling process can access the file at the given path.",
      "chmod": "Changes permissions of the file at the given path.",
      "fchmod": "Changes permissions of the file.",
      "utime": "Sets timestamps of the file at the given path.",
      "futime": "Sets timestamps of the file.",
      "lutime": "Sets timestamps of the file at the given path without dereferencing symlinks.",
      "link": "Hardlinks a file at the location given by `link`.",
      "symlink": "Symlinks a file at the location given by `link`.",
      "readLink": "Reads the target path of a symlink.",
      "realPath": "Resolves a real absolute path to the given file.",
      "chown": "Changes ownership of the file at the given path.",
      "lchown": "Changes ownership of the file at the given path. without dereferencing symlinks.",
      "fchown": "Changes ownership of the file.",
      "toInt": "Returns the integer representation of `eval.luv.File`.\n\n\t\t`eval.luv.File` is defined as an integer file descriptor by libuv on all\n\t\tplatforms at the moment. This is a convenience function for interoperability\n\t\twith `eval.luv.Process`, the API of which assumes that files are represented\n\t\tby integers."
    },
    "fields": {}
  },
  "eval.luv.abstract": {
    "doc": "Error handling.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Error",
    "path": "haxe\\std\\eval\\luv\\UVError.hx",
    "functions": {},
    "fields": {
      "UV_EACCES": "permission denied",
      "UV_EADDRINUSE": "address already in use",
      "UV_EADDRNOTAVAIL": "address not available",
      "UV_EAFNOSUPPORT": "address family not supported",
      "UV_EAGAIN": "resource temporarily unavailable",
      "UV_EAI_ADDRFAMILY": "address family not supported",
      "UV_EAI_AGAIN": "temporary failure",
      "UV_EAI_BADFLAGS": "bad ai_flags value",
      "UV_EAI_BADHINTS": "invalid value for hints",
      "UV_EAI_CANCELED": "request canceled",
      "UV_EAI_FAIL": "permanent failure",
      "UV_EAI_FAMILY": "ai_family not supported",
      "UV_EAI_MEMORY": "out of memory",
      "UV_EAI_NODATA": "no address",
      "UV_EAI_NONAME": "unknown node or service",
      "UV_EAI_OVERFLOW": "argument buffer overflow",
      "UV_EAI_PROTOCOL": "resolved protocol is unknown",
      "UV_EAI_SERVICE": "service not available for socket type",
      "UV_EAI_SOCKTYPE": "socket type not supported",
      "UV_EALREADY": "connection already in progress",
      "UV_EBADF": "bad file descriptor",
      "UV_EBUSY": "resource busy or locked",
      "UV_ECANCELED": "operation canceled",
      "UV_ECONNABORTED": "invalid Unicode character */\n\t// var UV_ECHARSET = 24; // not defined in Luv ocaml library\n\t/** software caused connection abort",
      "UV_ECONNREFUSED": "connection refused",
      "UV_ECONNRESET": "connection reset by peer",
      "UV_EDESTADDRREQ": "destination address required",
      "UV_EEXIST": "file already exists",
      "UV_EFAULT": "bad address in system call argument",
      "UV_EFBIG": "file too large",
      "UV_EHOSTUNREACH": "host is unreachable",
      "UV_EINTR": "interrupted system call",
      "UV_EINVAL": "invalid argument",
      "UV_EIO": "i/o error",
      "UV_EISCONN": "socket is already connected",
      "UV_EISDIR": "illegal operation on a directory",
      "UV_ELOOP": "too many symbolic links encountered",
      "UV_EMFILE": "too many open files",
      "UV_EMSGSIZE": "message too long",
      "UV_ENAMETOOLONG": "name too long",
      "UV_ENETDOWN": "network is down",
      "UV_ENETUNREACH": "network is unreachable",
      "UV_ENFILE": "file table overflow",
      "UV_ENOBUFS": "no buffer space available",
      "UV_ENODEV": "no such device",
      "UV_ENOENT": "no such file or directory",
      "UV_ENOMEM": "not enough memory",
      "UV_ENONET": "machine is not on the network",
      "UV_ENOPROTOOPT": "protocol not available",
      "UV_ENOSPC": "no space left on device",
      "UV_ENOSYS": "function not implemented",
      "UV_ENOTCONN": "socket is not connected",
      "UV_ENOTDIR": "not a directory",
      "UV_ENOTEMPTY": "directory not empty",
      "UV_ENOTSOCK": "socket operation on non-socket",
      "UV_ENOTSUP": "operation not supported on socket",
      "UV_EPERM": "operation not permitted",
      "UV_EPIPE": "broken pipe",
      "UV_EPROTO": "protocol error",
      "UV_EPROTONOSUPPORT": "protocol not supported",
      "UV_EPROTOTYPE": "protocol wrong type for socket",
      "UV_ERANGE": "result too large",
      "UV_EROFS": "read-only file system",
      "UV_ESHUTDOWN": "cannot send after transport endpoint shutdown",
      "UV_ESPIPE": "invalid seek",
      "UV_ESRCH": "no such process",
      "UV_ETIMEDOUT": "connection timed out",
      "UV_ETXTBSY": "text file is busy",
      "UV_EXDEV": "cross-device link not permitted",
      "UV_UNKNOWN": "unknown error",
      "UV_EOF": "end of file",
      "UV_ENXIO": "no such device or address",
      "UV_EMLINK": "too many links",
      "UV_ENOTTY": "inappropriate ioctl for device",
      "UV_EFTYPE": "inappropriate file type or format",
      "UV_EILSEQ": "illegal byte sequence",
      "UV_EOVERFLOW": "value too large for defined data type *",
      "UV_ESOCKTNOSUPPORT": "socket type not supported*"
    }
  },
  "eval.luv.LuvException": {
    "doc": "Exceptions thrown by functions in `eval.luv` package.",
    "path": "haxe\\std\\eval\\luv\\LuvException.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Metrics": {
    "doc": "Metrics.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Metrics",
    "path": "haxe\\std\\eval\\luv\\Metrics.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Network": {
    "doc": "Network interfaces and hostname.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Network",
    "path": "haxe\\std\\eval\\luv\\Network.hx",
    "functions": {
      "ifIndexToName": "Retrieves a network interface name.",
      "ifIndexToIid": "Retrieves a network interface identifier suitable for use in an IPv6 scoped address.",
      "getHostName": "Evaluates to the system's hostname."
    },
    "fields": {}
  },
  "eval.luv.Passwd": {
    "doc": "Current user information.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Passwd",
    "path": "haxe\\std\\eval\\luv\\Passwd.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Path": {
    "doc": "Relevant directories.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Path",
    "path": "haxe\\std\\eval\\luv\\Path.hx",
    "functions": {
      "cwd": "Evaluates to the current working directory.",
      "chdir": "Changes the current working directory.",
      "homedir": "Evaluates to the path of the home directory.",
      "tmpdir": "Evaluates to the path of the temporary directory."
    },
    "fields": {}
  },
  "eval.luv.Pid": {
    "doc": "Process ids.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Pid",
    "path": "haxe\\std\\eval\\luv\\Pid.hx",
    "functions": {
      "getPPid": "Evaluates to the pid of the parent process."
    },
    "fields": {}
  },
  "eval.luv.Random": {
    "doc": "System entropy source.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Random",
    "path": "haxe\\std\\eval\\luv\\Random.hx",
    "functions": {
      "random": "Fills the given buffer with bits from the system entropy source."
    },
    "fields": {}
  },
  "eval.luv.Resource": {
    "doc": "Resource usage.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Resource",
    "path": "haxe\\std\\eval\\luv\\Resource.hx",
    "functions": {
      "loadAvg": "Evaluates to the load average.",
      "freeMemory": "Evaluates to the amount of free memory, in bytes.\n\t\tReturns `null` when unknown.",
      "totalMemory": "Evaluates to the total amount of memory, in bytes.\n\t\tReturns `null` when unknown.",
      "constrainedMemory": "Gets the amount of memory available to the process (in bytes) based on\n\t\tlimits imposed by the OS.\n\t\tIf there is no such constraint returns `null`",
      "getPriority": "Evaluates to the priority of the process with the given pid.",
      "setPriority": "Sets the priority of the process with the given pid.",
      "residentSetMemory": "Evaluates to the resident set size for the current process.",
      "getRUsage": "Gets the resource usage measures for the current process."
    },
    "fields": {}
  },
  "eval.luv.AddressFamily": {
    "doc": "Network address families.",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.SocketType": {
    "doc": "Socket types.",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {
      "ipv6": "Converts a string and port number to an IPv6 struct sockaddr.",
      "toString": "Converts a network address to a string."
    },
    "fields": {}
  },
  "eval.luv.SystemInfo": {
    "doc": "System information.\n\n\t@see https://aantron.github.io/luv/luv/Luv/System_info",
    "path": "haxe\\std\\eval\\luv\\SystemInfo.hx",
    "functions": {
      "uname": "Gets information about the CPUs on the system."
    },
    "fields": {}
  },
  "eval.luv.ThreadPool": {
    "doc": "Thread pool.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Thread_pool",
    "path": "haxe\\std\\eval\\luv\\ThreadPool.hx",
    "functions": {
      "setSize": "Sets thread pool size.\n\n\t\tThis function should be called as soon during process startup as possible."
    },
    "fields": {}
  },
  "eval.luv.Time": {
    "doc": "Current time.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Time",
    "path": "haxe\\std\\eval\\luv\\Time.hx",
    "functions": {
      "hrTime": "Samples the high-resolution timer.",
      "sleep": "Suspends the calling thread for at least the given number of milliseconds."
    },
    "fields": {}
  },
  "eval.luv.Version": {
    "doc": "Version information for the vendored libuv.\n\n\t@see https://aantron.github.io/luv/luv/Luv/Version",
    "path": "haxe\\std\\eval\\luv\\Version.hx",
    "functions": {},
    "fields": {}
  },
  "eval.vm.Gc": {
    "doc": "The memory management counters are returned in a stat record.\n\tThe total amount of memory allocated by the program since it was started is (in words) minor_words + major_words - promoted_words. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.\n*/\ntypedef Stat = {\n\t/**\n\t\tNumber of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.\n*/\n\tvar minor_words:Float;\n\n\t/**\n\t\tNumber of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.\n*/\n\tvar promoted_words:Float;\n\n\t/**\n\t\tNumber of words allocated in the major heap, including the promoted words, since the program was started.\n*/\n\tvar major_words:Float;\n\n\t/**\n\t\tNumber of minor collections since the program was started.\n*/\n\tvar minor_collections:Float;\n\n\t/**\n\t\tNumber of major collection cycles completed since the program was started.\n*/\n\tvar major_collections:Float;\n\n\t/**\n\t\tTotal size of the major heap, in words.\n*/\n\tvar heap_words:Int;\n\n\t/**\n\t\tNumber of contiguous pieces of memory that make up the major heap.\n*/\n\tvar heap_chunks:Int;\n\n\t/**\n\t\tNumber of words of live data in the major heap, including the header words.\n*/\n\tvar live_words:Int;\n\n\t/**\n\t\tNumber of live blocks in the major heap.\n*/\n\tvar live_blocks:Int;\n\n\t/**\n\t\tNumber of words in the free list.\n*/\n\tvar free_words:Int;\n\n\t/**\n\t\tNumber of blocks in the free list.\n*/\n\tvar free_blocks:Int;\n\n\t/**\n\t\tSize (in words) of the largest block in the free list.\n*/\n\tvar largest_free:Int;\n\n\t/**\n\t\tNumber of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.\n*/\n\tvar fragments:Int;\n\n\t/**\n\t\tNumber of heap compactions since the program was started.\n*/\n\tvar compactions:Int;\n\n\t/**\n\t\tMaximum size reached by the major heap, in words.\n*/\n\tvar top_heap_words:Int;\n\n\t/**\n\t\tCurrent size of the stack, in words.\n*/\n\tvar stack_size:Int;\n}\n\n/**\n\tThe GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n\t/**\n\t\tThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.\n*/\n\tvar minor_heap_size:Int;\n\n\t/**\n\t\tHow much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.\n*/\n\tvar major_heap_increment:Int;\n\n\t/**\n\t\tThe major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.\n*/\n\tvar space_overhead:Int;\n\n\t/**\n\t\tThis value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.\n*/\n\tvar verbose:Int;\n\n\t/**\n\t\tHeap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.\n*/\n\tvar max_overhead:Int;\n\n\t/**\n\t\tThe maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.\n*/\n\tvar stack_limit:Int;\n\n\t/**\n\t\tThe policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.\n*/\n\tvar allocation_policy:Int;\n}\n\n/**\n\tMemory management control and statistics; finalised values.",
    "path": "haxe\\std\\eval\\vm\\Gc.hx",
    "functions": {
      "compact": "Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.",
      "counters": "Return (minor_words, promoted_words, major_words). This function is as fast as quick_stat.",
      "finalise": "Registers f as a finalisation function for v. v must be heap-allocated. f will be called with v as argument at some point between the first time v becomes unreachable (including through weak pointers) and the time v is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before v becomes unreachable).\n\t\tThe GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to finalise. If finalise is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.\n\n\t\tIn the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.",
      "full_major": "Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.",
      "get": "Return the current values of the GC parameters in a control record.",
      "major": "Do a minor collection and finish the current major collection cycle.",
      "major_slice": "Do a minor collection and a slice of major collection. n is the size of the slice: the GC will do enough work to free (on average) n words of memory. If n = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).",
      "minor": "Trigger a minor collection.",
      "print_stat": "Print the current values of the memory management counters (in human-readable form) into the channel argument.",
      "quick_stat": "Same as stat except that live_words, live_blocks, free_words, free_blocks, largest_free, and fragments are set to 0. This function is much faster than stat because it does not need to go through the heap.",
      "set": "Changes the GC parameters according to the control record r.",
      "stat": "Return the current values of the memory management counters in a stat record. This function examines every heap block to get the statistics."
    },
    "fields": {
      "promoted_words": "Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.",
      "major_words": "Number of words allocated in the major heap, including the promoted words, since the program was started.",
      "minor_collections": "Number of minor collections since the program was started.",
      "major_collections": "Number of major collection cycles completed since the program was started.",
      "heap_words": "Total size of the major heap, in words.",
      "heap_chunks": "Number of contiguous pieces of memory that make up the major heap.",
      "live_words": "Number of words of live data in the major heap, including the header words.",
      "live_blocks": "Number of live blocks in the major heap.",
      "free_words": "Number of words in the free list.",
      "free_blocks": "Number of blocks in the free list.",
      "largest_free": "Size (in words) of the largest block in the free list.",
      "fragments": "Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.",
      "compactions": "Number of heap compactions since the program was started.",
      "top_heap_words": "Maximum size reached by the major heap, in words.",
      "stack_size": "Current size of the stack, in words.",
      "minor_heap_size": "The GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n\t/**\n\t\tThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.",
      "major_heap_increment": "How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.",
      "space_overhead": "The major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.",
      "verbose": "This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.",
      "max_overhead": "Heap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.",
      "stack_limit": "The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.",
      "allocation_policy": "The policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0."
    }
  },
  "flash.Lib": {
    "doc": "Platform-specific Flash Library. Provides some platform-specific\n\tfunctions for the Flash target.",
    "path": "haxe\\std\\flash\\Lib.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.UnsafeStringMap": {
    "doc": "This is similar to `StringMap` excepts that it does not sanitize the keys.\n\tAs a result, it will be faster to access the map for reading, but it might fail\n\twith some reserved keys such as `constructor` or `prototype`.",
    "path": "haxe\\std\\flash\\_std\\haxe\\ds\\UnsafeStringMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.StackItem": {
    "doc": "Elements return by `CallStack` methods.",
    "path": "haxe\\std\\haxe\\CallStack.hx",
    "functions": {
      "exceptionStack": "Return the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t\tSet `fullStack` parameter to true in order to return the full exception stack.\n\n\t\tMay not work if catch type was a derivative from `haxe.Exception`.",
      "toString": "Returns a representation of the stack as a printable string.",
      "subtract": "Returns a range of entries of current stack from the beginning to the the\n\t\tcommon part of this and `stack`.",
      "copy": "Make a copy of the stack."
    },
    "fields": {}
  },
  "haxe.FlatEnum": {
    "doc": "This type unifies with any function type.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n*/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\n\tThis type unifies with an enum instance if all constructors of the enum\n\trequire no arguments.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.NotVoid": {
    "doc": "This type unifies with anything but `Void`.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Constructible": {
    "doc": "This type unifies with any instance of classes that have a constructor\n\twhich\n\nis `public` and\nunifies with the type used for type parameter `T`.\n\n\tIf a type parameter `A` is assigned to a type parameter `B` which is constrained\n\tto `Constructible<T>`, A must be explicitly constrained to\n\t`Constructible<T>` as well.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.DynamicAccess": {
    "doc": "DynamicAccess is an abstract type for working with anonymous structures\n\tthat are intended to hold collections of objects by the string key.\n\n\tFor example, these types of structures are often created from JSON.\n\n\tBasically, it wraps `Reflect` calls in a `Map`-like interface.",
    "path": "haxe\\std\\haxe\\DynamicAccess.hx",
    "functions": {
      "get": "Returns a value by specified `key`.\n\n\t\tIf the structure does not contain the given key, `null` is returned.\n\n\t\tIf `key` is `null`, the result is unspecified.",
      "set": "Sets a `value` for a specified `key`.\n\n\t\tIf the structure contains the given key, its value will be overwritten.\n\n\t\tReturns the given value.\n\n\t\tIf `key` is `null`, the result is unspecified.",
      "exists": "Tells if the structure contains a specified `key`.\n\n\t\tIf `key` is `null`, the result is unspecified.",
      "remove": "Removes a specified `key` from the structure.\n\n\t\tReturns true, if `key` was present in structure, or false otherwise.\n\n\t\tIf `key` is `null`, the result is unspecified.",
      "keys": "Returns an array of `keys` in a structure.",
      "copy": "Returns a shallow copy of the structure",
      "iterator": "Returns an Iterator over the values of this `DynamicAccess`.\n\n\t\tThe order of values is undefined.",
      "keyValueIterator": "Returns an Iterator over the keys and values of this `DynamicAccess`.\n\n\t\tThe order of values is undefined."
    },
    "fields": {}
  },
  "haxe.EntryPoint": {
    "doc": "If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\n\tThis class can be redefined by custom frameworks so they can handle their own main loop logic.",
    "path": "haxe\\std\\haxe\\EntryPoint.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumFlags": {
    "doc": "A typed interface for bit flags. This is not a real object, only a typed\n\tinterface for an actual Int. Each flag can be tested/set with the\n\tcorresponding enum instance. Up to 32 flags can be stored that way.\n\n\tEnum constructor indices are preserved from Haxe syntax, so the first\n\tdeclared is index 0, the next index 1 etc. The methods are optimized if the\n\tenum instance is passed directly, e.g. as `has(EnumCtor)`. Otherwise\n\t`Type.enumIndex()` reflection is used.",
    "path": "haxe\\std\\haxe\\EnumFlags.hx",
    "functions": {
      "has": "Checks if the index of enum instance `v` is set.\n\n\t\tThis method is optimized if `v` is an enum instance expression such as\n\t\t`SomeEnum.SomeCtor`.\n\n\t\tIf `v` is `null`, the result is unspecified.",
      "set": "Sets the index of enum instance `v`.\n\n\t\tThis method is optimized if `v` is an enum instance expression such as\n\t\t`SomeEnum.SomeCtor`.\n\n\t\tIf `v` is `null`, the result is unspecified.",
      "unset": "Unsets the index of enum instance `v`.\n\n\t\tThis method is optimized if `v` is an enum instance expression such as\n\t\t`SomeEnum.SomeCtor`.\n\n\t\tIf `v` is `null`, the result is unspecified.",
      "setTo": "Depending on the value of `condition` sets (`condition=true`) or unsets (`condition=false`)\n\t\tthe index of enum instance `v`.\n\n\t\tThis method is optimized if `v` is an enum instance expression such as\n\t\t`SomeEnum.SomeCtor`.\n\n\t\tIf `v` is `null`, the result is unspecified.",
      "ofInt": "Convert a integer bitflag into a typed one (this is a no-op, it does not\n\t\thave any impact on speed).",
      "toInt": "Convert the typed bitflag into the corresponding int value (this is a\n\t\tno-op, it doesn't have any impact on speed)."
    },
    "fields": {}
  },
  "haxe.EnumTools": {
    "doc": "This class provides advanced methods on enums. It is ideally used with\n\t`using EnumTools` and then acts as an\n\t  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n\t  `enum` types.\n\n\tIf the first argument to any of the methods is `null`, the result is\n\tunspecified.",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumValueTools": {
    "doc": "Returns the name of enum `e`, including its path.\n\n\t\tIf `e` is inside a package, the package structure is returned dot-\n\t\tseparated, with another dot separating the enum name:\n\n\t\t\tpack1.pack2.(...).packN.EnumName\n\n\t\tIf `e` is a sub-type of a Haxe module, that module is not part of the\n\t\tpackage structure.\n\n\t\tIf `e` has no package, the enum name is returned.\n\n\t\tIf `e` is `null`, the result is unspecified.\n\n\t\tThe enum name does not include any type parameters.\n*/\n\tstatic inline function getName<T>(e:Enum<T>):String {\n\t\treturn Type.getEnumName(e);\n\t}\n\n\t/**\n\t\tCreates an instance of enum `e` by calling its constructor `constr` with\n\t\targuments `params`.\n\n\t\tIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.\n*/\n\tstatic inline function createByName<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\t\treturn Type.createEnum(e, constr, params);\n\t}\n\n\t/**\n\t\tCreates an instance of enum `e` by calling its constructor number\n\t\t`index` with arguments `params`.\n\n\t\tThe constructor indices are preserved from Haxe syntax, so the first\n\t\tdeclared is index 0, the next index 1 etc.\n\n\t\tIf `e` or `index` is `null`, or if enum `e` has no constructor\n\t\tcorresponding to index `index`, or if the number of elements in `params`\n\t\tdoes not match the expected number of constructor arguments, or if any\n\t\targument has an invalid type, the result is unspecified.\n*/\n\tstatic inline function createByIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\t\treturn Type.createEnumIndex(e, index, params);\n\t}\n\n\t/**\n\t\tReturns a list of all constructors of enum `e` that require no\n\t\targuments.\n\n\t\tThis may return the empty Array `[]` if all constructors of `e` require\n\t\targuments.\n\n\t\tOtherwise an instance of `e` constructed through each of its non-\n\t\targument constructors is returned, in the order of the constructor\n\t\tdeclaration.\n\n\t\tIf `e` is `null`, the result is unspecified.\n*/\n\tstatic inline function createAll<T>(e:Enum<T>):Array<T> {\n\t\treturn Type.allEnums(e);\n\t}\n\n\t/**\n\t\tReturns a list of the names of all constructors of enum `e`.\n\n\t\tThe order of the constructor names in the returned Array is preserved\n\t\tfrom the original syntax.\n\n\t\tIf `c` is `null`, the result is unspecified.\n*/\n\tstatic inline function getConstructors<T>(e:Enum<T>):Array<String> {\n\t\treturn Type.getEnumConstructs(e);\n\t}\n\n\t#if jvm\n\t@:noCompletion\n\textern static function values<T>(en:Enum<T>):jvm.NativeArray<java.lang.Enum<T>>;\n\t#end\n}\n\n/**\n\tThis class provides advanced methods on enum values. It is ideally used with\n\t`using EnumValueTools` and then acts as an\n\t  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n\t  `EnumValue` types.\n\n\tIf the first argument to any of the methods is `null`, the result is\n\tunspecified.",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {
      "createByName": "Creates an instance of enum `e` by calling its constructor `constr` with\n\t\targuments `params`.\n\n\t\tIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n\t\t`constr`, or if the number of elements in `params` does not match the\n\t\texpected number of constructor arguments, or if any argument has an\n\t\tinvalid type, the result is unspecified.",
      "createByIndex": "Creates an instance of enum `e` by calling its constructor number\n\t\t`index` with arguments `params`.\n\n\t\tThe constructor indices are preserved from Haxe syntax, so the first\n\t\tdeclared is index 0, the next index 1 etc.\n\n\t\tIf `e` or `index` is `null`, or if enum `e` has no constructor\n\t\tcorresponding to index `index`, or if the number of elements in `params`\n\t\tdoes not match the expected number of constructor arguments, or if any\n\t\targument has an invalid type, the result is unspecified.",
      "createAll": "Returns a list of all constructors of enum `e` that require no\n\t\targuments.\n\n\t\tThis may return the empty Array `[]` if all constructors of `e` require\n\t\targuments.\n\n\t\tOtherwise an instance of `e` constructed through each of its non-\n\t\targument constructors is returned, in the order of the constructor\n\t\tdeclaration.\n\n\t\tIf `e` is `null`, the result is unspecified.",
      "getConstructors": "Returns a list of the names of all constructors of enum `e`.\n\n\t\tThe order of the constructor names in the returned Array is preserved\n\t\tfrom the original syntax.\n\n\t\tIf `c` is `null`, the result is unspecified.",
      "equals": "This class provides advanced methods on enum values. It is ideally used with\n\t`using EnumValueTools` and then acts as an\n\t  [extension](https://haxe.org/manual/lf-static-extension.html) to the\n\t  `EnumValue` types.\n\n\tIf the first argument to any of the methods is `null`, the result is\n\tunspecified.\n*/\nextern class EnumValueTools {\n\t/**\n\t\tRecursively compares two enum instances `a` and `b` by value.\n\n\t\tUnlike `a == b`, this function performs a deep equality check on the\n\t\targuments of the constructors (if there are any).\n\n\t\tIf `a` or `b` are `null`, the result is unspecified.",
      "getName": "Returns the constructor name of enum instance `e`.\n\n\t\tThe result String does not contain any constructor arguments.\n\n\t\tIf `e` is `null`, the result is unspecified.",
      "getParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\n\t\tIf `e` has no arguments, the result is `[]`.\n\n\t\tOtherwise the result are the values that were used as arguments to `e`,\n\t\tin the order of their declaration.\n\n\t\tIf `e` is `null`, the result is unspecified.",
      "getIndex": "Returns the index of enum instance `e`.\n\n\t\tThis corresponds to the original syntactic position of `e`. The index of\n\t\tthe first declared constructor is 0, the next one is 1 etc.\n\n\t\tIf `e` is `null`, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.Exception": {
    "doc": "Base class for exceptions.\n\n\tIf this class (or derivatives) is used to catch an exception, then\n\t`haxe.CallStack.exceptionStack()` will not return a stack for the exception\n\tcaught. Use `haxe.Exception.stack` property instead:\n\t```haxe\n\ttry {\n\t\tthrowSomething();\n\t} catch(e:Exception) {\n\t\ttrace(e.stack);\n\t}\n\t```\n\n\tCustom exceptions should extend this class:\n\t```haxe\n\tclass MyException extends haxe.Exception {}\n\t//...\n\tthrow new MyException('terrible exception');\n\t```\n\n\t`haxe.Exception` is also a wildcard type to catch any exception:\n\t```haxe\n\ttry {\n\t\tthrow 'Catch me!';\n\t} catch(e:haxe.Exception) {\n\t\ttrace(e.message); // Output: Catch me!\n\t}\n\t```\n\n\tTo rethrow an exception just throw it again.\n\tHaxe will try to rethrow an original native exception whenever possible.\n\t```haxe\n\ttry {\n\t\tvar a:Array<Int> = null;\n\t\ta.push(1); // generates target-specific null-pointer exception\n\t} catch(e:haxe.Exception) {\n\t\tthrow e; // rethrows native exception instead of haxe.Exception\n\t}\n\t```",
    "path": "haxe\\std\\haxe\\Exception.hx",
    "functions": {
      "thrown": "Used internally for wrapping non-throwable values for `throw` expressions.",
      "new": "Create a new Exception instance.\n\n\t\tThe `previous` argument could be used for exception chaining.\n\n\t\tThe `native` argument is for internal usage only.\n\t\tThere is no need to provide `native` argument manually and no need to keep it\n\t\tupon extending `haxe.Exception` unless you know what you're doing.",
      "unwrap": "Extract an originally thrown value.\n\n\t\tUsed internally for catching non-native exceptions.\n\t\tDo _not_ override unless you know what you are doing.",
      "toString": "Returns exception message.",
      "details": "Detailed exception description.\n\n\t\tIncludes message, stack and the chain of previous exceptions (if set)."
    },
    "fields": {
      "stack": "The call stack at the moment of the exception creation.",
      "previous": "Contains an exception, which was passed to `previous` constructor argument.",
      "native": "Native exception, which caused this exception."
    }
  },
  "haxe.Int64Helper": {
    "doc": "Helper for parsing to `Int64` instances.",
    "path": "haxe\\std\\haxe\\Int64Helper.hx",
    "functions": {
      "fromFloat": "Create `Int64` from given float."
    },
    "fields": {}
  },
  "haxe.Json": {
    "doc": "Cross-platform JSON API: it will automatically use the optimized native API if available.\n\tUse `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:\n\tThis will provide extra encoding (but not decoding) features such as enums (replaced by their index) and StringMaps.\n\n\t@see https://haxe.org/manual/std-Json.html",
    "path": "haxe\\std\\haxe\\Json.hx",
    "functions": {
      "stringify": "Encodes the given `value` and returns the resulting JSON string.\n\n\t\tIf `replacer` is given and is not null, it is used to retrieve the\n\t\tactual object to be encoded. The `replacer` function takes two parameters,\n\t\tthe key and the value being encoded. Initial key value is an empty string.\n\n\t\tIf `space` is given and is not null, the result will be pretty-printed.\n\t\tSuccessive levels will be indented by this string.\n\n\t\t@see https://haxe.org/manual/std-Json-encoding.html"
    },
    "fields": {}
  },
  "haxe.Log": {
    "doc": "Log primarily provides the `trace()` method, which is invoked upon a call to\n\t`trace()` in Haxe code.",
    "path": "haxe\\std\\haxe\\Log.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Resource": {
    "doc": "Resource can be used to access resources that were added through the\n\t`--resource file@name` command line parameter.\n\n\tDepending on their type they can be obtained as `String` through\n\t`getString(name)`, or as binary data through `getBytes(name)`.\n\n\tA list of all available resource names can be obtained from `listNames()`.",
    "path": "haxe\\std\\haxe\\Resource.hx",
    "functions": {
      "getString": "Retrieves the resource identified by `name` as a `String`.\n\n\t\tIf `name` does not match any resource name, `null` is returned.",
      "getBytes": "Retrieves the resource identified by `name` as an instance of\n\t\thaxe.io.Bytes.\n\n\t\tIf `name` does not match any resource name, `null` is returned."
    },
    "fields": {}
  },
  "haxe.Serializer": {
    "doc": "The Serializer class can be used to encode values and objects into a `String`,\n\tfrom which the `Unserializer` class can recreate the original representation.\n\n\tThis class can be used in two ways:\n\n\t- create a `new Serializer()` instance, call its `serialize()` method with\n\t\tany argument and finally retrieve the String representation from\n\t\t`toString()`\n\t- call `Serializer.run()` to obtain the serialized representation of a\n\t\tsingle argument\n\n\tSerialization is guaranteed to work for all haxe-defined classes, but may\n\tor may not work for instances of external/native classes.\n\n\tThe specification of the serialization format can be found here:\n\t<https://haxe.org/manual/std-serialization-format.html>",
    "path": "haxe\\std\\haxe\\Serializer.hx",
    "functions": {
      "reset": "Resets the internal state of the Serializer, allowing it to be reused.\n\n\t\tThis does not affect the `useCache` or `useEnumIndex` properties;\n\t\ttheir values will remain unchanged after calling this method.",
      "toString": "Return the String representation of `this` Serializer.\n\n\t\tThe exact format specification can be found here:\n\t\thttps://haxe.org/manual/serialization/format",
      "serialize": "Serializes `v`.\n\t\n\t\tAll haxe-defined values and objects with the exception of functions can\n\t\tbe serialized. Serialization of external/native objects is not\n\t\tguaranteed to work. This is also true for classes extending external/native\n\t\tclasses. On some targets, this might include exceptions, too.\n\t\n\t\tThe values of `this.useCache` and `this.useEnumIndex` may affect\n\t\tserialization output.",
      "run": "Serializes `v` and returns the String representation.\n\t\n\t\tThis is a convenience function for creating a new instance of\n\t\tSerializer, serialize `v` into it and obtain the result through a call\n\t\tto `toString()`."
    },
    "fields": {
      "USE_ENUM_INDEX": "Serializes enum values using constructor indices instead of names.\n\n\t\tWhen `USE_ENUM_INDEX` is set to `true`, enum constructors are serialized by\n\t\ttheir numeric index. This can reduce the size of the serialized data,\n\t\tespecially for enums with long or frequently used constructor names.\n\n\t\tHowever, using indices makes serialized data more fragile for long-term\n\t\tstorage. If enum definitions change (e.g., by adding or removing constructors),\n\t\tthe indices may no longer match the intended constructors.\n\n\t\tThis is a global default. You can override it per instance using the\n\t\t`useEnumIndex` field on a `Serializer`.",
      "useCache": "Determines whether this `Serializer` instance uses object caching.\n\n\t\tWhen enabled, repeated references to the same object are serialized using references\n\t\tinstead of duplicating data, reducing output size and preserving object identity.\n\n\t\tSee `USE_CACHE` for a complete description.",
      "useEnumIndex": "Determines whether this `Serializer` instance serializes enum values using their index\n\t\tinstead of their constructor name.\n\n\t\tUsing indexes can reduce the size of the serialized data but may be less readable and\n\t\tmore fragile if enum definitions change.\n\n\t\tSee `USE_ENUM_INDEX` for a complete description."
    }
  },
  "haxe.Template": {
    "doc": "`Template` provides a basic templating mechanism to replace values in a source\n\tString, and to have some basic logic.\n\n\tA complete documentation of the supported syntax is available at:\n\t<https://haxe.org/manual/std-template.html>",
    "path": "haxe\\std\\haxe\\Template.hx",
    "functions": {
      "execute": "Executes `this` `Template`, taking into account `context` for\n\t\treplacements and `macros` for callback functions.\n\n\t\tIf `context` has a field `name`, its value replaces all occurrences of\n\t\t`::name::` in the `Template`. Otherwise `Template.globals` is checked instead,\n\t\tIf `name` is not a field of that either, `::name::` is replaced with `null`.\n\n\t\tIf `macros` has a field `name`, all occurrences of `$$name(args)` are\n\t\treplaced with the result of calling that field. The first argument is\n\t\talways the `resolve()` method, followed by the given arguments.\n\t\tIf `macros` has no such field, the result is unspecified.\n\n\t\tIf `context` is `null`, the result is unspecified. If `macros` is `null`,\n\t\tno macros are used."
    },
    "fields": {}
  },
  "haxe.Timer": {
    "doc": "The `Timer` class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the `Timer` class with a given\n\tinterval, set its `run()` method to a custom function to be invoked and\n\teventually call `stop()` to stop the `Timer`.\n\n\tNote that a running `Timer` may or may not prevent the program to exit\n\tautomatically when `main()` returns.\n\n\tIt is also possible to extend this class and override its `run()` method in\n\tthe child class.\n\n\tNotice for threaded targets:\n\t`Timer` instances require threads they were created in to run with Haxe's event loops.\n\tMain thread of a Haxe program always contains an event loop. For other cases use\n\t`sys.thread.Thread.createWithEventLoop` and `sys.thread.Thread.runWithEventLoop` methods.",
    "path": "haxe\\std\\haxe\\Timer.hx",
    "functions": {
      "stop": "Stops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.",
      "delay": "This method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\n\t\t```haxe\n\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\ttimer.run = function() { ... }\n\t\t```\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n*/\n\tpublic dynamic function run() {}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its `run()` method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is `null`, the result is unspecified.",
      "measure": "Measures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\t`Timer.stamp()` before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to `Log.trace()`, with `\"s\"` appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is `null`, the result is unspecified.",
      "stamp": "Returns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.",
      "milliseconds": "Returns a monotonically increasing timestamp with millisecond resolution.\n\nThe precision and epoch of the timer is platform defined."
    },
    "fields": {}
  },
  "haxe.Unit": {
    "doc": "A unit type that only has one value.",
    "path": "haxe\\std\\haxe\\Unit.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Unserializer": {
    "doc": "The `Unserializer` class is the complement to the `Serializer` class. It parses\n\ta serialization `String` and creates objects from the contained data.\n\n\tThis class can be used in two ways:\n\n\t- create a `new Unserializer()` instance with a given serialization\n\t\tString, then call its `unserialize()` method until all values are\n\t\textracted\n\t- call `Unserializer.run()`  to unserialize a single value from a given\n\t\tString\n\n\tThe specification of the serialization format can be found here:\n\t<https://haxe.org/manual/serialization/format>",
    "path": "haxe\\std\\haxe\\Unserializer.hx",
    "functions": {
      "setResolver": "Sets the type resolver of `this` Unserializer instance to `r`.\n\n\t\tIf `r` is `null`, a special resolver is used which returns `null` for all\n\t\tinput values.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.",
      "getResolver": "Gets the type resolver of `this` Unserializer instance.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.",
      "unserialize": "Unserializes the next part of `this` Unserializer instance and returns\n\t\tthe according value.\n\n\t\tThis function may call `this.resolver.resolveClass` to determine a\n\t\tClass from a String, and `this.resolver.resolveEnum` to determine an\n\t\tEnum from a String.\n\n\t\tIf `this` Unserializer instance contains no more or invalid data, an\n\t\texception is thrown.\n\n\t\tThis operation may fail on structurally valid data if a type cannot be\n\t\tresolved or if a field cannot be set. This can happen when unserializing\n\t\tStrings that were serialized on a different Haxe target, in which the\n\t\tserialization side has to make sure not to include platform-specific\n\t\tdata.\n\n\t\tClasses are created from `Type.createEmptyInstance`, which means their\n\t\tconstructors are not called.",
      "run": "Unserializes `v` and returns the according value.\n\n\t\tThis is a convenience function for creating a new instance of\n\t\tUnserializer with `v` as buffer and calling its `unserialize()` method\n\t\tonce."
    },
    "fields": {
      "index": "Creates a new Unserializer instance, with its internal buffer\n\t\tinitialized to `buf`.\n\n\t\tThis does not parse `buf` immediately. It is parsed only when calls to\n\t\t`this.unserialize` are made.\n\n\t\tEach Unserializer instance maintains its own cache.\n*/\n\tpublic function new(buf:String) {\n\t\tthis.buf = buf;\n\t\tlength = this.buf.fastLength();\n\t\tpos = 0;\n\t\t#if neko\n\t\tupos = 0;\n\t\t#end\n\t\tscache = new Array();\n\t\tcache = new Array();\n\t\tvar r = DEFAULT_RESOLVER;\n\t\tif (r == null) {\n\t\t\tr = new DefaultResolver();\n\t\t\tDEFAULT_RESOLVER = r;\n\t\t}\n\t\tresolver = r;\n\t}\n\n\t/**\n\t\tSets the type resolver of `this` Unserializer instance to `r`.\n\n\t\tIf `r` is `null`, a special resolver is used which returns `null` for all\n\t\tinput values.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\n\tpublic function setResolver(r) {\n\t\tif (r == null)\n\t\t\tresolver = NullResolver.instance;\n\t\telse\n\t\t\tresolver = r;\n\t}\n\n\t/**\n\t\tGets the type resolver of `this` Unserializer instance.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\n\tpublic function getResolver() {\n\t\treturn resolver;\n\t}\n\n\tinline function get(p:Int):Int {\n\t\t#if php\n\t\treturn p >= length ? 0 : buf.fastCharCodeAt(p);\n\t\t#else\n\t\treturn StringTools.fastCodeAt(buf, p);\n\t\t#end\n\t}\n\n\tfunction readDigits() {\n\t\tvar k = 0;\n\t\tvar s = false;\n\t\tvar fpos = pos;\n\t\twhile (true) {\n\t\t\tvar c = get(pos);\n\t\t\tif (StringTools.isEof(c))\n\t\t\t\tbreak;\n\t\t\tif (c == \"-\".code) {\n\t\t\t\tif (pos != fpos)\n\t\t\t\t\tbreak;\n\t\t\t\ts = true;\n\t\t\t\tpos++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c < \"0\".code || c > \"9\".code)\n\t\t\t\tbreak;\n\t\t\tk = k * 10 + (c - \"0\".code);\n\t\t\tpos++;\n\t\t}\n\t\tif (s)\n\t\t\tk *= -1;\n\t\treturn k;\n\t}\n\n\tfunction readFloat() {\n\t\tvar p1 = pos;\n\t\twhile (true) {\n\t\t\tvar c = get(pos);\n\t\t\tif (StringTools.isEof(c))\n\t\t\t\tbreak;\n\t\t\t// + - . , 0-9\n\t\t\tif ((c >= 43 && c < 58) || c == \"e\".code || c == \"E\".code)\n\t\t\t\tpos++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn Std.parseFloat(buf.fastSubstr(p1, pos - p1));\n\t}\n\n\tfunction unserializeObject(o:{}) {\n\t\twhile (true) {\n\t\t\tif (pos >= length)\n\t\t\t\tthrow \"Invalid object\";\n\t\t\tif (get(pos) == \"g\".code)\n\t\t\t\tbreak;\n\t\t\tvar k:Dynamic = unserialize();\n\t\t\tif (!Std.isOfType(k, String))\n\t\t\t\tthrow \"Invalid object key\";\n\t\t\tvar v = unserialize();\n\t\t\tReflect.setField(o, k, v);\n\t\t}\n\t\tpos++;\n\t}\n\n\tfunction unserializeEnum<T>(edecl:Enum<T>, tag:String) {\n\t\tif (get(pos++) != \":\".code)\n\t\t\tthrow \"Invalid enum format\";\n\t\tvar nargs = readDigits();\n\t\tif (nargs == 0)\n\t\t\treturn Type.createEnum(edecl, tag);\n\t\tvar args = new Array();\n\t\twhile (nargs-- > 0)\n\t\t\targs.push(unserialize());\n\t\treturn Type.createEnum(edecl, tag, args);\n\t}\n\n\t/**\n\t\tUnserializes the next part of `this` Unserializer instance and returns\n\t\tthe according value.\n\n\t\tThis function may call `this.resolver.resolveClass` to determine a\n\t\tClass from a String, and `this.resolver.resolveEnum` to determine an\n\t\tEnum from a String.\n\n\t\tIf `this` Unserializer instance contains no more or invalid data, an\n\t\texception is thrown.\n\n\t\tThis operation may fail on structurally valid data if a type cannot be\n\t\tresolved or if a field cannot be set. This can happen when unserializing\n\t\tStrings that were serialized on a different Haxe target, in which the\n\t\tserialization side has to make sure not to include platform-specific\n\t\tdata.\n\n\t\tClasses are created from `Type.createEmptyInstance`, which means their\n\t\tconstructors are not called.\n*/\n\tpublic function unserialize():Dynamic {\n\t\tswitch (get(pos++)) {\n\t\t\tcase \"n\".code:\n\t\t\t\treturn null;\n\t\t\tcase \"t\".code:\n\t\t\t\treturn true;\n\t\t\tcase \"f\".code:\n\t\t\t\treturn false;\n\t\t\tcase \"z\".code:\n\t\t\t\treturn 0;\n\t\t\tcase \"i\".code:\n\t\t\t\treturn readDigits();\n\t\t\tcase \"d\".code:\n\t\t\t\treturn readFloat();\n\t\t\tcase \"y\".code:\n\t\t\t\tvar len = readDigits();\n\t\t\t\tif (get(pos++) != \":\".code || length - pos < len)\n\t\t\t\t\tthrow \"Invalid string length\";\n\t\t\t\tvar s = buf.fastSubstr(pos, len);\n\t\t\t\tpos += len;\n\t\t\t\ts = StringTools.urlDecode(s);\n\t\t\t\tscache.push(s);\n\t\t\t\treturn s;\n\t\t\tcase \"k\".code:\n\t\t\t\treturn Math.NaN;\n\t\t\tcase \"m\".code:\n\t\t\t\treturn Math.NEGATIVE_INFINITY;\n\t\t\tcase \"p\".code:\n\t\t\t\treturn Math.POSITIVE_INFINITY;\n\t\t\tcase \"a\".code:\n\t\t\t\tvar buf = buf;\n\t\t\t\tvar a = new Array<Dynamic>();\n\t\t\t\t#if cpp\n\t\t\t\tvar cachePos = cache.length;\n\t\t\t\t#end\n\t\t\t\tcache.push(a);\n\t\t\t\twhile (true) {\n\t\t\t\t\tvar c = get(pos);\n\t\t\t\t\tif (c == \"h\".code) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == \"u\".code) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tvar n = readDigits();\n\t\t\t\t\t\ta[a.length + n - 1] = null;\n\t\t\t\t\t} else\n\t\t\t\t\t\ta.push(unserialize());\n\t\t\t\t}\n\t\t\t\t#if cpp\n\t\t\t\treturn cache[cachePos] = cpp.NativeArray.resolveVirtualArray(a);\n\t\t\t\t#else\n\t\t\t\treturn a;\n\t\t\t\t#end\n\t\t\tcase \"o\".code:\n\t\t\t\tvar o = {};\n\t\t\t\tcache.push(o);\n\t\t\t\tunserializeObject(o);\n\t\t\t\treturn o;\n\t\t\tcase \"r\".code:\n\t\t\t\tvar n = readDigits();\n\t\t\t\tif (n < 0 || n >= cache.length)\n\t\t\t\t\tthrow \"Invalid reference\";\n\t\t\t\treturn cache[n];\n\t\t\tcase \"R\".code:\n\t\t\t\tvar n = readDigits();\n\t\t\t\tif (n < 0 || n >= scache.length)\n\t\t\t\t\tthrow \"Invalid string reference\";\n\t\t\t\treturn scache[n];\n\t\t\tcase \"x\".code:\n\t\t\t\tthrow unserialize();\n\t\t\tcase \"c\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar cl = resolver.resolveClass(name);\n\t\t\t\tif (cl == null)\n\t\t\t\t\tthrow \"Class not found \" + name;\n\t\t\t\tvar o = Type.createEmptyInstance(cl);\n\t\t\t\tcache.push(o);\n\t\t\t\tunserializeObject(o);\n\t\t\t\treturn o;\n\t\t\tcase \"w\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\t\tif (edecl == null)\n\t\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\t\tvar e = unserializeEnum(edecl, unserialize());\n\t\t\t\tcache.push(e);\n\t\t\t\treturn e;\n\t\t\tcase \"j\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\t\tif (edecl == null)\n\t\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\t\tpos++; /* skip ':'"
    }
  },
  "haxe.ValueException": {
    "doc": "An exception containing arbitrary value.\n\n\tThis class is automatically used for throwing values, which don't extend `haxe.Exception`\n\tor native exception type.\n\tFor example:\n\t```haxe\n\tthrow \"Terrible error\";\n\t```\n\twill be compiled to\n\t```haxe\n\tthrow new ValueException(\"Terrible error\");\n\t```",
    "path": "haxe\\std\\haxe\\ValueException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Adler32": {
    "doc": "Calculates the Adler32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Adler32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Base64": {
    "doc": "Allows one to encode/decode String and bytes using Base64 encoding.",
    "path": "haxe\\std\\haxe\\crypto\\Base64.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.BaseCode": {
    "doc": "Allows one to encode/decode String and bytes using a power of two base dictionary.",
    "path": "haxe\\std\\haxe\\crypto\\BaseCode.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Crc32": {
    "doc": "Calculates the Crc32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Crc32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.HashMethod": {
    "doc": "Hash methods for Hmac calculation.",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Hmac": {
    "doc": "Calculates a Hmac of the given Bytes using a HashMethod.",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Md5": {
    "doc": "Creates a MD5 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Md5.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha1": {
    "doc": "Creates a Sha1 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha1.hx",
    "functions": {
      "rol": "Bitwise rotate a 32-bit number to the left",
      "ft": "Perform the appropriate triplet combination function for the current iteration",
      "kt": "Determine the appropriate additive constant for the current iteration"
    },
    "fields": {}
  },
  "haxe.crypto.Sha224": {
    "doc": "Creates a Sha224 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha224.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha256": {
    "doc": "Creates a Sha256 of a String.",
    "path": "haxe\\std\\haxe\\crypto\\Sha256.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.display.abstract": {
    "doc": "This type is already available with it's unqualified name for one of these reasons:\n\t\t  - it's a toplevel type\n\t\t  - it's imported with an `import` in the current module\n\t\t  - it's imported in an `import.hx` file\n*/\n\tvar Imported;\n\n\t/**\n\t\tThe type is currently not imported. It can be accessed either\n\t\twith its fully qualified name or by inserting an import.\n*/\n\tvar Unimported;\n\n\t/**\n\t\tA type with the same name is already imported in the module.\n\t\tThe fully qualified name has to be used to access it.\n*/\n\tvar Shadowed;\n}\n\n/* Type instance */\ntypedef JsonPackagePath = {\n\tvar pack:Array<String>;\n}\n\ntypedef JsonModulePath = JsonPackagePath & {\n\tvar moduleName:String;\n\tvar ?importStatus:ImportStatus;\n}\n\ntypedef JsonTypePath = JsonModulePath & {\n\tvar typeName:String;\n}\n\ntypedef JsonStaticFieldPath = JsonTypePath & {\n\tvar fieldName:String;\n}\n\ntypedef JsonTypePathWithParams = {\n\tvar path:JsonTypePath;\n\tvar params:JsonTypes;\n}\n\ntypedef JsonFunctionArgument = {\n\tvar name:String;\n\tvar opt:Bool;\n\tvar t:JsonType<Dynamic>;\n\tvar ?value:{\n\t\tvar string:String;\n\t};\n}\n\ntypedef JsonFunctionSignature = {\n\tvar args:Array<JsonFunctionArgument>;\n\tvar ret:JsonType<Dynamic>;\n}\n\nenum abstract JsonAnonStatusKind<T>(String) {\n\tvar AClosed;\n\tvar AOpened;\n\tvar AConst;\n\tvar AExtend:JsonAnonStatusKind<JsonTypes>;\n\tvar AClassStatics:JsonAnonStatusKind<JsonTypePath>;\n\tvar AEnumStatics:JsonAnonStatusKind<JsonTypePath>;\n\tvar AAbstractStatics:JsonAnonStatusKind<JsonTypePath>;\n}\n\ntypedef JsonAnonStatus<T> = {\n\tvar kind:JsonAnonStatusKind<T>;\n\tvar args:T;\n}\n\ntypedef JsonAnon = {\n\tvar fields:JsonClassFields;\n\tvar status:JsonAnonStatus<Dynamic>;\n}\n\nenum abstract JsonTypeKind<T>(String) {\n\tvar TMono;\n\tvar TInst:JsonTypeKind<JsonTypePathWithParams>;\n\tvar TEnum:JsonTypeKind<JsonTypePathWithParams>;\n\tvar TType:JsonTypeKind<JsonTypePathWithParams>;\n\tvar TAbstract:JsonTypeKind<JsonTypePathWithParams>;\n\tvar TFun:JsonTypeKind<JsonFunctionSignature>;\n\tvar TAnonymous:JsonTypeKind<JsonAnon>;\n\tvar TDynamic:JsonTypeKind<Null<JsonType<Dynamic>>>;\n}\n\ntypedef JsonType<T> = {\n\tvar kind:JsonTypeKind<T>;\n\tvar args:T;\n}\n\ntypedef JsonTypes = Array<JsonType<Dynamic>>;\n\n/* Type parameters */\ntypedef JsonTypeParameter = {\n\tvar name:String;\n\tvar constraints:JsonTypes;\n}\n\ntypedef JsonTypeParameters = Array<JsonTypeParameter>;\n\n/* Expr",
    "path": "haxe\\std\\haxe\\display\\JsonModuleTypes.hx",
    "functions": {},
    "fields": {
      "Unimported": "The type is currently not imported. It can be accessed either\n\t\twith its fully qualified name or by inserting an import.",
      "Shadowed": "A type with the same name is already imported in the module.\n\t\tThe fully qualified name has to be used to access it."
    }
  },
  "haxe.ds.ArraySort": {
    "doc": "ArraySort provides a stable implementation of merge sort through its `sort`\n\tmethod. It should be used instead of `Array.sort` in cases where the order\n\tof equal elements has to be retained on all targets.",
    "path": "haxe\\std\\haxe\\ds\\ArraySort.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.BalancedTree": {
    "doc": "BalancedTree allows key-value mapping with arbitrary keys, as long as they\n\tcan be ordered. By default, `Reflect.compare` is used in the `compare`\n\tmethod, which can be overridden in subclasses.\n\n\tOperations have a logarithmic average and worst-case cost.\n\n\tIteration over keys and values, using `keys` and `iterator` respectively,\n\tare in-order.",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.TreeNode": {
    "doc": "Creates a new BalancedTree, which is initially empty.\n*/\n\tpublic function new() {}\n\n\t/**\n\t\tBinds `key` to `value`.\n\n\t\tIf `key` is already bound to a value, that binding disappears.\n\n\t\tIf `key` is null, the result is unspecified.\n*/\n\tpublic function set(key:K, value:V) {\n\t\troot = setLoop(key, value, root);\n\t}\n\n\t/**\n\t\tReturns the value `key` is bound to.\n\n\t\tIf `key` is not bound to any value, `null` is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n*/\n\tpublic function get(key:K):Null<V> {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn node.value;\n\t\t\tif (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tRemoves the current binding of `key`.\n\n\t\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\t\treturned.\n\n\t\tOtherwise the binding of `key` is removed and true is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n*/\n\tpublic function remove(key:K) {\n\t\ttry {\n\t\t\troot = removeLoop(key, root);\n\t\t\treturn true;\n\t\t} catch (e:String) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t\tTells if `key` is bound to a value.\n\n\t\tThis method returns true even if `key` is bound to null.\n\n\t\tIf `key` is null, the result is unspecified.\n*/\n\tpublic function exists(key:K) {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn true;\n\t\t\telse if (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tIterates over the bound values of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n*/\n\tpublic function iterator():Iterator<V> {\n\t\tvar ret = [];\n\t\titeratorLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tSee `Map.keyValueIterator`\n*/\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\t/**\n\t\tIterates over the keys of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n*/\n\tpublic function keys():Iterator<K> {\n\t\tvar ret = [];\n\t\tkeysLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\tpublic function copy():BalancedTree<K, V> {\n\t\tvar copied = new BalancedTree<K, V>();\n\t\tcopied.root = root;\n\t\treturn copied;\n\t}\n\n\tfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\treturn new TreeNode<K, V>(null, k, v, null);\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\n\t\t\tvar nl = setLoop(k, v, node.left);\n\t\t\tbalance(nl, node.key, node.value, node.right);\n\t\t} else {\n\t\t\tvar nr = setLoop(k, v, node.right);\n\t\t\tbalance(node.left, node.key, node.value, nr);\n\t\t}\n\t}\n\n\tfunction removeLoop(k:K, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\tthrow \"Not_found\";\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) merge(node.left,\n\t\t\tnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\n\t\t\tnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n\t}\n\n\tstatic function iteratorLoop<K,V>(node:TreeNode<K, V>, acc:Array<V>) {\n\t\tif (node != null) {\n\t\t\titeratorLoop(node.left, acc);\n\t\t\tacc.push(node.value);\n\t\t\titeratorLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\n\t\tif (node != null) {\n\t\t\tkeysLoop(node.left, acc);\n\t\t\tacc.push(node.key);\n\t\t\tkeysLoop(node.right, acc);\n\t\t}\n\t}\n\n\tstatic function sizeLoop<K,V>(node:TreeNode<K, V>):Int {\n\t\tif (node != null) {\n\t\t\treturn sizeLoop(node.left) + 1 + sizeLoop(node.right);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfunction merge(t1, t2) {\n\t\tif (t1 == null)\n\t\t\treturn t2;\n\t\tif (t2 == null)\n\t\t\treturn t1;\n\t\tvar t = minBinding(t2);\n\t\treturn balance(t1, t.key, t.value, removeMinBinding(t2));\n\t}\n\n\tfunction minBinding(t:TreeNode<K, V>) {\n\t\treturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n\t}\n\n\tfunction removeMinBinding(t:TreeNode<K, V>) {\n\t\treturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n\t}\n\n\tfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\n\t\tvar hl = l.get_height();\n\t\tvar hr = r.get_height();\n\t\treturn if (hl > hr + 2) {\n\t\t\tif (l.left.get_height() >= l.right.get_height())\n\t\t\t\tnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\n\t\t\t\t\tnew TreeNode<K, V>(l.right.right, k, v, r));\n\t\t} else if (hr > hl + 2) {\n\t\t\tif (r.right.get_height() > r.left.get_height())\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\n\t\t\t\t\tnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n\t\t} else {\n\t\t\tnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n\t\t}\n\t}\n\n\tfunction compare(k1:K, k2:K) {\n\t\treturn Reflect.compare(k1, k2);\n\t}\n\n\tpublic function toString() {\n\t\treturn root == null ? \"[]\" : '[${root.toString()}]';\n\t}\n\n\t/**\n\t\tRemoves all keys from `this` BalancedTree.\n*/\n\tpublic function clear():Void {\n\t\troot = null;\n\t}\n\n\tpublic function size():Int {\n\t\treturn sizeLoop(root);\n\t}\n}\n\n/**\n\tA tree node of `haxe.ds.BalancedTree`.",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {
      "set": "Binds `key` to `value`.\n\n\t\tIf `key` is already bound to a value, that binding disappears.\n\n\t\tIf `key` is null, the result is unspecified.",
      "get": "Returns the value `key` is bound to.\n\n\t\tIf `key` is not bound to any value, `null` is returned.\n\n\t\tIf `key` is null, the result is unspecified.",
      "remove": "Removes the current binding of `key`.\n\n\t\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\t\treturned.\n\n\t\tOtherwise the binding of `key` is removed and true is returned.\n\n\t\tIf `key` is null, the result is unspecified.",
      "exists": "Tells if `key` is bound to a value.\n\n\t\tThis method returns true even if `key` is bound to null.\n\n\t\tIf `key` is null, the result is unspecified.",
      "iterator": "Iterates over the bound values of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.",
      "keys": "See `Map.keyValueIterator`\n*/\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\t/**\n\t\tIterates over the keys of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.",
      "clear": "Removes all keys from `this` BalancedTree."
    },
    "fields": {}
  },
  "haxe.ds.Either": {
    "doc": "Either represents values which are either of type `L` (Left) or type `R`\n\t(Right).",
    "path": "haxe\\std\\haxe\\ds\\Either.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.EnumValueMap": {
    "doc": "EnumValueMap allows mapping of enum value keys to arbitrary values.\n\n\tKeys are compared by value and recursively over their parameters. If any\n\tparameter is not an enum value, `Reflect.compare` is used to compare them.",
    "path": "haxe\\std\\haxe\\ds\\EnumValueMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.HashMap": {
    "doc": "HashMap allows mapping of hashable objects to arbitrary values.\n\n\tSee `Map` for documentation details.\n\n\t@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\HashMap.hx",
    "functions": {
      "exists": "See `Map.set`\n*/\n\t@:arrayAccess public inline function set(k:K, v:V) {\n\t\tthis.keys.set(k.hashCode(), k);\n\t\tthis.values.set(k.hashCode(), v);\n\t}\n\n\t/**\n\t\tSee `Map.get`\n*/\n\t@:arrayAccess public inline function get(k:K) {\n\t\treturn this.values.get(k.hashCode());\n\t}\n\n\t/**\n\t\tSee `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`",
      "copy": "See `Map.copy`",
      "iterator": "See `Map.iterator`",
      "keyValueIterator": "See `Map.keyValueIterator`",
      "clear": "See `Map.clear`",
      "size": "See `Map.size`"
    },
    "fields": {}
  },
  "haxe.ds.IntMap": {
    "doc": "IntMap allows mapping of Int keys to arbitrary values.\n\n\tSee `Map` for documentation details.\n\n\t@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\IntMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n\t#if eval\n\t@:runtime inline function keyValueIterator():KeyValueIterator<Int, T> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\t#else\n\tfunction keyValueIterator():KeyValueIterator<Int, T>;\n\t#end\n\n\t/**\n\t\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.List": {
    "doc": "A linked-list of elements. The list is composed of element container objects\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole list content every time.\n\n\t@see https://haxe.org/manual/std-List.html",
    "path": "haxe\\std\\haxe\\ds\\List.hx",
    "functions": {
      "add": "Adds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.",
      "push": "Adds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.",
      "first": "Returns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.",
      "last": "Returns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.",
      "pop": "Returns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.",
      "isEmpty": "Tells if `this` List is empty.",
      "clear": "Empties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.",
      "remove": "Removes the first occurrence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.",
      "iterator": "Returns an iterator on the elements of the list.",
      "toString": "Returns an iterator of the List indices and values.\n*/\n\t@:pure @:runtime public inline function keyValueIterator():ListKeyValueIterator<T> {\n\t\treturn new ListKeyValueIterator(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.",
      "join": "Returns a string representation of `this` List, with `sep` separating\n\t\teach element.",
      "filter": "Returns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.",
      "map": "Returns a new list where all elements have been converted by the\n\t\tfunction `f`."
    },
    "fields": {}
  },
  "haxe.ds.ListSort": {
    "doc": "ListSort provides a stable implementation of merge sort through its `sort`\n\tmethod. It has a O(N.log(N)) complexity and does not require additional memory allocation.",
    "path": "haxe\\std\\haxe\\ds\\ListSort.hx",
    "functions": {
      "sortSingleLinked": "Same as `sort` but on single linked list."
    },
    "fields": {}
  },
  "haxe.ds.ObjectMap": {
    "doc": "ObjectMap allows mapping of object keys to arbitrary values.\n\n\tOn static targets, the keys are considered to be strong references. Refer\n\tto `haxe.ds.WeakMap` for a weak reference version.\n\n\tSee `Map` for documentation details.\n\n\t@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\ObjectMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n\t#if eval\n\t@:runtime inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\t#else\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n\t#end\n\n\t/**\n\t\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.Option": {
    "doc": "An Option is a wrapper type which can either have a value (Some) or not a\n\tvalue (None).\n\n\t@see https://haxe.org/manual/std-Option.html",
    "path": "haxe\\std\\haxe\\ds\\Option.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.StringMap": {
    "doc": "StringMap allows mapping of String keys to arbitrary values.\n\n\tSee `Map` for documentation details.\n\n\t@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\StringMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "iterator": "See `Map.iterator`\n\n\t\t(java) Implementation detail: Do not `set()` any new value while\n\t\titerating, as it may cause a resize, which will break iteration.",
      "copy": "See `Map.keyValueIterator`\n*/\n\t#if eval\n\t@:runtime inline function keyValueIterator():KeyValueIterator<String, T> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\t#else\n\tfunction keyValueIterator():KeyValueIterator<String, T>;\n\t#end\n\n\t/**\n\t\tSee `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`"
    },
    "fields": {}
  },
  "haxe.ds.Vector": {
    "doc": "A Vector is a storage of fixed size. It can be faster than Array on some\n\ttargets, and is never slower.\n\n\t@see https://haxe.org/manual/std-vector.html",
    "path": "haxe\\std\\haxe\\ds\\Vector.hx",
    "functions": {
      "toData": "Copies `length` of elements from `src` Vector, beginning at `srcPos` to\n\t\t`dest` Vector, beginning at `destPos`\n\n\t\tThe results are unspecified if `length` results in out-of-bounds access,\n\t\tor if `src` or `dest` are null\n*/\n\tpublic static #if (java || neko || cpp || eval) inline #end function blit<T>(src:Vector<T>, srcPos:Int, dest:Vector<T>, destPos:Int, len:Int):Void {\n\t\t#if neko\n\t\tuntyped __dollar__ablit(dest, destPos, src, srcPos, len);\n\t\t#elseif java\n\t\tjava.lang.System.arraycopy(src, srcPos, dest, destPos, len);\n\t\t#elseif cpp\n\t\tdest.toData().blit(destPos, src.toData(), srcPos, len);\n\t\t#elseif eval\n\t\tsrc.toData().blit(srcPos, dest.toData(), destPos, len);\n\t\t#else\n\t\tif (src == dest) {\n\t\t\tif (srcPos < destPos) {\n\t\t\t\tvar i = srcPos + len;\n\t\t\t\tvar j = destPos + len;\n\t\t\t\tfor (k in 0...len) {\n\t\t\t\t\ti--;\n\t\t\t\t\tj--;\n\t\t\t\t\tsrc[j] = src[i];\n\t\t\t\t}\n\t\t\t} else if (srcPos > destPos) {\n\t\t\t\tvar i = srcPos;\n\t\t\t\tvar j = destPos;\n\t\t\t\tfor (k in 0...len) {\n\t\t\t\t\tsrc[j] = src[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i in 0...len) {\n\t\t\t\tdest[destPos + i] = src[srcPos + i];\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tCreates a new Array, copy the content from the Vector to it, and returns it.\n*/\n\tpublic #if (flash || cpp || js || java || eval) inline #end function toArray():Array<T> {\n\t\t#if cpp\n\t\treturn this.copy();\n\t\t#elseif python\n\t\treturn this.copy();\n\t\t#elseif js\n\t\treturn this.slice(0);\n\t\t#elseif eval\n\t\treturn this.toArray();\n\t\t#else\n\t\tvar a = new Array();\n\t\tvar len = length;\n\t\t#if (neko)\n\t\t// prealloc good size\n\t\tif (len > 0)\n\t\t\ta[len - 1] = get(0);\n\t\t#end\n\t\tfor (i in 0...len)\n\t\t\ta[i] = get(i);\n\t\treturn a;\n\t\t#end\n\t}\n\n\t/**\n\t\tExtracts the data of `this` Vector.\n\n\t\tThis returns the internal representation type.",
      "fromData": "Initializes a new Vector from `data`.\n\n\t\tSince `data` is the internal representation of Vector, this is a no-op.\n\n\t\tIf `data` is null, the corresponding Vector is also `null`.",
      "fromArrayCopy": "Creates a new Vector by copying the elements of `array`.\n\n\t\tThis always creates a copy, even on platforms where the internal\n\t\trepresentation is Array.\n\n\t\tThe elements are not copied and retain their identity, so\n\t\t`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.\n\n\t\tIf `array` is null, the result is unspecified.",
      "sort": "Returns a shallow copy of `this` Vector.\n\n\t\tThe elements are not copied and retain their identity, so\n\t\t`a[i] == a.copy()[i]` is true for any valid `i`. However,\n\t\t`a == a.copy()` is always false.\n*/\n\textern public inline function copy<T>():Vector<T> {\n\t\t#if eval\n\t\treturn fromData(this.copy());\n\t\t#else\n\t\tvar r = new Vector<T>(length);\n\t\tVector.blit(cast this, 0, r, 0, length);\n\t\treturn r;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` Vector, with `sep` separating\n\t\teach element.\n\n\t\tThe result of this operation is equal to `Std.string(this[0]) + sep +\n\t\tStd.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`\n\n\t\tIf `this` Vector has length 0, the result is the empty String `\"\"`.\n\t\tIf `this` has exactly one element, the result is equal to a call to\n\t\t`Std.string(this[0])`.\n\n\t\tIf `sep` is null, the result is unspecified.\n*/\n\textern public inline function join<T>(sep:String):String {\n\t\t#if (flash10 || cpp || eval)\n\t\treturn this.join(sep);\n\t\t#else\n\t\tvar b = new StringBuf();\n\t\tvar len = length;\n\t\tfor (i in 0...len) {\n\t\t\tb.add(Std.string(get(i)));\n\t\t\tif (i < len - 1) {\n\t\t\t\tb.add(sep);\n\t\t\t}\n\t\t}\n\t\treturn b.toString();\n\t\t#end\n\t}\n\n\t/**\n\t\tCreates a new Vector by applying function `f` to all elements of `this`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n*/\n\textern public inline function map<S>(f:T->S):Vector<S> {\n\t\t#if eval\n\t\treturn fromData(this.map(f));\n\t\t#else\n\t\tvar length = length;\n\t\tvar r = new Vector<S>(length);\n\t\tvar len = length;\n\t\tfor (i in 0...len) {\n\t\t\tvar v = f(get(i));\n\t\t\tr.set(i, v);\n\t\t}\n\t\treturn r;\n\t\t#end\n\t}\n\n\t/**\n\t\tSorts `this` Vector according to the comparison function `f`, where\n\t\t`f(x,y)` returns 0 if x == y, a positive Int if x > y and a\n\t\tnegative Int if x < y.\n\n\t\tThis operation modifies `this` Vector in place.\n\n\t\tThe sort operation is not guaranteed to be stable, which means that the\n\t\torder of equal elements may not be retained.\n\n\t\tIf `f` is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.ds.WeakMap": {
    "doc": "WeakMap allows mapping of object keys to arbitrary values.\n\n\tThe keys are considered to be weak references on static targets.\n\n\tSee `Map` for documentation details.\n\n\t@see https://haxe.org/manual/std-Map.html",
    "path": "haxe\\std\\haxe\\ds\\WeakMap.hx",
    "functions": {
      "set": "See `Map.set`",
      "get": "See `Map.get`",
      "exists": "See `Map.exists`",
      "remove": "See `Map.remove`",
      "keys": "See `Map.keys`",
      "iterator": "See `Map.iterator`",
      "keyValueIterator": "See `Map.keyValueIterator`",
      "copy": "See `Map.copy`",
      "toString": "See `Map.toString`",
      "clear": "See `Map.clear`",
      "size": "See `Map.size`"
    },
    "fields": {}
  },
  "haxe.exceptions.ArgumentException": {
    "doc": "An exception that is thrown when an invalid value provided for an argument of a function.",
    "path": "haxe\\std\\haxe\\exceptions\\ArgumentException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.NotImplementedException": {
    "doc": "An exception that is thrown when requested function or operation does not have an implementation.",
    "path": "haxe\\std\\haxe\\exceptions\\NotImplementedException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.PosException": {
    "doc": "An exception that carry position information of a place where it was created.",
    "path": "haxe\\std\\haxe\\exceptions\\PosException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonParser": {
    "doc": "An implementation of JSON parser in Haxe.\n\n\tThis class is used by `haxe.Json` when native JSON implementation\n\tis not available.\n\n\t@see https://haxe.org/manual/std-Json-parsing.html",
    "path": "haxe\\std\\lua\\_std\\haxe\\format\\JsonParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonPrinter": {
    "doc": "An implementation of JSON printer in Haxe.\n\n\tThis class is used by `haxe.Json` when native JSON implementation\n\tis not available.\n\n\t@see https://haxe.org/manual/std-Json-encoding.html",
    "path": "haxe\\std\\haxe\\format\\JsonPrinter.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.http.HttpBase": {
    "doc": "This class can be used to handle Http requests consistently across\n\tplatforms. There are two intended usages:\n\n\t- call `haxe.Http.requestUrl(url)` and receive the result as a `String`\n\t(only available on `sys` targets)\n\t- create a `new haxe.Http(url)`, register your callbacks for `onData`,\n\t`onError` and `onStatus`, then call `request()`.",
    "path": "haxe\\std\\haxe\\http\\HttpBase.hx",
    "functions": {
      "setHeader": "Sets the header identified as `name` to value `value`.\n\n\t\tIf `name` or `value` are null, the result is unspecified.\n\n\t\tThis method provides a fluent interface.",
      "setParameter": "Sets the parameter identified as `name` to value `value`.\n\n\t\tIf `name` or `value` are null, the result is unspecified.\n\n\t\tThis method provides a fluent interface.",
      "setPostData": "Sets the post data of `this` Http request to `data` string.\n\n\t\tThere can only be one post data per request. Subsequent calls to\n\t\tthis method or to `setPostBytes()` overwrite the previously set value.\n\n\t\tIf `data` is null, the post data is considered to be absent.\n\n\t\tThis method provides a fluent interface.",
      "setPostBytes": "Sets the post data of `this` Http request to `data` bytes.\n\n\t\tThere can only be one post data per request. Subsequent calls to\n\t\tthis method or to `setPostData()` overwrite the previously set value.\n\n\t\tIf `data` is null, the post data is considered to be absent.\n\n\t\tThis method provides a fluent interface.",
      "request": "Sends `this` Http request to the Url specified by `this.url`.\n\n\t\tIf `post` is true, the request is sent as POST request, otherwise it is\n\t\tsent as GET request.\n\n\t\tDepending on the outcome of the request, this method calls the\n\t\t`onStatus()`, `onError()`, `onData()` or `onBytes()` callback functions.\n\n\t\tIf `this.url` is null, the result is unspecified.\n\n\t\tIf `this.url` is an invalid or inaccessible Url, the `onError()` callback\n\t\tfunction is called.\n\n\t\t[js] If `this.async` is false, the callback functions are called before\n\t\tthis method returns.",
      "hasOnData": "This method is called upon a successful request, with `data` containing\n\t\tthe result String.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onData = function(data) { // handle result }`\n*/\n\tpublic dynamic function onData(data:String) {}\n\n\t/**\n\t\tThis method is called upon a successful request, with `data` containing\n\t\tthe result String.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onBytes = function(data) { // handle result }`\n*/\n\tpublic dynamic function onBytes(data:Bytes) {}\n\n\t/**\n\t\tThis method is called upon a request error, with `msg` containing the\n\t\terror description.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onError = function(msg) { // handle error }`\n*/\n\tpublic dynamic function onError(msg:String) {}\n\n\t/**\n\t\tThis method is called upon a Http status change, with `status` being the\n\t\tnew status.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onStatus = function(status) { // handle status }`\n*/\n\tpublic dynamic function onStatus(status:Int) {}\n\n\t/**\n\t\tOverride this if extending `haxe.Http` with overriding `onData`"
    },
    "fields": {}
  },
  "haxe.http.abstract": {
    "doc": "HTTP Request Status",
    "path": "haxe\\std\\haxe\\http\\HttpStatus.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Encoding": {
    "doc": "String binary encoding supported by Haxe I/O",
    "path": "haxe\\std\\haxe\\io\\Encoding.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Eof": {
    "doc": "This exception is raised when reading while data is no longer available in the `haxe.io.Input`.",
    "path": "haxe\\std\\haxe\\io\\Eof.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.FPHelper": {
    "doc": "Helper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.",
    "path": "haxe\\std\\haxe\\io\\FPHelper.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.class": {
    "doc": "An Output is an abstract write. A specific output implementation will only\n\thave to override the `writeByte` and maybe the `write`, `flush` and `close`\n\tmethods. See `File.write` and `String.write` for two ways of creating an\n\tOutput.",
    "path": "haxe\\std\\haxe\\io\\Output.hx",
    "functions": {
      "writeBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tReturns the actual length of written data that can differ from `len`.\n\n\t\tSee `writeFullBytes` that tries to write the exact amount of specified bytes.",
      "flush": "Flush any buffered data.",
      "close": "Close the output.\n\n\t\tBehaviour while writing after calling this method is unspecified.",
      "write": "Write all bytes stored in `s`.",
      "writeFullBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.",
      "writeFloat": "Write `x` as 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeDouble": "Write `x` as 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeInt8": "Write `x` as 8-bit signed integer.",
      "writeInt16": "Write `x` as 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeUInt16": "Write `x` as 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeInt24": "Write `x` as 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeUInt24": "Write `x` as 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "writeInt32": "Write `x` as 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.",
      "prepare": "Inform that we are about to write at least `nbytes` bytes.\n\n\t\tThe underlying implementation can allocate proper working space depending\n\t\ton this information, or simply ignore it. This is not a mandatory call\n\t\tbut a tip and is only used in some specific cases.",
      "writeInput": "Read all available data from `i` and write it.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read and written. Its default value is 4096.",
      "writeString": "Write `s` string."
    },
    "fields": {}
  },
  "haxe.io.abstract": {
    "doc": "A scheme consists of a sequence of characters beginning with a letter and followed\n\tby any combination of letters, digits, plus (`+`, period (`.`), or hyphen (`-`).\n\n\tAlthough schemes are case-insensitive, the canonical form is lowercase\n\tand documents that specify schemes must do so with lowercase letters.\n\tIt is followed by a colon (`:`).",
    "path": "haxe\\std\\haxe\\io\\Scheme.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Path": {
    "doc": "This class provides a convenient way of working with paths. It supports the\n\tcommon path formats:\n\n\t- `directory1/directory2/filename.extension`\n\t- `directory1\\directory2\\filename.extension`",
    "path": "haxe\\std\\haxe\\io\\Path.hx",
    "functions": {
      "toString": "Returns a String representation of `this` path.\n\n\t\tIf `this.backslash` is `true`, backslash is used as directory separator,\n\t\totherwise slash is used. This only affects the separator between\n\t\t`this.dir` and `this.file`.\n\n\t\tIf `this.directory` or `this.extension` is `null`, their representation\n\t\tis the empty String `\"\"`.",
      "withoutExtension": "Returns the String representation of `path` without the file extension.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "withoutDirectory": "Returns the String representation of `path` without the directory.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "directory": "Returns the directory of `path`.\n\n\t\tIf the directory is `null`, the empty String `\"\"` is returned.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "extension": "Returns the extension of `path`.\n\n\t\tIf `path` has no extension, the empty String `\"\"` is returned.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "withExtension": "Returns a String representation of `path` where the extension is `ext`.\n\n\t\tIf `path` has no extension, `ext` is added as extension.\n\n\t\tIf `path` or `ext` are `null`, the result is unspecified.",
      "join": "Joins all paths in `paths` together.\n\n\t\tIf `paths` is empty, the empty String `\"\"` is returned. Otherwise the\n\t\tpaths are joined with a slash between them.\n\n\t\tIf `paths` is `null`, the result is unspecified.",
      "normalize": "Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).\n\n\t\tAlso replaces backslashes `\\` with slashes `/` and afterwards turns\n\t\tmultiple slashes into a single one.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "addTrailingSlash": "Adds a trailing slash to `path`, if it does not have one already.\n\n\t\tIf the last slash in `path` is a backslash, a backslash is appended to\n\t\t`path`.\n\n\t\tIf the last slash in `path` is a slash, or if no slash is found, a slash\n\t\tis appended to `path`. In particular, this applies to the empty String\n\t\t`\"\"`.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "removeTrailingSlashes": "Removes trailing slashes from `path`.\n\n\t\tIf `path` does not end with a `/` or `\\`, `path` is returned unchanged.\n\n\t\tOtherwise the substring of `path` excluding the trailing slashes or\n\t\tbackslashes is returned.\n\n\t\tIf `path` is `null`, the result is unspecified.",
      "isAbsolute": "Returns `true` if the path is an absolute path, and `false` otherwise."
    },
    "fields": {
      "file": "The file name.\n\n\t\tThis is the part of the part between the directory and the extension.\n\n\t\tIf there is no file name, e.g. for `\".htaccess\"` or `\"/dir/\"`, the value\n\t\tis the empty String `\"\"`.",
      "ext": "The file extension.\n\n\t\tIt is separated from the file name by a dot. This dot is not part of\n\t\tthe extension.\n\n\t\tIf the path has no extension, the value is `null`.",
      "backslash": "`true` if the last directory separator is a backslash, `false` otherwise."
    }
  },
  "haxe.iterators.ArrayIterator": {
    "doc": "This iterator is used only when `Array<T>` is passed to `Iterable<T>`",
    "path": "haxe\\std\\haxe\\iterators\\ArrayIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessIterator": {
    "doc": "This iterator can be used to iterate over the values of `haxe.DynamicAccess`.",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessIterator.hx",
    "functions": {
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessKeyValueIterator": {
    "doc": "This Key/Value iterator can be used to iterate over `haxe.DynamicAccess`.",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessKeyValueIterator.hx",
    "functions": {
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringIterator": {
    "doc": "This iterator can be used to iterate over char codes in a string.\n\n\tNote that char codes may differ across platforms because of different\n\tinternal encoding of strings in different of runtimes.",
    "path": "haxe\\std\\haxe\\iterators\\StringIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\n\tway. It handles surrogate pairs on platforms that require it. On each\n\titeration, it returns the next character code.\n\n\tNote that this has different semantics than a standard for-loop over the\n\tString's length due to the fact that it deals with surrogate pairs.",
    "path": "haxe\\std\\haxe\\iterators\\StringIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`",
      "unicodeIterator": "Convenience function which can be used as a static extension."
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIterator": {
    "doc": "This iterator can be used to iterate over char indexes and char codes in a string.\n\n\tNote that char codes may differ across platforms because of different\n\tinternal encoding of strings in different runtimes.",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIterator.hx",
    "functions": {
      "hasNext": "See `KeyValueIterator.hasNext`",
      "next": "See `KeyValueIterator.next`"
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\n\tway. It handles surrogate pairs on platforms that require it. On each\n\titeration, it returns the next character offset as key and the next\n\tcharacter code as value.\n\n\tNote that in the general case, because of surrogate pairs, the key values\n\tshould not be used as offsets for various String API operations. For the\n\tsame reason, the last key value returned might be less than `s.length - 1`.",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`",
      "next": "See `Iterator.next`",
      "unicodeKeyValueIterator": "Convenience function which can be used as a static extension."
    },
    "fields": {}
  },
  "haxe.macro.CompilationServer": {
    "doc": "Disables file modification checks, avoiding some filesystem operations.\n*/\n\tvar NoFileSystemCheck = 0;\n\n\t/**\n\t\tDefault behavior: check last modification time.\n*/\n\tvar CheckFileModificationTime = 1;\n\n\t/**\n\t\tIf a file is modified, also checks if its content changed. This check\n\t\tis not free, but useful when .hx files are auto-generated.\n*/\n\tvar CheckFileContentModification = 2;\n}\n\ntypedef CompilationStats = {\n\tvar filesParsed:Int;\n\tvar modulesTyped:Int;\n\tvar modulesRestoredFromHxb:Int;\n\tvar classesBuilt:Int;\n\tvar methodsTyped:Int;\n\tvar macrosCalled:Int;\n}\n\n/**\n\tThis class provides some methods which can be invoked from command line using\n\t`--macro server.field(args)`.",
    "path": "haxe\\std\\haxe\\macro\\CompilationServer.hx",
    "functions": {
      "invalidateModule": "Invalidates a module, removing it from the cache.\n\n\t\tIf the module has already been loaded in current context, a\n\t\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\t\tcaught using `try ... catch`.",
      "invalidateFiles": "Invalidates all files given in `filePaths`, removing them from the cache.",
      "getStats": "Get current compilation server stats counters.\n\n\t\tCan be called at different compilation stages, or even in the middle of\n\t\ta macro execution.\n\n\t\tCounters are reset at the beginning of each request."
    },
    "fields": {
      "CheckFileModificationTime": "Default behavior: check last modification time.",
      "CheckFileContentModification": "If a file is modified, also checks if its content changed. This check\n\t\tis not free, but useful when .hx files are auto-generated."
    }
  },
  "haxe.macro.Compiler": {
    "doc": "All these methods can be called for compiler configuration macros.",
    "path": "haxe\\std\\haxe\\macro\\Compiler.hx",
    "functions": {
      "define": "Set a conditional compiler flag.\n\n\t\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "addClassPath": "Add a class path where \".hx\" source files or packages (sub-directories) can be found.\n\n\t\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "getConfiguration": "Returns all the configuration settings applied to the compiler.\n\n\t\tUsage of this function outside a macro context returns `null`.",
      "setPlatformConfiguration": "Sets the target configuration.\n\n\t\tUsage of this function outside a macro context does nothing.",
      "addNativeLib": "Adds a native library depending on the platform (e.g. `-swf-lib` for Flash).\n\n\t\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.",
      "include": "Includes all modules in package `pack` in the compilation.\n\n\t\tIn order to include single modules, their paths can be listed directly\n\t\ton command line: `haxe ... ModuleName pack.ModuleName`.\n\n\t\tBy default `Compiler.include` will search for modules in the directories defined with `-cp`.\n\t\tIf you want to specify a different set of paths to search for modules, you can use the optional\n\t\targument `classPath`.\n\n\t\tUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n\n\t\t@param pack The package dot-path as String. Use `''` to include the root package.\n\t\t@param rec If true, recursively adds all sub-packages.\n\t\t@param ignore Array of module names to ignore for inclusion.\n\t\t\t   You can use `module*` with a * at the end for Wildcard matching\n\t\t@param classPaths An alternative array of paths (directory names) to use to search for modules to include.\n\t\t\t   Note that if you pass this argument, only the specified paths will be used for inclusion.\n\t\t@param strict If true and given package wasn't found in any of class paths, fail with an error.",
      "excludeBaseType": "Exclude a class or an enum without changing it to `@:nativeGen`.",
      "exclude": "Exclude a specific class, enum, or all classes and enums in a\n\t\tpackage from being generated. Excluded types become `extern`.\n\n\t\t@param pack The package dot-path as String. Use `''` to exclude the root package.\n\t\t@param rec If true, recursively excludes all sub-packages.",
      "excludeFile": "Exclude classes and enums listed in an extern file (one per line) from being generated.",
      "keep": "Marks types or packages to be kept by DCE.\n\n\t\tThis also extends to the sub-types of resolved modules.\n\n\t\tIn order to include module sub-types directly, their full dot path\n\t\tincluding the containing module has to be used\n\t\t(e.g. `msignal.Signal.Signal0`).\n\n\t\tThis operation has no effect if the type has already been loaded, e.g.\n\t\tthrough `Context.getType`.\n\n\t\t@param path A package, module or sub-type dot path to keep.\n\t\t@param paths An Array of package, module or sub-type dot paths to keep.\n\t\t@param recursive If true, recurses into sub-packages for package paths.",
      "nullSafety": "Enables null safety for a type or a package.\n\n\t\t@param path A package, module or sub-type dot path to enable null safety for.\n\t\t@param recursive If true, recurses into sub-packages for package paths.",
      "addGlobalMetadata": "Adds metadata `meta` to all types (if `toTypes = true`) or fields (if\n\t\t`toFields = true`) whose dot-path matches `pathFilter`.\n\n\t\tIf `recursive` is true a dot-path is considered matched if it starts\n\t\twith `pathFilter`. This automatically applies to path filters of\n\t\tpackages. Otherwise an exact match is required.\n\n\t\tIf `pathFilter` is the empty String `\"\"` it matches everything (if\n\t\t`recursive = true`) or only top-level types (if `recursive = false`).\n\n\t\tThis operation has no effect if the type has already been loaded, e.g.\n\t\tthrough `Context.getType`.",
      "registerMetadataDescriptionFile": "Reference a json file describing user-defined metadata\n\t\tSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/meta.json",
      "registerDefinesDescriptionFile": "Reference a json file describing user-defined defines\n\t\tSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/define.json",
      "registerCustomMetadata": "Register a custom metadata for documentation and completion purposes",
      "registerCustomDefine": "Register a custom define for documentation purposes",
      "setCustomJSGenerator": "Change the default JS output by using a custom generator callback",
      "flushDiskCache": "Clears cached results of file lookups",
      "getHxbWriterConfiguration": "Gets the current hxb writer configuration, if any.",
      "setHxbWriterConfiguration": "Sets the hxb writer configuration to `config`. If no hxb writer configuration\n\t\texists, it is created.\n\n\t\tThe intended usage is\n\n\t\t```\n\t\tvar config = Compiler.getHxbWriterConfiguration();\n\t\tconfig.archivePath = \"newPath.zip\";\n\t\t// Other changes\n\t\tCompiler.setHxbWriterConfiguration(config);\n\t\t```\n\n\t\tIf `config` is `null`, hxb writing is disabled.\n\n\t\t@see haxe.hxb.WriterConfig"
    },
    "fields": {
      "Closure": "Prepend the file content to the body of the top-level closure.\n\n\t\tSince the closure is in strict-mode, there may be run-time error if the input is not strict-mode-compatible.",
      "Inline": "Directly inject the file content at the call site.",
      "Off": "Disable null safety.",
      "Loose": "Loose safety.\n\t\tIf an expression is checked `!= null`, then it's considered safe even if it could be modified after the check.\n\t\tE.g.\n\t\t```haxe\n\t\tfunction example(o:{field:Null<String>}) {\n\t\t\tif(o.field != null) {\n\t\t\t\tmutate(o);\n\t\t\t\tvar notNullable:String = o.field; //no error\n\t\t\t}\n\t\t}\n\n\t\tfunction mutate(o:{field:Null<String>}) {\n\t\t\to.field = null;\n\t\t}\n\t\t```",
      "Strict": "Full scale null safety.\n\t\tIf a field is checked `!= null` it stays safe until a call is made or any field of any object is reassigned,\n\t\tbecause that could potentially alter an object of the checked field.\n\t\tE.g.\n\t\t```haxe\n\t\tfunction example(o:{field:Null<String>}, b:{o:{field:Null<String>}}) {\n\t\t\tif(o.field != null) {\n\t\t\t\tvar notNullable:String = o.field; //no error\n\t\t\t\tsomeCall();\n\t\t\t\tvar notNullable:String = o.field; // Error!\n\t\t\t}\n\t\t\tif(o.field != null) {\n\t\t\t\tvar notNullable:String = o.field; //no error\n\t\t\t\tb.o = {field:null};\n\t\t\t\tvar notNullable:String = o.field; // Error!\n\t\t\t}\n\t\t}\n\t\t```",
      "StrictThreaded": "Full scale null safety for a multi-threaded environment.\n\t\tWith this mode checking a field `!= null` does not make it safe, because it could be changed from another thread\n\t\tat the same time or immediately after the check.\n\t\tThe only nullable thing could be safe are local variables."
    }
  },
  "haxe.macro.ComplexTypeTools": {
    "doc": "This class provides some utility methods to work with AST-level types. It is\n\tbest used through `using haxe.macro.ComplexTypeTools` syntax and then provides\n\tadditional methods on `haxe.macro.ComplexType` instances.",
    "path": "haxe\\std\\haxe\\macro\\ComplexTypeTools.hx",
    "functions": {
      "toType": "Returns a type corresponding to `c`.\n\n\t\tIf `c` is null, the result is null."
    },
    "fields": {}
  },
  "haxe.macro.Context": {
    "doc": "Context provides an API for macro programming.\n\n\tIt contains common functions that interact with the macro interpreter to\n\tquery or set information. Other API functions are available in the tools\n\tclasses:\n\n\t- `haxe.macro.ComplexTypeTools`\n\t- `haxe.macro.ExprTools`\n\t- `haxe.macro.TypeTools`",
    "path": "haxe\\std\\haxe\\macro\\Context.hx",
    "functions": {
      "fatalError": "Displays a compilation error `msg` at the given `Position` `pos`\n\t\tand aborts the compilation.",
      "reportError": "Displays a compilation error `msg` at the given `Position` `pos`\n\t\twithout aborting the current macro call.",
      "warning": "Displays a compilation warning `msg` at the given `Position` `pos`.",
      "info": "Displays a compilation info `msg` at the given `Position` `pos`.",
      "getMessages": "Gets a list of all current compilation info/warning messages.",
      "filterMessages": "Filters all current info/warning messages. Filtered out messages will\n\t\tnot be displayed by the compiler.",
      "initMacrosDone": "Check if compiler is past initializations macros or not.\n\t\tWhen it is, configuration phase is over and parsing/typing can start.",
      "resolvePath": "Resolves a file name `file` based on the current class paths.\n\n\t\tThe resolution follows the usual class path rules where the last\n\t\tdeclared class path has priority.\n\n\t\tIf a class path was declared relative, this method returns the relative\n\t\tfile path. Otherwise it returns the absolute file path.\n\n\t\tIf no type can be found, an exception of type `String` is thrown.",
      "getClassPath": "Returns an `Array` of current class paths in the order of their\n\t\tdeclaration.\n\n\t\tModifying the returned array has no effect on the compiler. Class paths\n\t\tcan be added using `haxe.macro.Compiler.addClassPath`.",
      "containsDisplayPosition": "Check if current display position is within `pos`.",
      "currentPos": "Returns the position at which the macro was called.",
      "getMacroStack": "Get the call stack (excluding the call to `Context.getMacroStack()`\n\t\tthat led to current macro.",
      "getExpectedType": "Returns the type which is expected at the place the macro is called.\n\n\t\tThis affects usages such as `var x:Int = macroCall()`, where the\n\t\texpected type will be reported as `Int`.\n\n\t\tMight return `null` if no specific type is expected or if the calling\n\t\tmacro is not an expression-macro.",
      "getCallArguments": "Returns the call arguments that lead to the invocation of the current\n\t\t`@:genericBuild` macro, if available.\n\n\t\tReturns `null` if the current macro is not a `@:genericBuild` macro.",
      "getLocalClass": "Returns the current class in which the macro was called.\n\n\t\tIf no such class exists, `null` is returned.",
      "getLocalModule": "Returns the current module path in/on which the macro was called.",
      "getLocalType": "Returns the current type in/on which the macro was called.\n\n\t\tIf no such type exists, `null` is returned.",
      "getLocalMethod": "Returns the name of the method from which the macro was called.\n\n\t\tIf no such method exists, `null` is returned.",
      "getLocalUsing": "Returns an `Array` of classes which are available for `using` usage in\n\t\tthe context the macro was called.\n\n\t\tModifying the returned array has no effect on the compiler.",
      "getLocalImports": "Returns an `Array` of all imports in the context the macro was called.\n\n\t\tModifying the returned array has no effect on the compiler.",
      "getLocalVars": "Returns a map of local variables accessible in the context the macro was\n\t\tcalled.\n\n\t\tThe keys of the returned map are the variable names, the values are\n\t\ttheir types.\n\n\t\tModifying the returned map has no effect on the compiler.",
      "getLocalTVars": "Similar to `getLocalVars`, but returns elements of type `TVar` instead\n\t\tof `Type`.",
      "defined": "Tells if the conditional compilation flag `s` has been set.\n\n\t\tCompiler flags are set using the `-D` command line parameter, or\n\t\tby calling `haxe.macro.Compiler.define`.\n\n\t\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "definedValue": "Returns the value defined for the conditional compilation flag `key`.\n\n\t\tIf no value is defined for `key`, `null` is returned.\n\n\t\tCompiler flags values are set using the `-D key=value` command line\n\t\tparameter, or by calling `haxe.macro.Compiler.define`.\n\n\t\tThe default value is `\"1\"`.\n\n\t\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "getDefines": "Returns a map of all conditional compilation flags that have been set.\n\n\t\tCompiler flags are set using the `-D` command line parameter, or\n\t\tby calling `haxe.macro.Compiler.define`.\n\n\t\tModifying the returned map has no effect on the compiler.\n\n\t\t@see https://haxe.org/manual/lf-condition-compilation.html",
      "getType": "Resolves a type identified by `name`.\n\n\t\tThe resolution follows the usual class path rules where the last\n\t\tdeclared class path has priority.\n\n\t\tIf no type can be found, an exception of type `String` is thrown.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "getModule": "Resolves a module identified by `name` and returns an `Array` of all\n\t\tits contained types.\n\n\t\tThe resolution follows the usual class path rules where the last\n\t\tdeclared class path has priority.\n\n\t\tIf no module can be found, an exception of type `String` is thrown.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "getMainExpr": "Returns the typed expression of the call to the main function.\n\n\t\tThis function will only work in the generation phase. Any calls\n\t\tmade outside a function passed to `haxe.macro.Context.onGenerate`\n\t\tor `haxe.macro.Context.onAfterGenerate` will return `null`.",
      "getAllModuleTypes": "Returns an array of module types to be generated in the output.\n\n\t\tThis list may change depending on the phase of compilation and\n\t\tshould not be treated as conclusive until the generation phase.\n\n\t\tModifying the returned array has no effect on the compilation.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "parse": "Parses `expr` as Haxe code, returning the corresponding AST.\n\n\t\tString interpolation of single quote strings within `expr` is not\n\t\tsupported.\n\n\t\tThe provided `Position` `pos` is used for all generated inner AST nodes.",
      "parseInlineString": "Similar to `parse`, but error positions are reported within the provided\n\t\tString `expr`.",
      "registerFileContents": "Parse file content for newlines, allowing positions to be resolved\n\t\tproperly inside that file later on (using `Context.parseInlineString`\n\t\tfor example). Works with both real and virtual files.",
      "makeExpr": "Builds an expression from `v`.\n\n\t\tThis method generates AST nodes depending on the macro-runtime value of\n\t\t`v`. As such, only basic types and enums are supported and the behavior\n\t\tfor other types is undefined.\n\n\t\tThe provided `Position` `pos` is used for all generated inner AST nodes.",
      "signature": "Returns a hashed MD5 signature of value `v`.",
      "onGenerate": "Adds a callback function `callback` which is invoked after the\n\t\tcompiler's typing phase, just before its generation phase.\n\n\t\tThe callback receives an `Array` containing all types which are about\n\t\tto be generated. Modifications are limited to metadata, it is mainly\n\t\tintended to obtain information.\n\n\t\tBy default, the callback is made before types are stored in the compilation\n\t\tserver, if active. This means that any effect persists for the next compilation.\n\t\tIf `persistent` is set to `false`, changes to types made by the callback only\n\t\taffect the current compilation. If no compilation server is used, this flag has\n\t\tno effect.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.",
      "onAfterGenerate": "Adds a callback function `callback` which is invoked after the compiler\n\t\tgeneration phase.\n\n\t\tCompilation has completed at this point and cannot be influenced\n\t\tanymore. However, contextual information is still available.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.",
      "onAfterTyping": "Adds a callback function `callback` which is invoked after the compiler\n\t\tis done typing, but before optimization. The callback receives the types\n\t\twhich have been typed.\n\n\t\tIt is possible to define new types in the callback, in which case it\n\t\twill be called again with the new types as argument.",
      "onAfterInitMacros": "Adds a callback function `callback` which is invoked after the compiler\n\t\tis done running initialization macros, when typing begins.\n\n\t\t`onAfterInitMacros` should be used to delay typer-dependant code from\n\t\tyour initialization macros, to properly separate configuration phase and\n\t\tactual typing.",
      "onTypeNotFound": "Adds a callback function `callback` which is invoked when a type name\n\t\tcannot be resolved.\n\n\t\tThe callback may return a type definition, which is then used for the\n\t\texpected type. If it returns `null`, the type is considered to still not\n\t\texist.",
      "typeof": "Types expression `e` and returns its type.\n\n\t\tTyping the expression may result in a compiler error which can be\n\t\tcaught using `try ... catch`.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "typeExpr": "Types expression `e` and returns the corresponding `TypedExpr`.\n\n\t\tTyping the expression may result in a compiler error which can be\n\t\tcaught using `try ... catch`. Note that not all compiler errors can\n\t\tbe caught this way because the compiler might delay various checks\n\t\tto a later stage, at which point the exception handler is no longer\n\t\tactive.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "resolveType": "Resolve type `t` and returns the corresponding `Type`.\n\n\t\tResolving the type may result in a compiler error which can be\n\t\tcaught using `try ... catch`.\n\t\tResolution is performed based on the current context in which the macro is called.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "resolveComplexType": "Resolve type `t` and returns the corresponding `ComplexType`.\n\n\t\tResolving the type may result in a compiler error which can be\n\t\tcaught using `try ... catch`.\n\t\tResolution is performed based on the current context in which the macro is called.\n\t\tThe difference with `resolveType` is that it only performs type resolution, it does not\n\t\tbuild any type or trigger macros.",
      "toComplexType": "Returns the `ComplexType` corresponding to the given `Type` `t`.\n\n\t\tSee `haxe.macro.TypeTools.toComplexType` for details.",
      "unify": "Tries to unify `t1` and `t2` and returns `true` if successful.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "follow": "Follows a type.\n\n\t\tSee `haxe.macro.TypeTools.follow` for details.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "followWithAbstracts": "Follows a type, including abstracts' underlying implementation\n\n\t\tSee `haxe.macro.TypeTools.followWithAbstracts` for details.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "getPosInfos": "Returns the information stored in `Position` `p`.",
      "makePosition": "Builds a `Position` from `inf`.",
      "getResources": "Returns a map of all registered resources for this compilation unit.\n\n\t\tModifying the returned map has no effect on the compilation, use\n\t\t`haxe.macro.Context.addResource` to add new resources to the compilation unit.",
      "addResource": "Makes resource `data` available as `name`.\n\n\t\tThe resource is then available using the `haxe.macro.Resource` API.\n\n\t\tIf a previous resource was bound to `name`, it is overwritten.\n\n\t\tCompilation server : when using the compilation server, the resource is bound\n\t\tto the Haxe module which calls the macro, so it will be included again if\n\t\tthat module is reused. If this resource concerns several modules, prefix its\n\t\tname with a `$` sign, this will bind it to the macro module instead.",
      "getBuildFields": "Returns an `Array` of fields of the class which is to be built.\n\n\t\tThis is only defined for `@:build/@:autoBuild` macros.",
      "defineType": "Defines a new type from `TypeDefinition` `t`.\n\n\t\tIf a matching module has already been loaded in current context, a\n\t\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\t\tcaught using `try ... catch`.\n\n\t\tIf `moduleDependency` is given and is not `null`, it should contain\n\t\ta module path that will be used as a dependency for the newly defined module\n\t\tinstead of the current module.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "makeMonomorph": "Creates and returns a new instance of monomorph (`TMono`) type.\n\n\t\tReturned monomorph can be used with e.g. `Context.unify` to make the compiler\n\t\tbind the monomorph to an actual type and let macro further process the resulting type.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "defineModule": "Defines a new module as `modulePath` with several `TypeDefinition`\n\t\t`types`. This is analogous to defining a .hx file.\n\n\t\tIf a matching module has already been loaded in current context, a\n\t\t`haxe.macro.Expr.Error` compiler error will be raised which can be\n\t\tcaught using `try ... catch`.\n\n\t\tThe individual `types` can reference each other and any identifier\n\t\trespects the `imports` and `usings` as usual, expect that imports are\n\t\tnot allowed to have `.*` wildcards or `as s` shorthands.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "getTypedExpr": "Returns a syntax-level expression corresponding to typed expression `t`.\n\n\t\tThis process may lose some information.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "storeTypedExpr": "Store typed expression `t` internally and give a syntax-level expression\n\t\tthat can be returned from a macro and will be replaced by the stored\n\t\ttyped expression.\n\n\t\tIf `t` is `null` or invalid, an exception is thrown.\n\n\t\tNOTE: the returned value references an internally stored typed expression\n\t\tthat is reset between compilations, so care should be taken when storing\n\t\tthe expression returned by this method in a static variable and using the\n\t\tcompilation server.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "storeExpr": "Types expression `e`, stores the resulting typed expression internally and\n\t\treturns a syntax-level expression that can be returned from a macro and\n\t\twill be replaced by the stored typed expression.\n\n\t\tIf `e` is `null` or invalid, an exception is thrown.\n\n\t\tA call to `storeExpr(e)` is equivalent to `storeTypedExpr(typeExpr(e))` without\n\t\tthe overhead of encoding and decoding between regular and macro runtime.\n\n\t\tNOTE: the returned value references an internally stored typed expression\n\t\tthat is reset between compilations, so care should be taken when storing\n\t\tthe expression returned by this method in a static variable and using the\n\t\tcompilation server.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "typeAndStoreExpr": "This function works like `storeExpr`, but also returns access to the expression's\n\t\ttype through the `type` field of the return value.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "registerModuleDependency": "Manually adds a dependency between module `modulePath` and an external\n\t\tfile `externFile`.\n\n\t\tThis affects the compilation cache, causing the module to be typed if\n\t\t`externFile` has changed.\n\n\t\tHas no effect if the compilation cache is not used.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "timer": "Creates a timer which will be printed in the compilation report\n\t\tif `--times` compilation argument is set.\n\n\t\tNote that a timer may be omitted from the report if the amount of time\n\t\tmeasured is too small.\n\n\t\tThis method immediately starts a timer and returns a function to stop it:\n\t\t```\n\t\tvar stopTimer = haxe.macro.Context.timer(\"my heavy task\");\n\t\trunTask();\n\t\tstopTimer();\n\t\t```",
      "withImports": "Executes `code` in a context that has `imports` and `usings` added.\n\n\t\tThis is equivalent to temporarily having `import` and `using` statements in a file. These\n\t\tare only active during the execution of `code` and do not affect anything afterwards. This\n\t\tis true even if `code` throws an exception.\n\n\t\tIf any argument is `null`, the result is unspecified.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used.",
      "withOptions": "Executes `code` in a context that has some compiler options set, restore the compiler to its\n\t\tdefault behavior afterwards.\n\n\t\t`allowInlining`: enable or disable inlining during typing with `typeExpr`.\n\n\t\t`allowTransform`: when disabled, the code typed with `typeExpr` will be almost exactly the same\n\t\tas the input code. This will disable some abstract types transformations.\n\n\t\tUsage of this function from initialization macros is deprecated and may\n\t\tcause compilation server issues. Use `Context.onAfterInitMacros` to\n\t\trun your code once typer is ready to be used."
    },
    "fields": {}
  },
  "haxe.macro.Constant": {
    "doc": "Represents a position in a file.\n*/\ntypedef Position = {\n\t/**\n\t\tReference to the filename.\n*/\n\tvar file:String;\n\n\t/**\n\t\tPosition of the first character.\n*/\n\tvar min:Int;\n\n\t/**\n\t\tPosition of the last character.\n*/\n\tvar max:Int;\n}\n#end\n\nenum StringLiteralKind {\n\tDoubleQuotes;\n\tSingleQuotes;\n}\n\n/**\n\tRepresents a constant.\n\t@see https://haxe.org/manual/expression-constants.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "min": "Position of the first character.",
      "max": "Position of the last character.",
      "expr": "Represents a constant.\n\t@see https://haxe.org/manual/expression-constants.html\n*/\nenum Constant {\n\t/**\n\t\tRepresents an integer literal.\n*/\n\tCInt(v:String, ?s:String);\n\n\t/**\n\t\tRepresents a float literal.\n*/\n\tCFloat(f:String, ?s:String);\n\n\t/**\n\t\tRepresents a string literal.\n*/\n\tCString(s:String, ?kind:StringLiteralKind);\n\n\t/**\n\t\tRepresents an identifier.\n*/\n\tCIdent(s:String);\n\n\t/**\n\t\tRepresents a regular expression literal.\n\n\t\tExample: `~/haxe/i`\n\n\t\t- The first argument `haxe` is a string with regular expression pattern.\n\t\t- The second argument `i` is a string with regular expression flags.\n\n\t\t@see https://haxe.org/manual/std-regex.html\n*/\n\tCRegexp(r:String, opt:String);\n}\n\n/**\n\tA binary operator.\n\t@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Binop {\n\t/**\n\t\t`+`\n*/\n\tOpAdd;\n\n\t/**\n\t\t`*`\n*/\n\tOpMult;\n\n\t/**\n\t\t`/`\n*/\n\tOpDiv;\n\n\t/**\n\t\t`-`\n*/\n\tOpSub;\n\n\t/**\n\t\t`=`\n*/\n\tOpAssign;\n\n\t/**\n\t\t`==`\n*/\n\tOpEq;\n\n\t/**\n\t\t`!=`\n*/\n\tOpNotEq;\n\n\t/**\n\t\t`>`\n*/\n\tOpGt;\n\n\t/**\n\t\t`>=`\n*/\n\tOpGte;\n\n\t/**\n\t\t`<`\n*/\n\tOpLt;\n\n\t/**\n\t\t`<=`\n*/\n\tOpLte;\n\n\t/**\n\t\t`&`\n*/\n\tOpAnd;\n\n\t/**\n\t\t`|`\n*/\n\tOpOr;\n\n\t/**\n\t\t`^`\n*/\n\tOpXor;\n\n\t/**\n\t\t`&&`\n*/\n\tOpBoolAnd;\n\n\t/**\n\t\t`||`\n*/\n\tOpBoolOr;\n\n\t/**\n\t\t`<<`\n*/\n\tOpShl;\n\n\t/**\n\t\t`>>`\n*/\n\tOpShr;\n\n\t/**\n\t\t`>>>`\n*/\n\tOpUShr;\n\n\t/**\n\t\t`%`\n*/\n\tOpMod;\n\n\t/**\n\t\t`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\n\tOpAssignOp(op:Binop);\n\n\t/**\n\t\t`...`\n*/\n\tOpInterval;\n\n\t/**\n\t\t`=>`\n*/\n\tOpArrow;\n\n\t/**\n\t\t`in`\n*/\n\tOpIn;\n\n\t/**\n\t\t`??`\n*/\n\tOpNullCoal;\n}\n\n/**\n\tA unary operator.\n\t@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Unop {\n\t/**\n\t\t`++`\n*/\n\tOpIncrement;\n\n\t/**\n\t\t`--`\n*/\n\tOpDecrement;\n\n\t/**\n\t\t`!`\n*/\n\tOpNot;\n\n\t/**\n\t\t`-`\n*/\n\tOpNeg;\n\n\t/**\n\t\t`~`\n*/\n\tOpNegBits;\n\n\t/**\n\t\t`...`\n*/\n\tOpSpread;\n}\n\nenum EFieldKind {\n\tNormal;\n\tSafe;\n}\n\n/**\n\tRepresents a node in the AST.\n\t@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n\t/**\n\t\tThe expression kind."
    }
  },
  "haxe.macro.Binop": {
    "doc": "Represents an integer literal.\n*/\n\tCInt(v:String, ?s:String);\n\n\t/**\n\t\tRepresents a float literal.\n*/\n\tCFloat(f:String, ?s:String);\n\n\t/**\n\t\tRepresents a string literal.\n*/\n\tCString(s:String, ?kind:StringLiteralKind);\n\n\t/**\n\t\tRepresents an identifier.\n*/\n\tCIdent(s:String);\n\n\t/**\n\t\tRepresents a regular expression literal.\n\n\t\tExample: `~/haxe/i`\n\n\t\t- The first argument `haxe` is a string with regular expression pattern.\n\t\t- The second argument `i` is a string with regular expression flags.\n\n\t\t@see https://haxe.org/manual/std-regex.html\n*/\n\tCRegexp(r:String, opt:String);\n}\n\n/**\n\tA binary operator.\n\t@see https://haxe.org/manual/types-numeric-operators.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Unop": {
    "doc": "`+`\n*/\n\tOpAdd;\n\n\t/**\n\t\t`*`\n*/\n\tOpMult;\n\n\t/**\n\t\t`/`\n*/\n\tOpDiv;\n\n\t/**\n\t\t`-`\n*/\n\tOpSub;\n\n\t/**\n\t\t`=`\n*/\n\tOpAssign;\n\n\t/**\n\t\t`==`\n*/\n\tOpEq;\n\n\t/**\n\t\t`!=`\n*/\n\tOpNotEq;\n\n\t/**\n\t\t`>`\n*/\n\tOpGt;\n\n\t/**\n\t\t`>=`\n*/\n\tOpGte;\n\n\t/**\n\t\t`<`\n*/\n\tOpLt;\n\n\t/**\n\t\t`<=`\n*/\n\tOpLte;\n\n\t/**\n\t\t`&`\n*/\n\tOpAnd;\n\n\t/**\n\t\t`|`\n*/\n\tOpOr;\n\n\t/**\n\t\t`^`\n*/\n\tOpXor;\n\n\t/**\n\t\t`&&`\n*/\n\tOpBoolAnd;\n\n\t/**\n\t\t`||`\n*/\n\tOpBoolOr;\n\n\t/**\n\t\t`<<`\n*/\n\tOpShl;\n\n\t/**\n\t\t`>>`\n*/\n\tOpShr;\n\n\t/**\n\t\t`>>>`\n*/\n\tOpUShr;\n\n\t/**\n\t\t`%`\n*/\n\tOpMod;\n\n\t/**\n\t\t`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\n\tOpAssignOp(op:Binop);\n\n\t/**\n\t\t`...`\n*/\n\tOpInterval;\n\n\t/**\n\t\t`=>`\n*/\n\tOpArrow;\n\n\t/**\n\t\t`in`\n*/\n\tOpIn;\n\n\t/**\n\t\t`??`\n*/\n\tOpNullCoal;\n}\n\n/**\n\tA unary operator.\n\t@see https://haxe.org/manual/types-numeric-operators.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.QuoteStatus": {
    "doc": "`++`\n*/\n\tOpIncrement;\n\n\t/**\n\t\t`--`\n*/\n\tOpDecrement;\n\n\t/**\n\t\t`!`\n*/\n\tOpNot;\n\n\t/**\n\t\t`-`\n*/\n\tOpNeg;\n\n\t/**\n\t\t`~`\n*/\n\tOpNegBits;\n\n\t/**\n\t\t`...`\n*/\n\tOpSpread;\n}\n\nenum EFieldKind {\n\tNormal;\n\tSafe;\n}\n\n/**\n\tRepresents a node in the AST.\n\t@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n\t/**\n\t\tThe expression kind.\n*/\n\tvar expr:ExprDef;\n\n\t/**\n\t\tThe position of the expression.\n*/\n\tvar pos:Position;\n}\n\n/**\n\tRepresents a AST node identical to `Expr`, but it allows constraining the\n\ttype of accepted expressions.\n\t@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\n\tRepresents a switch case.\n\t@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n\t/**\n\t\tThe value expressions of the case.\n*/\n\tvar values:Array<Expr>;\n\n\t/**\n\t\tThe optional guard expressions of the case, if available.\n*/\n\tvar ?guard:Expr;\n\n\t/**\n\t\tThe expression of the case, if available.\n*/\n\tvar ?expr:Expr;\n}\n\n/**\n\tRepresents a variable in the AST.\n\t@see https://haxe.org/manual/expression-var.html\n*/\ntypedef Var = {\n\t/**\n\t\tThe name of the variable.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe position of the variable name.\n*/\n\tvar ?namePos:Position;\n\n\t/**\n\t\tThe type-hint of the variable, if available.\n*/\n\tvar ?type:ComplexType;\n\n\t/**\n\t\tThe expression of the variable, if available.\n*/\n\tvar ?expr:Expr;\n\n\t/**\n\t\tWhether or not the variable can be assigned to.\n*/\n\tvar ?isFinal:Bool;\n\n\t/**\n\t\tWhether or not the variable is static.\n*/\n\tvar ?isStatic:Bool;\n\n\t/**\n\t\tMetadata associated with the variable, if available.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents a catch in the AST.\n\t@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n\t/**\n\t\tThe name of the catch variable.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the catch.\n*/\n\tvar ?type:ComplexType;\n\n\t/**\n\t\tThe expression of the catch.\n*/\n\tvar expr:Expr;\n}\n\n/**\n\tRepresents the way something is quoted.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "pos": "The position of the expression.",
      "values": "Represents a AST node identical to `Expr`, but it allows constraining the\n\ttype of accepted expressions.\n\t@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\n\tRepresents a switch case.\n\t@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n\t/**\n\t\tThe value expressions of the case.",
      "name": "The position of the variable name.\n*/\n\tvar ?namePos:Position;\n\n\t/**\n\t\tThe type-hint of the variable, if available.\n*/\n\tvar ?type:ComplexType;\n\n\t/**\n\t\tThe expression of the variable, if available.\n*/\n\tvar ?expr:Expr;\n\n\t/**\n\t\tWhether or not the variable can be assigned to.\n*/\n\tvar ?isFinal:Bool;\n\n\t/**\n\t\tWhether or not the variable is static.\n*/\n\tvar ?isStatic:Bool;\n\n\t/**\n\t\tMetadata associated with the variable, if available.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents a catch in the AST.\n\t@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n\t/**\n\t\tThe name of the catch variable.",
      "expr": "The type of the catch.\n*/\n\tvar ?type:ComplexType;\n\n\t/**\n\t\tThe expression of the catch.",
      "field": "Represents the way something is quoted.\n*/\nenum QuoteStatus {\n\t/**\n\t\tNo quotes\n*/\n\tUnquoted;\n\n\t/**\n\t\tDouble quotes `\"`\n*/\n\tQuoted;\n}\n\n/**\n\tRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n\t/**\n\t\tThe name of the field."
    }
  },
  "haxe.macro.FunctionKind": {
    "doc": "No quotes\n*/\n\tUnquoted;\n\n\t/**\n\t\tDouble quotes `\"`\n*/\n\tQuoted;\n}\n\n/**\n\tRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n\t/**\n\t\tThe name of the field.\n*/\n\tvar field:String;\n\n\t/**\n\t\tThe field expression.\n*/\n\tvar expr:Expr;\n\n\t/**\n\t\tHow the field name is quoted.\n*/\n\tvar ?quotes:QuoteStatus;\n}\n\n/**\n\tRepresents function kind in the AST",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "expr": "The field expression.",
      "pack": "How the field name is quoted.\n*/\n\tvar ?quotes:QuoteStatus;\n}\n\n/**\n\tRepresents function kind in the AST\n*/\nenum FunctionKind {\n\t/**\n\t\tAnonymous function\n*/\n\tFAnonymous;\n\n\t/**\n\t\tNamed function\n*/\n\tFNamed(name:String, ?inlined:Bool);\n\n\t/**\n\t\tArrow function\n*/\n\tFArrow;\n}\n\n/**\n\tRepresents the kind of a node in the AST.\n*/\nenum ExprDef {\n\t/**\n\t\tA constant.\n*/\n\tEConst(c:Constant);\n\n\t/**\n\t\tArray access `e1[e2]`.\n*/\n\tEArray(e1:Expr, e2:Expr);\n\n\t/**\n\t\tBinary operator `e1 op e2`.\n*/\n\tEBinop(op:Binop, e1:Expr, e2:Expr);\n\n\t/**\n\t\tField access on `e.field`.\n\n\t\tIf `kind` is null, it is equal to Normal.\n*/\n\tEField(e:Expr, field:String, ?kind:EFieldKind);\n\n\t/**\n\t\tParentheses `(e)`.\n*/\n\tEParenthesis(e:Expr);\n\n\t/**\n\t\tAn object declaration.\n*/\n\tEObjectDecl(fields:Array<ObjectField>);\n\n\t/**\n\t\tAn array declaration `[el]`.\n*/\n\tEArrayDecl(values:Array<Expr>);\n\n\t/**\n\t\tA call `e(params)`.\n*/\n\tECall(e:Expr, params:Array<Expr>);\n\n\t/**\n\t\tA constructor call `new t(params)`.\n*/\n\tENew(t:TypePath, params:Array<Expr>);\n\n\t/**\n\t\tAn unary operator `op` on `e`:\n\n\t\t- `e++` (`op = OpIncrement, postFix = true`)\n\t\t- `e--` (`op = OpDecrement, postFix = true`)\n\t\t- `++e` (`op = OpIncrement, postFix = false`)\n\t\t- `--e` (`op = OpDecrement, postFix = false`)\n\t\t- `-e` (`op = OpNeg, postFix = false`)\n\t\t- `!e` (`op = OpNot, postFix = false`)\n\t\t- `~e` (`op = OpNegBits, postFix = false`)\n*/\n\tEUnop(op:Unop, postFix:Bool, e:Expr);\n\n\t/**\n\t\tVariable declarations.\n*/\n\tEVars(vars:Array<Var>);\n\n\t/**\n\t\tA function declaration.\n*/\n\tEFunction(kind:Null<FunctionKind>, f:Function);\n\n\t/**\n\t\tA block of expressions `{exprs}`.\n*/\n\tEBlock(exprs:Array<Expr>);\n\n\t/**\n\t\tA `for` expression.\n*/\n\tEFor(it:Expr, expr:Expr);\n\n\t/**\n\t\tAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\n\tEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n\t/**\n\t\tRepresents a `while` expression.\n\n\t\tWhen `normalWhile` is `true` it is `while (...)`.\n\n\t\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\n\tEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n\t/**\n\t\tRepresents a `switch` expression with related cases and an optional.\n\t\t`default` case if `edef != null`.\n*/\n\tESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n\t/**\n\t\tRepresents a `try`-expression with related catches.\n*/\n\tETry(e:Expr, catches:Array<Catch>);\n\n\t/**\n\t\tA `return` or `return e` expression.\n*/\n\tEReturn(?e:Expr);\n\n\t/**\n\t\tA `break` expression.\n*/\n\tEBreak;\n\n\t/**\n\t\tA `continue` expression.\n*/\n\tEContinue;\n\n\t/**\n\t\tAn `untyped e` source code.\n*/\n\tEUntyped(e:Expr);\n\n\t/**\n\t\tA `throw e` expression.\n*/\n\tEThrow(e:Expr);\n\n\t/**\n\t\tA `cast e` or `cast (e, m)` expression.\n*/\n\tECast(e:Expr, t:Null<ComplexType>);\n\n\t/**\n\t\tUsed internally to provide completion.\n*/\n\tEDisplay(e:Expr, displayKind:DisplayKind);\n\n\t/**\n\t\tA `(econd) ? eif : eelse` expression.\n*/\n\tETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n\t/**\n\t\tA `(e:t)` expression.\n*/\n\tECheckType(e:Expr, t:ComplexType);\n\n\t/**\n\t\tA `@m e` expression.\n*/\n\tEMeta(s:MetadataEntry, e:Expr);\n\n\t/**\n\t\tAn `expr is Type` expression.\n*/\n\tEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\n\tDKCall;\n\tDKDot;\n\tDKStructure;\n\tDKMarked;\n\tDKPattern(outermost:Bool);\n}\n\n/**\n\tRepresents a type syntax in the AST.\n*/\nenum ComplexType {\n\t/**\n\t\tRepresents the type path.\n*/\n\tTPath(p:TypePath);\n\n\t/**\n\t\tRepresents a function type.\n\t\t@see https://haxe.org/manual/types-function.html\n*/\n\tTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n\t/**\n\t\tRepresents an anonymous structure type.\n\t\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\n\tTAnonymous(fields:Array<Field>);\n\n\t/**\n\t\tRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n\t\t`(Int -> Void) -> String`.\n*/\n\tTParent(t:ComplexType);\n\n\t/**\n\t\tRepresents typedef extensions `> Iterable<T>`.\n\t\tThe array `p` holds the type paths to the given types.\n\t\t@see https://haxe.org/manual/type-system-extensions.html\n*/\n\tTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n\t/**\n\t\tRepresents an optional type.\n*/\n\tTOptional(t:ComplexType);\n\n\t/**\n\t\tRepresents a type with a name.\n*/\n\tTNamed(n:String, t:ComplexType);\n\n\t/**\n\t\tRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\n\tTIntersection(tl:Array<ComplexType>);\n}\n\n/**\n\tRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n\t/**\n\t\tRepresents the package of the type path."
    }
  },
  "haxe.macro.ExprDef": {
    "doc": "Anonymous function\n*/\n\tFAnonymous;\n\n\t/**\n\t\tNamed function\n*/\n\tFNamed(name:String, ?inlined:Bool);\n\n\t/**\n\t\tArrow function\n*/\n\tFArrow;\n}\n\n/**\n\tRepresents the kind of a node in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ComplexType": {
    "doc": "A constant.\n*/\n\tEConst(c:Constant);\n\n\t/**\n\t\tArray access `e1[e2]`.\n*/\n\tEArray(e1:Expr, e2:Expr);\n\n\t/**\n\t\tBinary operator `e1 op e2`.\n*/\n\tEBinop(op:Binop, e1:Expr, e2:Expr);\n\n\t/**\n\t\tField access on `e.field`.\n\n\t\tIf `kind` is null, it is equal to Normal.\n*/\n\tEField(e:Expr, field:String, ?kind:EFieldKind);\n\n\t/**\n\t\tParentheses `(e)`.\n*/\n\tEParenthesis(e:Expr);\n\n\t/**\n\t\tAn object declaration.\n*/\n\tEObjectDecl(fields:Array<ObjectField>);\n\n\t/**\n\t\tAn array declaration `[el]`.\n*/\n\tEArrayDecl(values:Array<Expr>);\n\n\t/**\n\t\tA call `e(params)`.\n*/\n\tECall(e:Expr, params:Array<Expr>);\n\n\t/**\n\t\tA constructor call `new t(params)`.\n*/\n\tENew(t:TypePath, params:Array<Expr>);\n\n\t/**\n\t\tAn unary operator `op` on `e`:\n\n\t\t- `e++` (`op = OpIncrement, postFix = true`)\n\t\t- `e--` (`op = OpDecrement, postFix = true`)\n\t\t- `++e` (`op = OpIncrement, postFix = false`)\n\t\t- `--e` (`op = OpDecrement, postFix = false`)\n\t\t- `-e` (`op = OpNeg, postFix = false`)\n\t\t- `!e` (`op = OpNot, postFix = false`)\n\t\t- `~e` (`op = OpNegBits, postFix = false`)\n*/\n\tEUnop(op:Unop, postFix:Bool, e:Expr);\n\n\t/**\n\t\tVariable declarations.\n*/\n\tEVars(vars:Array<Var>);\n\n\t/**\n\t\tA function declaration.\n*/\n\tEFunction(kind:Null<FunctionKind>, f:Function);\n\n\t/**\n\t\tA block of expressions `{exprs}`.\n*/\n\tEBlock(exprs:Array<Expr>);\n\n\t/**\n\t\tA `for` expression.\n*/\n\tEFor(it:Expr, expr:Expr);\n\n\t/**\n\t\tAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\n\tEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n\t/**\n\t\tRepresents a `while` expression.\n\n\t\tWhen `normalWhile` is `true` it is `while (...)`.\n\n\t\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\n\tEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n\t/**\n\t\tRepresents a `switch` expression with related cases and an optional.\n\t\t`default` case if `edef != null`.\n*/\n\tESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n\t/**\n\t\tRepresents a `try`-expression with related catches.\n*/\n\tETry(e:Expr, catches:Array<Catch>);\n\n\t/**\n\t\tA `return` or `return e` expression.\n*/\n\tEReturn(?e:Expr);\n\n\t/**\n\t\tA `break` expression.\n*/\n\tEBreak;\n\n\t/**\n\t\tA `continue` expression.\n*/\n\tEContinue;\n\n\t/**\n\t\tAn `untyped e` source code.\n*/\n\tEUntyped(e:Expr);\n\n\t/**\n\t\tA `throw e` expression.\n*/\n\tEThrow(e:Expr);\n\n\t/**\n\t\tA `cast e` or `cast (e, m)` expression.\n*/\n\tECast(e:Expr, t:Null<ComplexType>);\n\n\t/**\n\t\tUsed internally to provide completion.\n*/\n\tEDisplay(e:Expr, displayKind:DisplayKind);\n\n\t/**\n\t\tA `(econd) ? eif : eelse` expression.\n*/\n\tETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n\t/**\n\t\tA `(e:t)` expression.\n*/\n\tECheckType(e:Expr, t:ComplexType);\n\n\t/**\n\t\tA `@m e` expression.\n*/\n\tEMeta(s:MetadataEntry, e:Expr);\n\n\t/**\n\t\tAn `expr is Type` expression.\n*/\n\tEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\n\tDKCall;\n\tDKDot;\n\tDKStructure;\n\tDKMarked;\n\tDKPattern(outermost:Bool);\n}\n\n/**\n\tRepresents a type syntax in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeParam": {
    "doc": "Represents the type path.\n*/\n\tTPath(p:TypePath);\n\n\t/**\n\t\tRepresents a function type.\n\t\t@see https://haxe.org/manual/types-function.html\n*/\n\tTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n\t/**\n\t\tRepresents an anonymous structure type.\n\t\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\n\tTAnonymous(fields:Array<Field>);\n\n\t/**\n\t\tRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n\t\t`(Int -> Void) -> String`.\n*/\n\tTParent(t:ComplexType);\n\n\t/**\n\t\tRepresents typedef extensions `> Iterable<T>`.\n\t\tThe array `p` holds the type paths to the given types.\n\t\t@see https://haxe.org/manual/type-system-extensions.html\n*/\n\tTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n\t/**\n\t\tRepresents an optional type.\n*/\n\tTOptional(t:ComplexType);\n\n\t/**\n\t\tRepresents a type with a name.\n*/\n\tTNamed(n:String, t:ComplexType);\n\n\t/**\n\t\tRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\n\tTIntersection(tl:Array<ComplexType>);\n}\n\n/**\n\tRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n\t/**\n\t\tRepresents the package of the type path.\n*/\n\tvar pack:Array<String>;\n\n\t/**\n\t\tThe name of the type path.\n*/\n\tvar name:String;\n\n\t/**\n\t\tOptional parameters of the type path.\n*/\n\tvar ?params:Array<TypeParam>;\n\n\t/**\n\t\tSub is set on module sub-type access:\n\t\t`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\n\tvar ?sub:String;\n\n\t/**\n\t\tThe full position of the type path, including type parameters.\n*/\n\tvar ?pos:Position;\n\n\t/**\n\t\tThe position of the dot-path itself, without type parameters.\n*/\n\tvar ?posPath:Position;\n}\n\n/**\n\tRepresents a concrete type parameter in the AST.\n\n\tHaxe allows expressions in concrete type parameters, e.g.\n\t`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\n\tin the normal case it's `TPType`.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "Optional parameters of the type path.\n*/\n\tvar ?params:Array<TypeParam>;\n\n\t/**\n\t\tSub is set on module sub-type access:\n\t\t`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\n\tvar ?sub:String;\n\n\t/**\n\t\tThe full position of the type path, including type parameters.\n*/\n\tvar ?pos:Position;\n\n\t/**\n\t\tThe position of the dot-path itself, without type parameters.\n*/\n\tvar ?posPath:Position;\n}\n\n/**\n\tRepresents a concrete type parameter in the AST.\n\n\tHaxe allows expressions in concrete type parameters, e.g.\n\t`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\n\tin the normal case it's `TPType`.\n*/\nenum TypeParam {\n\tTPType(t:ComplexType);\n\tTPExpr(e:Expr);\n}\n\n/**\n\tRepresents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n\t/**\n\t\tThe name of the type parameter."
    }
  },
  "haxe.macro.Access": {
    "doc": "Represents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n\t/**\n\t\tThe name of the type parameter.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe optional constraints of the type parameter.\n*/\n\tvar ?constraints:Array<ComplexType>;\n\n\t/**\n\t\tThe optional default type of the type parameter.\n*/\n\tvar ?defaultType:Null<ComplexType>;\n\n\t/**\n\t\tThe optional parameters of the type parameter.\n*/\n\tvar ?params:Array<TypeParamDecl>;\n\n\t/**\n\t\tThe metadata of the type parameter.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents a function in the AST.\n*/\ntypedef Function = {\n\t/**\n\t\tA list of function arguments.\n*/\n\tvar args:Array<FunctionArg>;\n\n\t/**\n\t\tThe return type-hint of the function, if available.\n*/\n\tvar ?ret:ComplexType;\n\n\t/**\n\t\tThe expression of the function body, if available.\n*/\n\tvar ?expr:Expr;\n\n\t/**\n\t\tAn optional list of function parameter type declarations.\n*/\n\tvar ?params:Array<TypeParamDecl>;\n}\n\n/**\n\tRepresents a function argument in the AST.\n*/\ntypedef FunctionArg = {\n\t/**\n\t\tThe name of the function argument.\n*/\n\tvar name:String;\n\n\t/**\n\t\tWhether or not the function argument is optional.\n*/\n\tvar ?opt:Bool;\n\n\t/**\n\t\tThe type-hint of the function argument, if available.\n*/\n\tvar ?type:ComplexType;\n\n\t/**\n\t\tThe optional value of the function argument, if available.\n*/\n\tvar ?value:Expr;\n\n\t/**\n\t\tThe metadata of the function argument.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents a metadata entry in the AST.\n*/\ntypedef MetadataEntry = {\n\t/**\n\t\tThe name of the metadata entry.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe optional parameters of the metadata entry.\n*/\n\tvar ?params:Array<Expr>;\n\n\t/**\n\t\tThe position of the metadata entry.\n*/\n\tvar pos:Position;\n}\n\n/**\n\tRepresents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\n\tRepresents a field in the AST.\n*/\ntypedef Field = {\n\t/**\n\t\tThe name of the field.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe documentation of the field, if available. If the field has no\n\t\tdocumentation, the value is `null`.\n*/\n\tvar ?doc:String;\n\n\t/**\n\t\tThe access modifiers of the field. By default fields have private access.\n\t\t@see https://haxe.org/manual/class-field-access-modifier.html\n*/\n\tvar ?access:Array<Access>;\n\n\t/**\n\t\tThe kind of the field.\n*/\n\tvar kind:FieldType;\n\n\t/**\n\t\tThe position of the field.\n*/\n\tvar pos:Position;\n\n\t/**\n\t\tThe optional metadata of the field.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents an access modifier.\n\t@see https://haxe.org/manual/class-field-access-modifier.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "args": "The optional constraints of the type parameter.\n*/\n\tvar ?constraints:Array<ComplexType>;\n\n\t/**\n\t\tThe optional default type of the type parameter.\n*/\n\tvar ?defaultType:Null<ComplexType>;\n\n\t/**\n\t\tThe optional parameters of the type parameter.\n*/\n\tvar ?params:Array<TypeParamDecl>;\n\n\t/**\n\t\tThe metadata of the type parameter.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents a function in the AST.\n*/\ntypedef Function = {\n\t/**\n\t\tA list of function arguments.",
      "name": "Represents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\n\tRepresents a field in the AST.\n*/\ntypedef Field = {\n\t/**\n\t\tThe name of the field.",
      "pos": "The position of the field.",
      "kind": "The documentation of the field, if available. If the field has no\n\t\tdocumentation, the value is `null`.\n*/\n\tvar ?doc:String;\n\n\t/**\n\t\tThe access modifiers of the field. By default fields have private access.\n\t\t@see https://haxe.org/manual/class-field-access-modifier.html\n*/\n\tvar ?access:Array<Access>;\n\n\t/**\n\t\tThe kind of the field.",
      "pack": "The optional metadata of the field.\n*/\n\tvar ?meta:Metadata;\n}\n\n/**\n\tRepresents an access modifier.\n\t@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nenum Access {\n\t/**\n\t\tPublic access modifier, grants access from anywhere.\n\t\t@see https://haxe.org/manual/class-field-visibility.html\n*/\n\tAPublic;\n\n\t/**\n\t\tPrivate access modifier, grants access to class and its sub-classes\n\t\tonly.\n\t\t@see https://haxe.org/manual/class-field-visibility.html\n*/\n\tAPrivate;\n\n\t/**\n\t\tStatic access modifier.\n*/\n\tAStatic;\n\n\t/**\n\t\tOverride access modifier.\n\t\t@see https://haxe.org/manual/class-field-override.html\n*/\n\tAOverride;\n\n\t/**\n\t\tDynamic (re-)bindable access modifier.\n\t\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\n\tADynamic;\n\n\t/**\n\t\tInline access modifier. Allows expressions to be directly inserted in\n\t\tplace of calls to them.\n\t\t@see https://haxe.org/manual/class-field-inline.html\n*/\n\tAInline;\n\n\t/**\n\t\tMacro access modifier. Allows expression macro functions. These are\n\t\tnormal functions which are executed as soon as they are typed.\n*/\n\tAMacro;\n\n\t/**\n\t\tFinal access modifier. For functions, they can not be overridden. For\n\t\tvariables, it means they can be assigned to only once.\n*/\n\tAFinal;\n\n\t/**\n\t\tExtern access modifier.\n*/\n\tAExtern;\n\n\t/**\n\t\tAbstract access modifier.\n*/\n\tAAbstract;\n\n\t/**\n\t\tOverload access modifier.\n*/\n\tAOverload;\n\n\t/**\n\t\tEnum access modifier.\n*/\n\tAEnum;\n}\n\n/**\n\tRepresents the field type in the AST.\n*/\nenum FieldType {\n\t/**\n\t\tRepresents a variable field type.\n*/\n\tFVar(t:Null<ComplexType>, ?e:Expr);\n\n\t/**\n\t\tRepresents a function field type.\n*/\n\tFFun(f:Function);\n\n\t/**\n\t\tRepresents a property with getter and setter field type.\n*/\n\tFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\n\tRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n\t/**\n\t\tThe package of the type definition."
    }
  },
  "haxe.macro.FieldType": {
    "doc": "Public access modifier, grants access from anywhere.\n\t\t@see https://haxe.org/manual/class-field-visibility.html\n*/\n\tAPublic;\n\n\t/**\n\t\tPrivate access modifier, grants access to class and its sub-classes\n\t\tonly.\n\t\t@see https://haxe.org/manual/class-field-visibility.html\n*/\n\tAPrivate;\n\n\t/**\n\t\tStatic access modifier.\n*/\n\tAStatic;\n\n\t/**\n\t\tOverride access modifier.\n\t\t@see https://haxe.org/manual/class-field-override.html\n*/\n\tAOverride;\n\n\t/**\n\t\tDynamic (re-)bindable access modifier.\n\t\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\n\tADynamic;\n\n\t/**\n\t\tInline access modifier. Allows expressions to be directly inserted in\n\t\tplace of calls to them.\n\t\t@see https://haxe.org/manual/class-field-inline.html\n*/\n\tAInline;\n\n\t/**\n\t\tMacro access modifier. Allows expression macro functions. These are\n\t\tnormal functions which are executed as soon as they are typed.\n*/\n\tAMacro;\n\n\t/**\n\t\tFinal access modifier. For functions, they can not be overridden. For\n\t\tvariables, it means they can be assigned to only once.\n*/\n\tAFinal;\n\n\t/**\n\t\tExtern access modifier.\n*/\n\tAExtern;\n\n\t/**\n\t\tAbstract access modifier.\n*/\n\tAAbstract;\n\n\t/**\n\t\tOverload access modifier.\n*/\n\tAOverload;\n\n\t/**\n\t\tEnum access modifier.\n*/\n\tAEnum;\n}\n\n/**\n\tRepresents the field type in the AST.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeDefKind": {
    "doc": "Represents a variable field type.\n*/\n\tFVar(t:Null<ComplexType>, ?e:Expr);\n\n\t/**\n\t\tRepresents a function field type.\n*/\n\tFFun(f:Function);\n\n\t/**\n\t\tRepresents a property with getter and setter field type.\n*/\n\tFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\n\tRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n\t/**\n\t\tThe package of the type definition.\n*/\n\tvar pack:Array<String>;\n\n\t/**\n\t\tThe name of the type definition.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe documentation of the type, if available. If the type has no\n\t\tdocumentation, the value is `null`.\n*/\n\tvar ?doc:String;\n\n\t/**\n\t\tThe position to the type definition.\n*/\n\tvar pos:Position;\n\n\t/**\n\t\tThe optional metadata of the type definition.\n*/\n\tvar ?meta:Metadata;\n\n\t/**\n\t\tThe parameter type declarations of the type definition.\n*/\n\tvar ?params:Array<TypeParamDecl>;\n\n\t/**\n\t\tWhether or not the type is extern.\n*/\n\tvar ?isExtern:Bool;\n\n\t/**\n\t\tThe kind of the type definition.\n*/\n\tvar kind:TypeDefKind;\n\n\t/**\n\t\tThe fields of the type definition.\n*/\n\tvar fields:Array<Field>;\n}\n\n/**\n\tRepresents a type definition kind.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "The name of the type definition.",
      "pos": "Represents a type definition kind.\n*/\nenum TypeDefKind {\n\t/**\n\t\tRepresents an enum kind.\n*/\n\tTDEnum;\n\n\t/**\n\t\tRepresents a structure kind.\n*/\n\tTDStructure;\n\n\t/**\n\t\tRepresents a class kind.\n*/\n\tTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n\t/**\n\t\tRepresents an alias/typedef kind.\n*/\n\tTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n\t/**\n\t\tRepresents an abstract kind.\n*/\n\tTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n\t/**\n\t\tRepresents a module-level field.\n*/\n\tTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\n\tRepresents an abstract flag.\n*/\nenum AbstractFlag {\n\t/**\n\t\tIndicates that this abstract is an `enum abstract`\n*/\n\tAbEnum;\n\n\t/**\n\t\tIndicates that this abstract can be assigned from `ct`.\n\t\tThis flag can be added several times to add multiple \"from\" types.\n*/\n\tAbFrom(ct:ComplexType);\n\n\t/**\n\t\tIndicates that this abstract can be assigned to `ct`.\n\t\tThis flag can be added several times to add multiple \"to\" types.\n*/\n\tAbTo(ct:ComplexType);\n}\n\n/**\n\tThis error can be used to handle or produce compilation errors in macros.\n*/\nclass Error extends Exception {\n\t/**\n\t\tThe position of the error.",
      "kind": "The optional metadata of the type definition.\n*/\n\tvar ?meta:Metadata;\n\n\t/**\n\t\tThe parameter type declarations of the type definition.\n*/\n\tvar ?params:Array<TypeParamDecl>;\n\n\t/**\n\t\tWhether or not the type is extern.\n*/\n\tvar ?isExtern:Bool;\n\n\t/**\n\t\tThe kind of the type definition.",
      "fields": "The fields of the type definition."
    }
  },
  "haxe.macro.AbstractFlag": {
    "doc": "Represents an enum kind.\n*/\n\tTDEnum;\n\n\t/**\n\t\tRepresents a structure kind.\n*/\n\tTDStructure;\n\n\t/**\n\t\tRepresents a class kind.\n*/\n\tTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n\t/**\n\t\tRepresents an alias/typedef kind.\n*/\n\tTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n\t/**\n\t\tRepresents an abstract kind.\n*/\n\tTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n\t/**\n\t\tRepresents a module-level field.\n*/\n\tTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\n\tRepresents an abstract flag.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Error": {
    "doc": "Indicates that this abstract is an `enum abstract`\n*/\n\tAbEnum;\n\n\t/**\n\t\tIndicates that this abstract can be assigned from `ct`.\n\t\tThis flag can be added several times to add multiple \"from\" types.\n*/\n\tAbFrom(ct:ComplexType);\n\n\t/**\n\t\tIndicates that this abstract can be assigned to `ct`.\n\t\tThis flag can be added several times to add multiple \"to\" types.\n*/\n\tAbTo(ct:ComplexType);\n}\n\n/**\n\tThis error can be used to handle or produce compilation errors in macros.",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ImportMode": {
    "doc": "The position of the error.\n*/\n\tpublic var pos:Position;\n\n\t/**\n\t\tChild error messages, if any.\n*/\n\tprivate var childErrors:Array<Error>;\n\n\t/**\n\t\tInstantiates an error with given message and position.\n*/\n\tpublic function new(message:String, pos:Position, ?previous:Exception) {\n\t\tsuper(message, previous);\n\t\tthis.pos = pos;\n\t}\n}\n\n/**\n\tRepresents the import mode.\n\t@see https://haxe.org/manual/type-system-import.html",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "childErrors": "Child error messages, if any.",
      "path": "Instantiates an error with given message and position.\n*/\n\tpublic function new(message:String, pos:Position, ?previous:Exception) {\n\t\tsuper(message, previous);\n\t\tthis.pos = pos;\n\t}\n}\n\n/**\n\tRepresents the import mode.\n\t@see https://haxe.org/manual/type-system-import.html\n*/\nenum ImportMode {\n\t/**\n\t\tRepresents a default import `import c`.\n*/\n\tINormal;\n\n\t/**\n\t\tRepresents the alias import `import c as alias`.\n*/\n\tIAsName(alias:String);\n\n\t/**\n\t\tRepresents the wildcard import `import *`.\n*/\n\tIAll;\n}\n\n/**\n\tRepresents the import expression.\n*/\ntypedef ImportExpr = {\n\t/**\n\t\tThe path to the import expression.",
      "mode": "The mode of the import expression."
    }
  },
  "haxe.macro.ExprTools": {
    "doc": "This class provides some utility methods to work with expressions. It is\n\tbest used through 'using haxe.macro.ExprTools' syntax and then provides\n\tadditional methods on haxe.macro.Expr instances.\n\n\tWhile mainly intended to be used in macros, it works in non-macro code as\n\twell.",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ExprArrayTools": {
    "doc": "Converts expression `e` to a human-readable String representation.\n\n\t\tThe result is guaranteed to be valid Haxe code, but there may be\n\t\tdifferences from the original lexical syntax.\n*/\n\tstatic public function toString(e:Expr):String\n\t\treturn new Printer().printExpr(e);\n\n\t/**\n\t\tCalls function `f` on each sub-expression of `e`.\n\n\t\tIf `e` has no sub-expressions, this operation has no effect.\n\n\t\tOtherwise `f` is called once per sub-expression of `e`, with the\n\t\tsub-expression as argument. These calls are done in order of the\n\t\tsub-expression declarations.\n\n\t\tThis method does not call itself recursively. It should instead be used\n\t\tin a recursive function which handles the expression nodes of interest.\n\n\t\tUsage example:\n\t\t```haxe\n\t\tfunction findStrings(e:Expr) {\n\t\t\tswitch(e.expr) {\n\t\t\t\tcase EConst(CString(s)):\n\t\t\t\t\t// handle s\n\t\t\t\tcase _:\n\t\t\t\t\tExprTools.iter(e, findStrings);\n\t\t\t}\n\t\t}\n\t\t```\n*/\n\tstatic public function iter(e:Expr, f:Expr->Void):Void {\n\t\tswitch (e.expr) {\n\t\t\tcase EConst(_), EContinue, EBreak:\n\t\t\tcase EField(e, _), EParenthesis(e), EUntyped(e), EThrow(e), EDisplay(e, _), ECheckType(e, _), EUnop(_, _, e), ECast(e, _), EIs(e, _) | EMeta(_, e):\n\t\t\t\tf(e);\n\t\t\tcase EArray(e1, e2), EWhile(e1, e2, _), EBinop(_, e1, e2), EFor(e1, e2):\n\t\t\t\tf(e1);\n\t\t\t\tf(e2);\n\t\t\tcase EVars(vl):\n\t\t\t\tfor (v in vl)\n\t\t\t\t\topt2(v.expr, f);\n\t\t\tcase ETry(e, cl):\n\t\t\t\tf(e);\n\t\t\t\tfor (c in cl)\n\t\t\t\t\tf(c.expr);\n\t\t\tcase ETernary(e1, e2, e3) | EIf(e1, e2, e3):\n\t\t\t\tf(e1);\n\t\t\t\tf(e2);\n\t\t\t\topt2(e3, f);\n\t\t\tcase EArrayDecl(el), ENew(_, el), EBlock(el):\n\t\t\t\tExprArrayTools.iter(el, f);\n\t\t\tcase EObjectDecl(fl):\n\t\t\t\tfor (fd in fl)\n\t\t\t\t\tf(fd.expr);\n\t\t\tcase ECall(e, el):\n\t\t\t\tf(e);\n\t\t\t\tExprArrayTools.iter(el, f);\n\t\t\tcase EReturn(e):\n\t\t\t\topt2(e, f);\n\t\t\tcase EFunction(_, func):\n\t\t\t\tfor (arg in func.args)\n\t\t\t\t\topt2(arg.value, f);\n\t\t\t\topt2(func.expr, f);\n\t\t\tcase ESwitch(e, cl, edef):\n\t\t\t\tf(e);\n\t\t\t\tfor (c in cl) {\n\t\t\t\t\tExprArrayTools.iter(c.values, f);\n\t\t\t\t\topt2(c.guard, f);\n\t\t\t\t\topt2(c.expr, f);\n\t\t\t\t}\n\t\t\t\tif (edef != null && edef.expr != null)\n\t\t\t\t\tf(edef);\n\t\t}\n\t}\n\n\t/**\n\t\tTransforms the sub-expressions of `e` by calling `f` on each of them.\n\n\t\tIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\n\t\tOtherwise `f` is called once per sub-expression of `e`, with the\n\t\tsub-expression as argument. These calls are done in order of the\n\t\tsub-expression declarations.\n\n\t\tThis method does not call itself recursively. It should instead be used\n\t\tin a recursive function which handles the expression nodes of interest.\n\n\t\tUsage example:\n\t\t```haxe\n\t\tfunction capitalizeStrings(e:Expr) {\n\t\t\treturn switch(e.expr) {\n\t\t\t\tcase EConst(CString(s)):\n\t\t\t\t\t{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\n\t\t\t\tcase _:\n\t\t\t\t\tExprTools.map(e, capitalizeStrings);\n\t\t\t}\n\t\t}\n\t\t```\n*/\n\tstatic public function map(e:Expr, f:Expr->Expr):Expr {\n\t\treturn {\n\t\t\tpos: e.pos,\n\t\t\texpr: switch (e.expr) {\n\t\t\t\tcase EConst(_): e.expr;\n\t\t\t\tcase EArray(e1, e2): EArray(f(e1), f(e2));\n\t\t\t\tcase EBinop(op, e1, e2): EBinop(op, f(e1), f(e2));\n\t\t\t\tcase EField(e, field, kind): EField(f(e), field, kind);\n\t\t\t\tcase EParenthesis(e): EParenthesis(f(e));\n\t\t\t\tcase EObjectDecl(fields):\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tfor (field in fields)\n\t\t\t\t\t\tret.push({field: field.field, expr: f(field.expr), quotes: field.quotes});\n\t\t\t\t\tEObjectDecl(ret);\n\t\t\t\tcase EArrayDecl(el): EArrayDecl(ExprArrayTools.map(el, f));\n\t\t\t\tcase ECall(e, params): ECall(f(e), ExprArrayTools.map(params, f));\n\t\t\t\tcase ENew(tp, params): ENew(tp, ExprArrayTools.map(params, f));\n\t\t\t\tcase EUnop(op, postFix, e): EUnop(op, postFix, f(e));\n\t\t\t\tcase EVars(vars):\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tfor (v in vars) {\n\t\t\t\t\t\tvar v2:Var = {name: v.name, type: v.type, expr: opt(v.expr, f)};\n\t\t\t\t\t\tif (v.isFinal != null)\n\t\t\t\t\t\t\tv2.isFinal = v.isFinal;\n\t\t\t\t\t\tif (v.isStatic != null)\n\t\t\t\t\t\t\tv2.isStatic = v.isStatic;\n\t\t\t\t\t\tret.push(v2);\n\t\t\t\t\t}\n\t\t\t\t\tEVars(ret);\n\t\t\t\tcase EBlock(el): EBlock(ExprArrayTools.map(el, f));\n\t\t\t\tcase EFor(it, expr): EFor(f(it), f(expr));\n\t\t\t\tcase EIf(econd, eif, eelse): EIf(f(econd), f(eif), opt(eelse, f));\n\t\t\t\tcase EWhile(econd, e, normalWhile): EWhile(f(econd), f(e), normalWhile);\n\t\t\t\tcase EReturn(e): EReturn(opt(e, f));\n\t\t\t\tcase EUntyped(e): EUntyped(f(e));\n\t\t\t\tcase EThrow(e): EThrow(f(e));\n\t\t\t\tcase ECast(e, t): ECast(f(e), t);\n\t\t\t\tcase EIs(e, t): EIs(f(e), t);\n\t\t\t\tcase EDisplay(e, dk): EDisplay(f(e), dk);\n\t\t\t\tcase ETernary(econd, eif, eelse): ETernary(f(econd), f(eif), f(eelse));\n\t\t\t\tcase ECheckType(e, t): ECheckType(f(e), t);\n\t\t\t\tcase EContinue, EBreak:\n\t\t\t\t\te.expr;\n\t\t\t\tcase ETry(e, catches):\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tfor (c in catches)\n\t\t\t\t\t\tret.push({name: c.name, type: c.type, expr: f(c.expr)});\n\t\t\t\t\tETry(f(e), ret);\n\t\t\t\tcase ESwitch(e, cases, edef):\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tfor (c in cases)\n\t\t\t\t\t\tret.push({expr: opt(c.expr, f), guard: opt(c.guard, f), values: ExprArrayTools.map(c.values, f)});\n\t\t\t\t\tESwitch(f(e), ret, edef == null || edef.expr == null ? edef : f(edef));\n\t\t\t\tcase EFunction(kind, func):\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tfor (arg in func.args)\n\t\t\t\t\t\tret.push({\n\t\t\t\t\t\t\tname: arg.name,\n\t\t\t\t\t\t\topt: arg.opt,\n\t\t\t\t\t\t\ttype: arg.type,\n\t\t\t\t\t\t\tvalue: opt(arg.value, f)\n\t\t\t\t\t\t});\n\t\t\t\t\tEFunction(kind, {\n\t\t\t\t\t\targs: ret,\n\t\t\t\t\t\tret: func.ret,\n\t\t\t\t\t\tparams: func.params,\n\t\t\t\t\t\texpr: f(func.expr)\n\t\t\t\t\t});\n\t\t\t\tcase EMeta(m, e): EMeta(m, f(e));\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the value `e` represents.\n\n\t\tSupported expressions are:\n\n\t\t - `Int`, `Float` and `String` literals\n\t\t - identifiers `true`, `false` and `null`\n\t\t - structure declarations if all their fields are values\n\t\t - array declarations if all their elements are values\n\t\t - unary operators `-`, `!` and `~` if the operand is a value\n\t\t - binary operators except `=>`, `...` and assignments\n\n\t\tParentheses, metadata and the `untyped` keyword are ignored.\n\n\t\tIf any non-value is encountered, an exception of type `String` is\n\t\tthrown.\n\n\t\tIf `e` is null, the result is unspecified.\n*/\n\tstatic public function getValue(e:Expr):Dynamic {\n\t\treturn switch (e.expr) {\n\t\t\tcase EConst(CInt(v)): Std.parseInt(v);\n\t\t\tcase EConst(CFloat(v)): Std.parseFloat(v);\n\t\t\tcase EConst(CString(s)): s;\n\t\t\tcase EConst(CIdent(\"true\")): true;\n\t\t\tcase EConst(CIdent(\"false\")): false;\n\t\t\tcase EConst(CIdent(\"null\")): null;\n\t\t\tcase EParenthesis(e1) | EUntyped(e1) | EMeta(_, e1): getValue(e1);\n\t\t\tcase EObjectDecl(fields):\n\t\t\t\tvar obj = {};\n\t\t\t\tfor (field in fields) {\n\t\t\t\t\tReflect.setField(obj, field.field, getValue(field.expr));\n\t\t\t\t}\n\t\t\t\tobj;\n\t\t\tcase EArrayDecl(el): el.map(getValue);\n\t\t\tcase EIf(econd, eif, eelse) | ETernary(econd, eif, eelse):\n\t\t\t\tif (eelse == null) {\n\t\t\t\t\tthrow \"If statements only have a value if the else clause is defined\";\n\t\t\t\t} else {\n\t\t\t\t\tvar econd:Dynamic = getValue(econd);\n\t\t\t\t\tecond ? getValue(eif) : getValue(eelse);\n\t\t\t\t}\n\t\t\tcase EUnop(op, false, e1):\n\t\t\t\tvar e1:Dynamic = getValue(e1);\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase OpNot: !e1;\n\t\t\t\t\tcase OpNeg: -e1;\n\t\t\t\t\tcase OpNegBits: ~e1;\n\t\t\t\t\tcase _: throw 'Unsupported expression: $e';\n\t\t\t\t}\n\t\t\tcase EBinop(op, e1, e2):\n\t\t\t\tvar e1:Dynamic = getValue(e1);\n\t\t\t\tvar e2:Dynamic = getValue(e2);\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase OpAdd: e1 + e2;\n\t\t\t\t\tcase OpSub: e1 - e2;\n\t\t\t\t\tcase OpMult: e1 * e2;\n\t\t\t\t\tcase OpDiv: e1 / e2;\n\t\t\t\t\tcase OpMod: e1 % e2;\n\t\t\t\t\tcase OpEq: e1 == e2;\n\t\t\t\t\tcase OpNotEq: e1 != e2;\n\t\t\t\t\tcase OpLt: e1 < e2;\n\t\t\t\t\tcase OpLte: e1 <= e2;\n\t\t\t\t\tcase OpGt: e1 > e2;\n\t\t\t\t\tcase OpGte: e1 >= e2;\n\t\t\t\t\tcase OpOr: e1 | e2;\n\t\t\t\t\tcase OpAnd: e1 & e2;\n\t\t\t\t\tcase OpXor: e1 ^ e2;\n\t\t\t\t\tcase OpBoolAnd: e1 && e2;\n\t\t\t\t\tcase OpBoolOr: e1 || e2;\n\t\t\t\t\tcase OpShl: e1 << e2;\n\t\t\t\t\tcase OpShr: e1 >> e2;\n\t\t\t\t\tcase OpUShr: e1 >>> e2;\n\t\t\t\t\tcase _: throw 'Unsupported expression: $e';\n\t\t\t\t}\n\t\t\tcase _: throw 'Unsupported expression: $e';\n\t\t}\n\t}\n\n\tstatic inline function opt(e:Null<Expr>, f:Expr->Expr):Expr\n\t\treturn e == null ? null : f(e);\n\n\tstatic inline function opt2(e:Null<Expr>, f:Expr->Void):Void\n\t\tif (e != null)\n\t\t\tf(e);\n}\n\n/**\n\tThis class provides functions on expression arrays for convenience. For a\n\tdetailed reference on each method, see the documentation of ExprTools.",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\n\t\tIf `e` has no sub-expressions, this operation has no effect.\n\n\t\tOtherwise `f` is called once per sub-expression of `e`, with the\n\t\tsub-expression as argument. These calls are done in order of the\n\t\tsub-expression declarations.\n\n\t\tThis method does not call itself recursively. It should instead be used\n\t\tin a recursive function which handles the expression nodes of interest.\n\n\t\tUsage example:\n\t\t```haxe\n\t\tfunction findStrings(e:Expr) {\n\t\t\tswitch(e.expr) {\n\t\t\t\tcase EConst(CString(s)):\n\t\t\t\t\t// handle s\n\t\t\t\tcase _:\n\t\t\t\t\tExprTools.iter(e, findStrings);\n\t\t\t}\n\t\t}\n\t\t```",
      "map": "Transforms the sub-expressions of `e` by calling `f` on each of them.\n\n\t\tIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\n\t\tOtherwise `f` is called once per sub-expression of `e`, with the\n\t\tsub-expression as argument. These calls are done in order of the\n\t\tsub-expression declarations.\n\n\t\tThis method does not call itself recursively. It should instead be used\n\t\tin a recursive function which handles the expression nodes of interest.\n\n\t\tUsage example:\n\t\t```haxe\n\t\tfunction capitalizeStrings(e:Expr) {\n\t\t\treturn switch(e.expr) {\n\t\t\t\tcase EConst(CString(s)):\n\t\t\t\t\t{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\n\t\t\t\tcase _:\n\t\t\t\t\tExprTools.map(e, capitalizeStrings);\n\t\t\t}\n\t\t}\n\t\t```",
      "getValue": "Returns the value `e` represents.\n\n\t\tSupported expressions are:\n\n\t\t - `Int`, `Float` and `String` literals\n\t\t - identifiers `true`, `false` and `null`\n\t\t - structure declarations if all their fields are values\n\t\t - array declarations if all their elements are values\n\t\t - unary operators `-`, `!` and `~` if the operand is a value\n\t\t - binary operators except `=>`, `...` and assignments\n\n\t\tParentheses, metadata and the `untyped` keyword are ignored.\n\n\t\tIf any non-value is encountered, an exception of type `String` is\n\t\tthrown.\n\n\t\tIf `e` is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.macro.Format": {
    "doc": "The actual macro implemented for Std.format",
    "path": "haxe\\std\\haxe\\macro\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MacroStringTools": {
    "doc": "This class provides some utility methods to work with strings in macro\n\tcontext.",
    "path": "haxe\\std\\haxe\\macro\\MacroStringTools.hx",
    "functions": {
      "isFormatExpr": "Tells if `e` is a format string, i.e. uses single quotes `'` as\n\t\tdelimiters.",
      "toFieldExpr": "Converts an array of Strings `sl` to a field expression.\n\n\t\tIf `sl` has no elements, the result is null.\n\n\t\tIf `sl` has one element, the result is `EConst(CIdent(sl[0])`.\n\n\t\tOtherwise the result is a chain of `EField` nodes.\n\n\t\tIf `sl` is null, the result is unspecified.",
      "toDotPath": "Converts a path given by package `pack` and name `name` to a `String`\n\t\tseparated by dots.\n\n\t\tIf `pack` has no elements, the result is `name`.\n\n\t\tIf `pack` is null, the result is unspecified.\n\n\t\tOtherwise the elements of `pack` are joined with a separating dot, with\n\t\tan appended dot separating the result from `name`."
    },
    "fields": {}
  },
  "haxe.macro.MacroType": {
    "doc": "This type is meant to be used to generate custom types using a macro.\n\tFor instance by doing MacroType<[my.Class.myMacro(55)]>",
    "path": "haxe\\std\\haxe\\macro\\MacroType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Printer": {
    "doc": "This class provides some utility methods to convert elements from the\n\tmacro context to a human-readable String representation.\n\n\tThis is only guaranteed to work with data that corresponds to valid Haxe\n\tsyntax.",
    "path": "haxe\\std\\haxe\\macro\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Type": {
    "doc": "Represents a reference to internal compiler structure. It exists to avoid\n\texpensive encoding if it is not required and to ensure that physical\n\tequality remains intact.\n\n\tA structure is only encoded when user requests it through `ref.get()`.\n/\ntypedef Ref<T> = {\n\tpublic function get():T;\n\tpublic function toString():String;\n}\n\n/**\n\tRepresents a type.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.AnonStatus": {
    "doc": "Represents a monomorph.\n\n\t\t@see https://haxe.org/manual/types-monomorph.html\n*/\n\tTMono(t:Ref<Null<Type>>);\n\n\t/**\n\t\tRepresents an enum instance.\n\n\t\t@see https://haxe.org/manual/types-enum-instance.html\n*/\n\tTEnum(t:Ref<EnumType>, params:Array<Type>);\n\n\t/**\n\t\tRepresents a class instance.\n\n\t\t@see https://haxe.org/manual/types-class-instance.html\n*/\n\tTInst(t:Ref<ClassType>, params:Array<Type>);\n\n\t/**\n\t\tRepresents a typedef.\n\n\t\t@see https://haxe.org/manual/type-system-typedef.html\n*/\n\tTType(t:Ref<DefType>, params:Array<Type>);\n\n\t/**\n\t\tRepresents a function type.\n\n\t\t@see https://haxe.org/manual/types-function.html\n*/\n\tTFun(args:Array<{name:String, opt:Bool, t:Type}>, ret:Type);\n\n\t/**\n\t\tRepresents an anonymous structure type.\n\n\t\t@see https://haxe.org/manual/types-anonymous-structure.html\n*/\n\tTAnonymous(a:Ref<AnonType>);\n\n\t/**\n\t\tRepresents Dynamic.\n\n\t\t@see https://haxe.org/manual/types-dynamic.html\n*/\n\tTDynamic(t:Null<Type>);\n\n\t/**\n\t\tUsed internally by the compiler to delay some typing.\n*/\n\tTLazy(f:Void->Type);\n\n\t/**\n\t\tRepresents an abstract type.\n\n\t\t@see https://haxe.org/manual/types-abstract.html\n*/\n\tTAbstract(t:Ref<AbstractType>, params:Array<Type>);\n}\n\n/**\n\tRepresents information for anonymous structure types.\n/\ntypedef AnonType = {\n\t/**\n\t\tThe class fields of the structure.\n*/\n\tvar fields:Array<ClassField>;\n\n\t/**\n\t\tThe status/kind of the structure.\n*/\n\tvar status:AnonStatus;\n}\n\n/**\n\tRepresents the kind of the anonymous structure type.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "status": "The status/kind of the structure.",
      "name": "Represents the kind of the anonymous structure type.\n*/\nenum AnonStatus {\n\t/**\n\t\tA closed structure is considered complete. That is, no further fields\n\t\tcan be added to it.\n*/\n\tAClosed;\n\n\t/**\n\t\tAn open structure allows having additional fields added to it, which is\n\t\tused during type inference. It is closed upon unification.\n*/\n\tAOpened;\n\n\t/**\n\t\tA const structure is one that appears directly in syntax. It cannot be\n\t\tassigned to a smaller structure type (that is, it does not allow\n\t\tstructural sub-typing).\n*/\n\tAConst;\n\n\t/**\n\t\tRepresents a structure which extends one or multiple structures defined\n\t\tin `tl`.\n\n\t\t@see https://haxe.org/manual/type-system-extensions.html\n*/\n\tAExtend(tl:Ref<Array<Type>>);\n\n\t/**\n\t\tA structure that represents the static fields of a class.\n*/\n\tAClassStatics(t:Ref<ClassType>);\n\n\t/**\n\t\tA structure that represents the constructors of an enum.\n*/\n\tAEnumStatics(t:Ref<EnumType>);\n\n\t/**\n\t\tA structure that represents the static fields of an abstract.\n*/\n\tAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\n\tRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n\t/**\n\t\tThe name of the type parameter."
    }
  },
  "haxe.macro.ClassKind": {
    "doc": "A closed structure is considered complete. That is, no further fields\n\t\tcan be added to it.\n*/\n\tAClosed;\n\n\t/**\n\t\tAn open structure allows having additional fields added to it, which is\n\t\tused during type inference. It is closed upon unification.\n*/\n\tAOpened;\n\n\t/**\n\t\tA const structure is one that appears directly in syntax. It cannot be\n\t\tassigned to a smaller structure type (that is, it does not allow\n\t\tstructural sub-typing).\n*/\n\tAConst;\n\n\t/**\n\t\tRepresents a structure which extends one or multiple structures defined\n\t\tin `tl`.\n\n\t\t@see https://haxe.org/manual/type-system-extensions.html\n*/\n\tAExtend(tl:Ref<Array<Type>>);\n\n\t/**\n\t\tA structure that represents the static fields of a class.\n*/\n\tAClassStatics(t:Ref<ClassType>);\n\n\t/**\n\t\tA structure that represents the constructors of an enum.\n*/\n\tAEnumStatics(t:Ref<EnumType>);\n\n\t/**\n\t\tA structure that represents the static fields of an abstract.\n*/\n\tAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\n\tRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n\t/**\n\t\tThe name of the type parameter.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the type parameter. It is guaranteed to be a `TInst` with a\n\t\t`KTypeParameter` kind.\n*/\n\tvar t:Type;\n\n\t/**\n\t\tThe default type for this type parameter.\n*/\n\tvar ?defaultType:Null<Type>;\n}\n\n/**\n\tRepresents a class field.\n/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the class field.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the class field.\n*/\n\tvar type:Type;\n\n\t/**\n\t\tWhether or not the class field is public.\n*/\n\tvar isPublic:Bool;\n\n\t/**\n\t\tWhether or not the class field is extern.\n*/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tWhether or not the class field is final.\n*/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the class field is abstract.\n*/\n\tvar isAbstract:Bool;\n\n\t/**\n\t\tThe type parameters of the class field.\n*/\n\tvar params:Array<TypeParameter>;\n\n\t/**\n\t\tThe metadata of the class field.\n*/\n\tvar meta:MetaAccess;\n\n\t/**\n\t\tThe class field kind.\n*/\n\tvar kind:FieldKind;\n\n\t/**\n\t\tReturns the typed expression of the class field.\n*/\n\tfunction expr():Null<TypedExpr>;\n\n\t/**\n\t\tThe position of the class field.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tThe associated documentation of the class field.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe overload fields of the class field.\n*/\n\tvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\n\tRepresents an enum constructor.\n/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the enum constructor.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the enum constructor.\n*/\n\tvar type:Type;\n\n\t/**\n\t\tThe position of the enum constructor.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tThe metadata of the enum constructor.\n*/\n\tvar meta:MetaAccess;\n\n\t/**\n\t\tThe index of the enum constructor, i.e. in which position it appears\n\t\tin the syntax.\n*/\n\tvar index:Int;\n\n\t/**\n\t\tThe associated documentation of the enum constructor.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe type parameters of the enum constructor.\n*/\n\tvar params:Array<TypeParameter>;\n}\n\n/**\n\tRepresents the kind of a class.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "exclude": "The position of the class field.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tThe associated documentation of the class field.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe overload fields of the class field.\n*/\n\tvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\n\tRepresents an enum constructor.\n/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the enum constructor.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the enum constructor.\n*/\n\tvar type:Type;\n\n\t/**\n\t\tThe position of the enum constructor.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tThe metadata of the enum constructor.\n*/\n\tvar meta:MetaAccess;\n\n\t/**\n\t\tThe index of the enum constructor, i.e. in which position it appears\n\t\tin the syntax.\n*/\n\tvar index:Int;\n\n\t/**\n\t\tThe associated documentation of the enum constructor.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe type parameters of the enum constructor.\n*/\n\tvar params:Array<TypeParameter>;\n}\n\n/**\n\tRepresents the kind of a class.\n/\nenum ClassKind {\n\t/**\n\t\tA normal class.\n*/\n\tKNormal;\n\n\t/**\n\t\tA type parameter class with a set of constraints.\n*/\n\tKTypeParameter(constraints:Array<Type>);\n\n\t/**\n\t\tA class containing module fields.\n*/\n\tKModuleFields(module:String);\n\n\t/**\n\t\tA special kind of class to encode expressions into type parameters.\n*/\n\tKExpr(expr:Expr);\n\n\t/**\n\t\tA `@:generic` base class.\n*/\n\tKGeneric;\n\n\t/**\n\t\tA concrete `@:generic` instance, referencing the original class and the\n\t\tapplied type parameters.\n*/\n\tKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n\t/**\n\t\tA special class for `haxe.macro.MacroType`.\n\n\t\t@deprecated\n*/\n\tKMacroType;\n\n\t/**\n\t\tAn implementation class of an abstract, i.e. where all its run-time code\n\t\tis.\n*/\n\tKAbstractImpl(a:Ref<AbstractType>);\n\n\t/**\n\t\tA `@:genericBuild` class\n*/\n\tKGenericBuild;\n}\n\n/**\n\tThe information that all types (`ClassType`, `EnumType`, `DefType`,\n\t`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n\t/**\n\t\tThe package of the type.\n*/\n\tvar pack:Array<String>;\n\n\t/**\n\t\tThe name of the type.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe module name of the type, which might be different.\n*/\n\tvar module:String;\n\n\t/**\n\t\tThe position of the type.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tWhether or not the type is private.\n*/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tWhether or not the type is extern.\n*/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe type parameters of the type.\n*/\n\tvar params:Array<TypeParameter>;\n\n\t/**\n\t\tThe metadata of the type.\n*/\n\tvar meta:MetaAccess;\n\n\t/**\n\t\tThe associated documentation of the class field.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tAllows excluding the type from compilation."
    },
    "fields": {
      "t": "The type of the type parameter. It is guaranteed to be a `TInst` with a\n\t\t`KTypeParameter` kind.",
      "name": "Represents an enum constructor.\n/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the enum constructor.",
      "type": "The type of the enum constructor.",
      "isPublic": "Whether or not the class field is public.",
      "isExtern": "Whether or not the class field is extern.",
      "isFinal": "Whether or not the class field is final.",
      "isAbstract": "Whether or not the class field is abstract.",
      "params": "The type parameters of the enum constructor.",
      "meta": "The metadata of the enum constructor.",
      "kind": "The class field kind.",
      "pos": "The position of the enum constructor.",
      "doc": "The associated documentation of the enum constructor.",
      "overloads": "The overload fields of the class field.",
      "index": "The index of the enum constructor, i.e. in which position it appears\n\t\tin the syntax.",
      "pack": "Represents the kind of a class.\n/\nenum ClassKind {\n\t/**\n\t\tA normal class.\n*/\n\tKNormal;\n\n\t/**\n\t\tA type parameter class with a set of constraints.\n*/\n\tKTypeParameter(constraints:Array<Type>);\n\n\t/**\n\t\tA class containing module fields.\n*/\n\tKModuleFields(module:String);\n\n\t/**\n\t\tA special kind of class to encode expressions into type parameters.\n*/\n\tKExpr(expr:Expr);\n\n\t/**\n\t\tA `@:generic` base class.\n*/\n\tKGeneric;\n\n\t/**\n\t\tA concrete `@:generic` instance, referencing the original class and the\n\t\tapplied type parameters.\n*/\n\tKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n\t/**\n\t\tA special class for `haxe.macro.MacroType`.\n\n\t\t@deprecated\n*/\n\tKMacroType;\n\n\t/**\n\t\tAn implementation class of an abstract, i.e. where all its run-time code\n\t\tis.\n*/\n\tKAbstractImpl(a:Ref<AbstractType>);\n\n\t/**\n\t\tA `@:genericBuild` class\n*/\n\tKGenericBuild;\n}\n\n/**\n\tThe information that all types (`ClassType`, `EnumType`, `DefType`,\n\t`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n\t/**\n\t\tThe package of the type."
    }
  },
  "haxe.macro.FieldKind": {
    "doc": "A normal class.\n*/\n\tKNormal;\n\n\t/**\n\t\tA type parameter class with a set of constraints.\n*/\n\tKTypeParameter(constraints:Array<Type>);\n\n\t/**\n\t\tA class containing module fields.\n*/\n\tKModuleFields(module:String);\n\n\t/**\n\t\tA special kind of class to encode expressions into type parameters.\n*/\n\tKExpr(expr:Expr);\n\n\t/**\n\t\tA `@:generic` base class.\n*/\n\tKGeneric;\n\n\t/**\n\t\tA concrete `@:generic` instance, referencing the original class and the\n\t\tapplied type parameters.\n*/\n\tKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n\t/**\n\t\tA special class for `haxe.macro.MacroType`.\n\n\t\t@deprecated\n*/\n\tKMacroType;\n\n\t/**\n\t\tAn implementation class of an abstract, i.e. where all its run-time code\n\t\tis.\n*/\n\tKAbstractImpl(a:Ref<AbstractType>);\n\n\t/**\n\t\tA `@:genericBuild` class\n*/\n\tKGenericBuild;\n}\n\n/**\n\tThe information that all types (`ClassType`, `EnumType`, `DefType`,\n\t`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n\t/**\n\t\tThe package of the type.\n*/\n\tvar pack:Array<String>;\n\n\t/**\n\t\tThe name of the type.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe module name of the type, which might be different.\n*/\n\tvar module:String;\n\n\t/**\n\t\tThe position of the type.\n*/\n\tvar pos:Expr.Position;\n\n\t/**\n\t\tWhether or not the type is private.\n*/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tWhether or not the type is extern.\n*/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe type parameters of the type.\n*/\n\tvar params:Array<TypeParameter>;\n\n\t/**\n\t\tThe metadata of the type.\n*/\n\tvar meta:MetaAccess;\n\n\t/**\n\t\tThe associated documentation of the class field.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tAllows excluding the type from compilation.\n*/\n\tfunction exclude():Void;\n}\n\n/**\n\tRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n\t/**\n\t\tThe kind of the class.\n*/\n\tvar kind:ClassKind;\n\n\t/**\n\t\tIf true the type is an interface, otherwise it is a class.\n*/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tIf true the class is final and cannot be extended.\n*/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tIf true the class is abstract and cannot be instantiated directly.\n*/\n\tvar isAbstract:Bool;\n\n\t/**\n\t\tThe parent class and its type parameters, if available.\n*/\n\tvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n\t/**\n\t\tThe implemented interfaces and their type parameters.\n*/\n\tvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n\t/**\n\t\tThe member fields of the class.\n*/\n\tvar fields:Ref<Array<ClassField>>;\n\n\t/**\n\t\tThe static fields of the class.\n*/\n\tvar statics:Ref<Array<ClassField>>;\n\n\t// var dynamic : Null<Type>;\n\t// var arrayAccess : Null<Type>;\n\n\t/**\n\t\tThe constructor of the class, if available.\n*/\n\tvar constructor:Null<Ref<ClassField>>;\n\n\t/**\n\t\tThe `__init__` expression of the class, if available.\n*/\n\tvar init:Null<TypedExpr>;\n\n\t/**\n\t\tThe list of fields that have override status.\n*/\n\tvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\n\tRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n\t/**\n\t\tThe available enum constructors.\n*/\n\tvar constructs:Map<String, EnumField>;\n\n\t/**\n\t\tAn ordered list of enum constructor names.\n*/\n\tvar names:Array<String>;\n}\n\n/**\n\tRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n\t/**\n\t\tThe target type of the typedef.\n*/\n\tvar type:Type;\n}\n\n/**\n\tRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n\t/**\n\t\tThe underlying type of the abstract.\n*/\n\tvar type:Type;\n\n\t/**\n\t\tThe implementation class of the abstract, if available.\n*/\n\tvar impl:Null<Ref<ClassType>>;\n\n\t/**\n\t\tThe defined binary operators of the abstract.\n*/\n\tvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n\t/**\n\t\tThe defined unary operators of the abstract.\n*/\n\tvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n\t/**\n\t\tThe available implicit from-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\n\tvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n\t/**\n\t\tThe available implicit to-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\n\tvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n\t/**\n\t\tThe defined array-access fields of the abstract.\n*/\n\tvar array:Array<ClassField>;\n\n\t/**\n\t\tThe method used for resolving unknown field access, if available.\n*/\n\tvar resolve:Null<ClassField>;\n\n\t/**\n\t\tThe method used for resolving unknown field access, if available.\n*/\n\tvar resolveWrite:Null<ClassField>;\n\n\t/**\n\t\tThe expression given as a default value for this abstract, if available.\n*/\n\tvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\n\tMetaAccess is a wrapper for the `Metadata` array. It can be used to add\n\tmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n\t/**\n\t\tReturn the wrapped `Metadata` array.\n\n\t\tModifying this array has no effect on the origin of `this` MetaAccess.\n\t\tThe `add` and `remove` methods can be used for that.\n*/\n\tfunction get():Expr.Metadata;\n\n\t/**\n\t\tExtract metadata entries by given `name`.\n\n\t\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n\t/**\n\t\tAdds the metadata specified by `name`, `params` and `pos` to the origin\n\t\tof `this` MetaAccess.\n\n\t\tMetadata names are not unique during compilation, so this method never\n\t\toverwrites a previous metadata.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `add` has no effect on that array.\n\n\t\tIf any argument is null, compilation fails with an error.\n*/\n\tfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n\t/**\n\t\tRemoves all `name` metadata entries from the origin of `this`\n\t\tMetaAccess.\n\n\t\tThis method might clear several metadata entries of the same name.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `remove` has no effect on that array.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction remove(name:String):Void;\n\n\t/**\n\t\tTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction has(name:String):Bool;\n}\n\n/**\n\tRepresents a field kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "get": "Represents a class type.\n/\ntypedef ClassType = BaseType & {\n\t/**\n\t\tThe kind of the class.\n*/\n\tvar kind:ClassKind;\n\n\t/**\n\t\tIf true the type is an interface, otherwise it is a class.\n*/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tIf true the class is final and cannot be extended.\n*/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tIf true the class is abstract and cannot be instantiated directly.\n*/\n\tvar isAbstract:Bool;\n\n\t/**\n\t\tThe parent class and its type parameters, if available.\n*/\n\tvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n\t/**\n\t\tThe implemented interfaces and their type parameters.\n*/\n\tvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n\t/**\n\t\tThe member fields of the class.\n*/\n\tvar fields:Ref<Array<ClassField>>;\n\n\t/**\n\t\tThe static fields of the class.\n*/\n\tvar statics:Ref<Array<ClassField>>;\n\n\t// var dynamic : Null<Type>;\n\t// var arrayAccess : Null<Type>;\n\n\t/**\n\t\tThe constructor of the class, if available.\n*/\n\tvar constructor:Null<Ref<ClassField>>;\n\n\t/**\n\t\tThe `__init__` expression of the class, if available.\n*/\n\tvar init:Null<TypedExpr>;\n\n\t/**\n\t\tThe list of fields that have override status.\n*/\n\tvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\n\tRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n\t/**\n\t\tThe available enum constructors.\n*/\n\tvar constructs:Map<String, EnumField>;\n\n\t/**\n\t\tAn ordered list of enum constructor names.\n*/\n\tvar names:Array<String>;\n}\n\n/**\n\tRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n\t/**\n\t\tThe target type of the typedef.\n*/\n\tvar type:Type;\n}\n\n/**\n\tRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n\t/**\n\t\tThe underlying type of the abstract.\n*/\n\tvar type:Type;\n\n\t/**\n\t\tThe implementation class of the abstract, if available.\n*/\n\tvar impl:Null<Ref<ClassType>>;\n\n\t/**\n\t\tThe defined binary operators of the abstract.\n*/\n\tvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n\t/**\n\t\tThe defined unary operators of the abstract.\n*/\n\tvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n\t/**\n\t\tThe available implicit from-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\n\tvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n\t/**\n\t\tThe available implicit to-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\n\tvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n\t/**\n\t\tThe defined array-access fields of the abstract.\n*/\n\tvar array:Array<ClassField>;\n\n\t/**\n\t\tThe method used for resolving unknown field access, if available.\n*/\n\tvar resolve:Null<ClassField>;\n\n\t/**\n\t\tThe method used for resolving unknown field access, if available.\n*/\n\tvar resolveWrite:Null<ClassField>;\n\n\t/**\n\t\tThe expression given as a default value for this abstract, if available.\n*/\n\tvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\n\tMetaAccess is a wrapper for the `Metadata` array. It can be used to add\n\tmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n\t/**\n\t\tReturn the wrapped `Metadata` array.\n\n\t\tModifying this array has no effect on the origin of `this` MetaAccess.\n\t\tThe `add` and `remove` methods can be used for that.",
      "extract": "Extract metadata entries by given `name`.\n\n\t\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\t\tIf `name` is null, compilation fails with an error.",
      "add": "Adds the metadata specified by `name`, `params` and `pos` to the origin\n\t\tof `this` MetaAccess.\n\n\t\tMetadata names are not unique during compilation, so this method never\n\t\toverwrites a previous metadata.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `add` has no effect on that array.\n\n\t\tIf any argument is null, compilation fails with an error.",
      "remove": "Removes all `name` metadata entries from the origin of `this`\n\t\tMetaAccess.\n\n\t\tThis method might clear several metadata entries of the same name.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `remove` has no effect on that array.\n\n\t\tIf `name` is null, compilation fails with an error.",
      "has": "Tells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\t\tIf `name` is null, compilation fails with an error."
    },
    "fields": {
      "name": "The name of the type.",
      "module": "The module name of the type, which might be different.",
      "pos": "The position of the type.",
      "isPrivate": "Whether or not the type is private.",
      "isExtern": "Whether or not the type is extern.",
      "params": "The type parameters of the type.",
      "meta": "The metadata of the type.",
      "doc": "The associated documentation of the class field.",
      "kind": "Allows excluding the type from compilation.\n*/\n\tfunction exclude():Void;\n}\n\n/**\n\tRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n\t/**\n\t\tThe kind of the class.",
      "isInterface": "If true the type is an interface, otherwise it is a class.",
      "isFinal": "If true the class is final and cannot be extended.",
      "isAbstract": "If true the class is abstract and cannot be instantiated directly.",
      "superClass": "The parent class and its type parameters, if available.",
      "interfaces": "The implemented interfaces and their type parameters.",
      "fields": "The member fields of the class.",
      "statics": "The static fields of the class.",
      "constructor": "The constructor of the class, if available.",
      "init": "The `__init__` expression of the class, if available.",
      "overrides": "The list of fields that have override status.",
      "constructs": "Represents an enum type.\n/\ntypedef EnumType = BaseType & {\n\t/**\n\t\tThe available enum constructors.",
      "names": "An ordered list of enum constructor names.",
      "type": "Represents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n\t/**\n\t\tThe underlying type of the abstract.",
      "impl": "The implementation class of the abstract, if available.",
      "binops": "The defined binary operators of the abstract.",
      "unops": "The defined unary operators of the abstract.",
      "from": "The available implicit from-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html",
      "to": "The available implicit to-casts of the abstract.\n\n\t\t@see https://haxe.org/manual/types-abstract-implicit-casts.html",
      "array": "The defined array-access fields of the abstract.",
      "resolve": "The method used for resolving unknown field access, if available.",
      "resolveWrite": "The method used for resolving unknown field access, if available.",
      "defaultValue": "The expression given as a default value for this abstract, if available.",
      "args": "MetaAccess is a wrapper for the `Metadata` array. It can be used to add\n\tmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n\t/**\n\t\tReturn the wrapped `Metadata` array.\n\n\t\tModifying this array has no effect on the origin of `this` MetaAccess.\n\t\tThe `add` and `remove` methods can be used for that.\n*/\n\tfunction get():Expr.Metadata;\n\n\t/**\n\t\tExtract metadata entries by given `name`.\n\n\t\tIf there's no metadata with such name, empty array `[]` is returned.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n\t/**\n\t\tAdds the metadata specified by `name`, `params` and `pos` to the origin\n\t\tof `this` MetaAccess.\n\n\t\tMetadata names are not unique during compilation, so this method never\n\t\toverwrites a previous metadata.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `add` has no effect on that array.\n\n\t\tIf any argument is null, compilation fails with an error.\n*/\n\tfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n\t/**\n\t\tRemoves all `name` metadata entries from the origin of `this`\n\t\tMetaAccess.\n\n\t\tThis method might clear several metadata entries of the same name.\n\n\t\tIf a `Metadata` array is obtained through a call to `get`, a subsequent\n\t\tcall to `remove` has no effect on that array.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction remove(name:String):Void;\n\n\t/**\n\t\tTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\n\t\tIf `name` is null, compilation fails with an error.\n*/\n\tfunction has(name:String):Bool;\n}\n\n/**\n\tRepresents a field kind.\n/\nenum FieldKind {\n\t/**\n\t\tA variable or property, depending on the `read` and `write` values.\n*/\n\tFVar(read:VarAccess, write:VarAccess);\n\n\t/**\n\t\tA method\n*/\n\tFMethod(k:MethodKind);\n}\n\n/**\n\tRepresents the variable accessor.\n/\nenum VarAccess {\n\t/**\n\t\tNormal access (`default`).\n*/\n\tAccNormal;\n\n\t/**\n\t\tPrivate access (`null`).\n*/\n\tAccNo;\n\n\t/**\n\t\tNo access (`never`).\n*/\n\tAccNever;\n\n\t/**\n\t\tUnused.\n*/\n\tAccResolve;\n\n\t/**\n\t\tAccess through accessor function (`get`, `set`, `dynamic`).\n*/\n\tAccCall;\n\n\t/**\n\t\tAccess through private accessor function (`private get`, `private set`).\n*/\n\tAccPrivateCall;\n\n\t/**\n\t\tInline access (`inline`).\n*/\n\tAccInline;\n\n\t/**\n\t\tFailed access due to a `@:require` metadata.\n*/\n\tAccRequire(r:String, ?msg:String);\n\n\t/**\n\t\tAccess is only allowed from the constructor.\n*/\n\tAccCtor;\n}\n\n/**\n\tRepresents the method kind.\n/\nenum MethodKind {\n\t/**\n\t\tA normal method.\n*/\n\tMethNormal;\n\n\t/**\n\t\tAn inline method.\n\n\t\t@see https://haxe.org/manual/class-field-inline.html\n*/\n\tMethInline;\n\n\t/**\n\t\tA dynamic, rebindable method.\n\n\t\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\n\tMethDynamic;\n\n\t/**\n\t\tA macro method.\n*/\n\tMethMacro;\n}\n\n/**\n\tRepresents typed constant.\n/\nenum TConstant {\n\t/**\n\t\tAn `Int` literal.\n*/\n\tTInt(i:Int);\n\n\t/**\n\t\tA `Float` literal, represented as String to avoid precision loss.\n*/\n\tTFloat(s:String);\n\n\t/**\n\t\tA `String` literal.\n*/\n\tTString(s:String);\n\n\t/**\n\t\tA `Bool` literal.\n*/\n\tTBool(b:Bool);\n\n\t/**\n\t\tThe constant `null`.\n*/\n\tTNull;\n\n\t/**\n\t\tThe constant `this`.\n*/\n\tTThis;\n\n\t/**\n\t\tThe constant `super`.\n*/\n\tTSuper;\n}\n\n/**\n\tRepresents a module type. These are the types that can be declared in a Haxe\n\tmodule and which are passed to the generators (except `TTypeDecl`).\n/\nenum ModuleType {\n\t/**\n\t\tA class.\n*/\n\tTClassDecl(c:Ref<ClassType>);\n\n\t/**\n\t\tAn enum.\n*/\n\tTEnumDecl(e:Ref<EnumType>);\n\n\t/**\n\t\tA typedef.\n*/\n\tTTypeDecl(t:Ref<DefType>);\n\n\t/**\n\t\tAn abstract.\n*/\n\tTAbstract(a:Ref<AbstractType>);\n}\n\n/**\n\tRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n\t/**\n\t\tA list of function arguments identified by an argument variable `v` and\n\t\tan optional initialization `value`."
    }
  },
  "haxe.macro.VarAccess": {
    "doc": "A variable or property, depending on the `read` and `write` values.\n*/\n\tFVar(read:VarAccess, write:VarAccess);\n\n\t/**\n\t\tA method\n*/\n\tFMethod(k:MethodKind);\n}\n\n/**\n\tRepresents the variable accessor.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MethodKind": {
    "doc": "Normal access (`default`).\n*/\n\tAccNormal;\n\n\t/**\n\t\tPrivate access (`null`).\n*/\n\tAccNo;\n\n\t/**\n\t\tNo access (`never`).\n*/\n\tAccNever;\n\n\t/**\n\t\tUnused.\n*/\n\tAccResolve;\n\n\t/**\n\t\tAccess through accessor function (`get`, `set`, `dynamic`).\n*/\n\tAccCall;\n\n\t/**\n\t\tAccess through private accessor function (`private get`, `private set`).\n*/\n\tAccPrivateCall;\n\n\t/**\n\t\tInline access (`inline`).\n*/\n\tAccInline;\n\n\t/**\n\t\tFailed access due to a `@:require` metadata.\n*/\n\tAccRequire(r:String, ?msg:String);\n\n\t/**\n\t\tAccess is only allowed from the constructor.\n*/\n\tAccCtor;\n}\n\n/**\n\tRepresents the method kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TConstant": {
    "doc": "A normal method.\n*/\n\tMethNormal;\n\n\t/**\n\t\tAn inline method.\n\n\t\t@see https://haxe.org/manual/class-field-inline.html\n*/\n\tMethInline;\n\n\t/**\n\t\tA dynamic, rebindable method.\n\n\t\t@see https://haxe.org/manual/class-field-dynamic.html\n*/\n\tMethDynamic;\n\n\t/**\n\t\tA macro method.\n*/\n\tMethMacro;\n}\n\n/**\n\tRepresents typed constant.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ModuleType": {
    "doc": "An `Int` literal.\n*/\n\tTInt(i:Int);\n\n\t/**\n\t\tA `Float` literal, represented as String to avoid precision loss.\n*/\n\tTFloat(s:String);\n\n\t/**\n\t\tA `String` literal.\n*/\n\tTString(s:String);\n\n\t/**\n\t\tA `Bool` literal.\n*/\n\tTBool(b:Bool);\n\n\t/**\n\t\tThe constant `null`.\n*/\n\tTNull;\n\n\t/**\n\t\tThe constant `this`.\n*/\n\tTThis;\n\n\t/**\n\t\tThe constant `super`.\n*/\n\tTSuper;\n}\n\n/**\n\tRepresents a module type. These are the types that can be declared in a Haxe\n\tmodule and which are passed to the generators (except `TTypeDecl`).",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.FieldAccess": {
    "doc": "A class.\n*/\n\tTClassDecl(c:Ref<ClassType>);\n\n\t/**\n\t\tAn enum.\n*/\n\tTEnumDecl(e:Ref<EnumType>);\n\n\t/**\n\t\tA typedef.\n*/\n\tTTypeDecl(t:Ref<DefType>);\n\n\t/**\n\t\tAn abstract.\n*/\n\tTAbstract(a:Ref<AbstractType>);\n}\n\n/**\n\tRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n\t/**\n\t\tA list of function arguments identified by an argument variable `v` and\n\t\tan optional initialization `value`.\n*/\n\tvar args:Array<{v:TVar, value:Null<TypedExpr>}>;\n\n\t/**\n\t\tThe return type of the function.\n*/\n\tvar t:Type;\n\n\t/**\n\t\tThe expression of the function body.\n*/\n\tvar expr:TypedExpr;\n}\n\n/**\n\tRepresents the kind of field access in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "t": "The return type of the function.",
      "expr": "The expression of the function body.",
      "id": "Represents the kind of field access in the typed AST.\n/\nenum FieldAccess {\n\t/**\n\t\tAccess of field `cf` on a class instance `c` with type parameters\n\t\t`params`.\n*/\n\tFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n\t/**\n\t\tStatic access of a field `cf` on a class `c`.\n*/\n\tFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n\t/**\n\t\tAccess of field `cf` on an anonymous structure.\n*/\n\tFAnon(cf:Ref<ClassField>);\n\n\t/**\n\t\tDynamic field access of a field named `s`.\n*/\n\tFDynamic(s:String);\n\n\t/**\n\t\tClosure field access of field `cf` on a class instance `c` with type\n\t\tparameters `params`.\n*/\n\tFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n\t/**\n\t\tField access to an enum constructor `ef` of enum `e`.\n*/\n\tFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\n\tRepresents kind of a node in the typed AST.\n/\nenum TypedExprDef {\n\t/**\n\t\tA constant.\n*/\n\tTConst(c:TConstant);\n\n\t/**\n\t\tReference to a local variable `v`.\n*/\n\tTLocal(v:TVar);\n\n\t/**\n\t\tArray access `e1[e2]`.\n*/\n\tTArray(e1:TypedExpr, e2:TypedExpr);\n\n\t/**\n\t\tBinary operator `e1 op e2`.\n*/\n\tTBinop(op:Expr.Binop, e1:TypedExpr, e2:TypedExpr);\n\n\t/**\n\t\tField access on `e` according to `fa`.\n*/\n\tTField(e:TypedExpr, fa:FieldAccess);\n\n\t/**\n\t\tReference to a module type `m`.\n*/\n\tTTypeExpr(m:ModuleType);\n\n\t/**\n\t\tParentheses `(e)`.\n*/\n\tTParenthesis(e:TypedExpr);\n\n\t/**\n\t\tAn object declaration.\n*/\n\tTObjectDecl(fields:Array<{name:String, expr:TypedExpr}>);\n\n\t/**\n\t\tAn array declaration `[el]`.\n*/\n\tTArrayDecl(el:Array<TypedExpr>);\n\n\t/**\n\t\tA call `e(el)`.\n*/\n\tTCall(e:TypedExpr, el:Array<TypedExpr>);\n\n\t/**\n\t\tA constructor call `new c<params>(el)`.\n*/\n\tTNew(c:Ref<ClassType>, params:Array<Type>, el:Array<TypedExpr>);\n\n\t/**\n\t\tAn unary operator `op` on `e`:\n\ne++ (op = OpIncrement, postFix = true)\ne-- (op = OpDecrement, postFix = true)\n++e (op = OpIncrement, postFix = false)\n--e (op = OpDecrement, postFix = false)\n-e (op = OpNeg, postFix = false)\n!e (op = OpNot, postFix = false)\n~e (op = OpNegBits, postFix = false)\n*/\n\tTUnop(op:Expr.Unop, postFix:Bool, e:TypedExpr);\n\n\t/**\n\t\tA function declaration.\n*/\n\tTFunction(tfunc:TFunc);\n\n\t/**\n\t\tA variable declaration `var v` or `var v = expr`.\n*/\n\tTVar(v:TVar, expr:Null<TypedExpr>);\n\n\t/**\n\t\tA block declaration `{el}`.\n*/\n\tTBlock(el:Array<TypedExpr>);\n\n\t/**\n\t\tA `for` expression.\n*/\n\tTFor(v:TVar, e1:TypedExpr, e2:TypedExpr);\n\n\t/**\n\t\tAn `if(econd) eif` or `if(econd) eif else eelse` expression.\n*/\n\tTIf(econd:TypedExpr, eif:TypedExpr, eelse:Null<TypedExpr>);\n\n\t/**\n\t\tRepresents a `while` expression.\n\t\tWhen `normalWhile` is `true` it is `while (...)`.\n\t\tWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\n\tTWhile(econd:TypedExpr, e:TypedExpr, normalWhile:Bool);\n\n\t/**\n\t\tRepresents a `switch` expression with related cases and an optional\n\t\t`default` case if edef != null.\n*/\n\tTSwitch(e:TypedExpr, cases:Array<{values:Array<TypedExpr>, expr:TypedExpr}>, edef:Null<TypedExpr>);\n\n\t/**\n\t\tRepresents a `try`-expression with related catches.\n*/\n\tTTry(e:TypedExpr, catches:Array<{v:TVar, expr:TypedExpr}>);\n\n\t/**\n\t\tA `return` or `return e` expression.\n*/\n\tTReturn(e:Null<TypedExpr>);\n\n\t/**\n\t\tA `break` expression.\n*/\n\tTBreak;\n\n\t/**\n\t\tA `continue` expression.\n*/\n\tTContinue;\n\n\t/**\n\t\tA `throw e` expression.\n*/\n\tTThrow(e:TypedExpr);\n\n\t/**\n\t\tA `cast e` or `cast (e, m)` expression.\n*/\n\tTCast(e:TypedExpr, m:Null<ModuleType>);\n\n\t/**\n\t\tA `@m e1` expression.\n*/\n\tTMeta(m:Expr.MetadataEntry, e1:TypedExpr);\n\n\t/**\n\t\tAccess to an enum parameter (generated by the pattern matcher).\n*/\n\tTEnumParameter(e1:TypedExpr, ef:EnumField, index:Int);\n\n\t/**\n\t\tAccess to an enum index (generated by the pattern matcher).\n*/\n\tTEnumIndex(e1:TypedExpr);\n\n\t/**\n\t\tAn unknown identifier.\n*/\n\tTIdent(s:String);\n}\n\n/**\n\tRepresents a variable in the typed AST.\n/\ntypedef TVar = {\n\t/**\n\t\tThe unique ID of the variable."
    }
  },
  "haxe.macro.TypedExprDef": {
    "doc": "Access of field `cf` on a class instance `c` with type parameters\n\t\t`params`.\n*/\n\tFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n\t/**\n\t\tStatic access of a field `cf` on a class `c`.\n*/\n\tFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n\t/**\n\t\tAccess of field `cf` on an anonymous structure.\n*/\n\tFAnon(cf:Ref<ClassField>);\n\n\t/**\n\t\tDynamic field access of a field named `s`.\n*/\n\tFDynamic(s:String);\n\n\t/**\n\t\tClosure field access of field `cf` on a class instance `c` with type\n\t\tparameters `params`.\n*/\n\tFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n\t/**\n\t\tField access to an enum constructor `ef` of enum `e`.\n*/\n\tFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\n\tRepresents kind of a node in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "name": "The name of the variable.",
      "t": "The type of the expression.",
      "capture": "Whether or not the variable has been captured by a closure.",
      "extra": "Special information which is internally used to keep track of closure.\n\t\tinformation",
      "meta": "The metadata of the variable.",
      "isStatic": "Whether the variable is a local static variable",
      "expr": "Represents a typed AST node.\n/\ntypedef TypedExpr = {\n\t/**\n\t\tThe expression kind.",
      "pos": "The position of the expression."
    }
  },
  "haxe.macro.TypedExprTools": {
    "doc": "This class provides some utility methods to work with typed expressions.\n\tIt is best used through 'using haxe.macro.TypedExprTools' syntax and then\n\tprovides additional methods on `haxe.macro.TypedExpr` instances.",
    "path": "haxe\\std\\haxe\\macro\\TypedExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\n\t\tSee `haxe.macro.ExprTools.iter` for details on iterating expressions in\n\t\tgeneral. This function works the same way, but with a different data\n\t\tstructure.",
      "mapWithType": "Transforms the sub-expressions of `e` by calling `f` on each of them.\n\t\tAdditionally, types are mapped using `ft` and variables are mapped using\n\t\t`fv`.\n\n\t\tSee `haxe.macro.ExprTools.map` for details on expression mapping in\n\t\tgeneral. This function works the same way, but with a different data\n\t\tstructure."
    },
    "fields": {}
  },
  "haxe.macro.TypeTools": {
    "doc": "This class provides some utility methods to work with types. It is\n\tbest used through 'using haxe.macro.TypeTools' syntax and then provides\n\tadditional methods on haxe.macro.Type instances.",
    "path": "haxe\\std\\haxe\\macro\\TypeTools.hx",
    "functions": {
      "follow": "Follows all typedefs of `t` to reach the actual type.\n\n\t\tIf `once` is true, this function does not call itself recursively,\n\t\totherwise it does. This can be useful in cases where intermediate\n\t\ttypedefs might be of interest.\n\n\t\tAffected types are monomorphs `TMono` and typedefs `TType(t,pl)`.\n\n\t\tIf `t` is null, an internal exception is thrown.\n\n\t\tUsage example with monomorphs:\n\t\t\tvar t = Context.typeof(macro null); // TMono(<mono>)\n\t\t\tvar ts = Context.typeof(macro \"foo\"); //TInst(String,[])\n\t\t\tContext.unify(t, ts);\n\t\t\ttrace(t); // TMono(<mono>)\n\t\t\ttrace(t.follow()); //TInst(String,[])\n\n\t\tUsage example with typedefs:\n\t\t\tvar t = Context.typeof(macro (\"foo\" :MyString)); // typedef MyString = String\n\t\t\ttrace(t); // TType(MyString,[])\n\t\t\ttrace(t.follow()); //TInst(String,[])",
      "followWithAbstracts": "Like `follow`, follows all typedefs of `t` to reach the actual type.\n\n\t\tWill however follow also abstracts to their underlying implementation,\n\t\tif they are not a @:coreType abstract\n\n\t\tIf `t` is null, an internal exception is thrown.\n\n\t\tUsage example:\n\t\t\tvar t = Context.typeof(macro new Map<String, String>());\n\t\t\ttrace(t); // TAbstract(Map,[TInst(String,[]),TInst(String,[])])\n\t\t\ttrace(t.followWithAbstracts()); // TInst(haxe.ds.StringMap, [TInst(String,[])])",
      "unify": "Returns true if `t1` and `t2` unify, false otherwise.",
      "getClass": "Tries to extract the class instance stored inside `t`.\n\n\t\tIf `t` is a class instance `TInst(c,pl)`, c is returned.\n\n\t\tIf `t` is of a different type, an exception of type String is thrown.\n\n\t\tIf `t` is null, the result is null.",
      "getEnum": "Tries to extract the enum instance stored inside `t`.\n\n\t\tIf `t` is an enum instance `TEnum(e,pl)`, e is returned.\n\n\t\tIf `t` is of a different type, an exception of type String is thrown.\n\n\t\tIf `t` is null, the result is null.",
      "applyTypeParameters": "Applies the type parameters `typeParameters` to type `t` with the given\n\t\ttypes `concreteTypes`.\n\n\t\tThis function replaces occurrences of type parameters in `t` if they are\n\t\tpart of `typeParameters`. The array index of such a type parameter is\n\t\tthen used to lookup the concrete type in `concreteTypes`.\n\n\t\tIf `typeParameters.length` is not equal to `concreteTypes.length`, an\n\t\texception of type `String` is thrown.\n\n\t\tIf `typeParameters.length` is 0, `t` is returned unchanged.\n\n\t\tIf either argument is `null`, the result is unspecified.",
      "map": "Transforms `t` by calling `f` on each of its subtypes.\n\n\t\tIf `t` is a compound type, `f` is called on each of its components.\n\n\t\tOtherwise `t` is returned unchanged.\n\n\t\tThe following types are considered compound:\n\t\t\t- TInst, TEnum, TType and TAbstract with type parameters\n\t\t\t- TFun\n\t\t\t- TAnonymous\n\n\t\tIf `t` or `f` are null, the result is unspecified.",
      "iter": "Calls function `f` on each component of type `t`.\n\n\t\tIf `t` is not a compound type, this operation has no effect.\n\n\t\tThe following types are considered compound:\n\t\t\t- TInst, TEnum, TType and TAbstract with type parameters\n\t\t\t- TFun\n\t\t\t- TAnonymous\n\n\t\tIf `t` or `f` are null, the result is unspecified.",
      "toString": "Converts type `t` to a human-readable String representation.",
      "setVarName": "Changes the name of the variable in the typed expression.",
      "toModuleType": "Converts type `t` to `haxe.macro.Type.ModuleType`.",
      "fromModuleType": "Creates a type from the `haxe.macro.Type.ModuleType` argument.",
      "toBaseType": "Converts type `t` to `haxe.macro.Type.BaseType`.",
      "resolveTypeParameters": "Calls `f` for each missing `TypeParameter` within Type `type`.\n\t\tThe `Type` returned from `f` fills the vacant parameter in a\n\t\tcopy returned by the function.\n\n\t\tIf `type` does not use type parameters, or all of the type\n\t\tparameters are defined, `type` is returned unchanged.\n\n\t\tExcessive type parameters are truncated.\n\n\t\tIf `recursive` is true, all subtypes are resolved.\n\n\t\tThe parameters provided to `f` are:\n\t\t\t- The `TypeParameter` being resolved.\n\t\t\t- The `Type` missing a type parameter.\n\t\t\t- The `Int` index of type parameter being resolved.\n\n\t\tMissing type parameters may cause fatal compiler errors.\n\t\tTherefore, this function should be called on user generated\n\t\t`Type`s prior to passing to macro API functions such as\n\t\t`Context.follow` or `Context.unify`.",
      "findField": "Resolves the field named `name` on class `c`.\n\n\t\tIf `isStatic` is true, the classes' static fields are checked. Otherwise\n\t\tthe classes' member fields are checked.\n\n\t\tIf the field is found, it is returned. Otherwise if `c` has a super\n\t\tclass, `findField` recursively checks that super class. Otherwise null\n\t\tis returned.\n\n\t\tIf any argument is null, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntArithmetic": {
    "doc": "A collection of static helper functions for performing arithmetic\n\ton `BigInt_` objects.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntArithmetic.hx",
    "functions": {
      "compare": "Compare two big integers.\n\n\t\tReturns -1 if `a < b`; otherwise\n\t\treturns 1 if `a > b`; otherwise\n\t\treturns 0 (`a == b`).",
      "negate": "Perform the unary negation of big integer `operand` and put\n\t\tthe result into big integer `result`.\n\n\t\tOk for `result` and `operand` to be the same object.",
      "add": "Add big integer `operand2` to big integer `operand1` and put\n\t\tthe result into big integer `result`.\n\n\t\tOk for `result`, `operand1`, and `operand2` to be the same object.",
      "addInt": "Add integer `operand2` to big integer `operand1` and put the\n\t\tresult into big integer `result`.\n\n\t\tOk for `result` and `operand1` to be the same object.",
      "subtract": "Subtract big integer `operand2` from big integer `operand1`\n\t\tand put the result into big integer `result`.\n\n\t\tOk for `result`, `operand1`, and `operand2` to be the same object.",
      "subtractInt": "Subtract integer `operand2` from big integer `operand1` and\n\t\tput the result into big integer `result`.\n\n\t\tOk for `result` and `operand1` to be the same object.",
      "multiplyInt": "Multiply big integer `operand1` by integer `operand2` and put\n\t\tthe result into `result`.\n\n\t\t`result` may not refer the same object as either `operand1`\n\t\tor `operand2`; however, `operand1` and `operand2` may be the\n\t\tsame object.",
      "multiplyTraditional": "Multiply big integer `operand1` by big integer `operand2` and\n\t\tput the result into `result`.\n\n\t\t`result` may not refer the same object as either `operand1`\n\t\tor `operand2`; however, `operand1` and `operand2` may be the\n\t\tsame object.",
      "divideInt": "Divide the big integer `dividend` by the integer `divisor`.\n\t\tThe quotient of the division is put into `quotientOut`;\n\t\tthe remainder is the return value.\n\n\t\t`quotientOut` may refer to `dividend`.\n\n\t\t`work`, if supplied, must not refer to any of the inputs.",
      "divide": "Divide the big integer `dividend` by the big integer `divisor`.\n\t\tThe quotient of the division is put into `quotientOut`;\n\t\tthe remainder is put into `remainderOut`.\n\n\t\t`remainderOut` may be `null` if the remainder value is not\n\t\tneeded.\n\n\t\t`dividend` and `divisor` may refer to the same object.\n\n\t\t`quotientOut` and `remainderOut` must not refer to the same\n\t\tobject; but either may refer to the inputs.\n\n\t\t`work`, if supplied, must not refer to any of the inputs.",
      "arithmeticShiftLeft": "Shift big integer `operand1` to the left by `operand2` bits\n\t\tand put the result into big integer `result`.\n\n\t\tOk for `result` and `operand1` to be the same object.",
      "arithmeticShiftRight": "Shift big integer `operand1` to the right by `operand2` bits\n\t\tand put the result into big integer `result`.\n\n\t\tOk for `result` and `operand1` to be the same object.",
      "getBit": "Returns the value, 0 or 1, of the bit at 2^`index` place.",
      "bitwiseAndInt": "Returns the bitwise AND of `operand1` with `operand2`.",
      "bitwiseAnd": "Returns the bitwise AND of two big integers.\n\t\t@return A new `BigInt_` holding the result.",
      "bitwiseOr": "Returns the bitwise OR of `operand1` with `operand2`.",
      "bitwiseXor": "Returns the bitwise XOR of two big integers.\n\t\t@return A new `BigInt_` holding the result.",
      "bitwiseNot": "Returns the bitwise NOT (inversion) of a big integer.\n\t\t@return A new `BigInt_` holding the result.",
      "floorLog2": "Returns `floor(log2(input))`.\n\t\t@param input The `BigInt_` operand.\n\t\t@return The integer base-2 logarithm.",
      "square": "Squaring operation using power-of-two splitting.\n\t\t@param result The output BigInt for the square\n\t\t@param operand The operand to square"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntException": {
    "doc": "An exception thrown for errors during `BigInt` operations.\n\tIt wraps a `BigIntError` value to provide specific details.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.math.bigint.BigIntHelper": {
    "doc": "A collection of low-level, static Int manipulation helper functions.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntHelper.hx",
    "functions": {
      "bitLen": "Calculates the bit length of a signed 32-bit integer.\n\t\t@param x The integer value.\n\t\t@return The number of bits required to represent `x`.",
      "clp2": "\"Ceiling power of two\" -- round up to the least power of two\n\t\tgreater than or equal to input `x`, which is interpreted as\n\t\tunsigned.",
      "u32gtu32": "Unsigned greater than comparison.\n\n\t\tReturns `true` if `a > b` when both `a` and `b` are\n\t\tinterpreted as unsigned integers; `false` otherwise.",
      "u32divu16": "Integer division of unsigned 32-bit integer by unsigned 16-bit integer.\n\n\t\tResult is undefined when `divisor` <= 0 or `divisor` >= 2^16.",
      "u32geu32": "Unsigned greater than or equal comparison.\n\t\tReturns `true` if `a >= b` when both `a` and `b` are\n\t\tinterpreted as unsigned integers; `false` otherwise.",
      "ntz": "Number of trailing zeros - return the number of trailing\n\t\t0-value bits"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntTools": {
    "doc": "A collection of high-level static utility functions for `BigInt`.",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntTools.hx",
    "functions": {
      "isBigInt": "Checks if a dynamic value is a `BigInt`.\n\t\t@param value The value to check.\n\t\t@return `true` if the value is of type `BigInt`.",
      "castFrom": "Casts a dynamic value to a `BigInt`.\n\t\t@param value The value to cast.\n\t\t@return The value as a `BigInt`.",
      "parseValueUnsigned": "Parses a dynamic value into an unsigned `BigInt`.\n\t\tSupports `String`, `Int`, and other `BigInt` types.\n\t\t@param value The value to parse.\n\t\t@return A new `BigInt` instance.",
      "parseStringUnsigned": "Parses a string representing an unsigned integer into a `BigInt`.\n\t\tThis internal helper handles decimal strings, and hexadecimal strings\n\t\tthat are prefixed with \"0x\".\n\t\t@param value The string to be parsed.\n\t\t@return A new `BigInt` instance representing the unsigned value."
    },
    "fields": {}
  },
  "haxe.rtti.CType": {
    "doc": "The (dot-)path of the runtime type.\n*/\ntypedef Path = String;\n\n/**\n\tA list of strings representing the targets where the type is available.\n*/\ntypedef Platforms = Array<String>;\n\n/**\n\tThe function argument runtime type information.\n*/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\n\tThe runtime member types.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.Rights": {
    "doc": "The type parameters in the runtime type information.\n*/\ntypedef PathParams = {\n\t/**\n\t\tThe path of the type.\n*/\n\tvar path:Path;\n\n\t/**\n\t\tThe array of parameters types.\n*/\n\tvar params:Array<CType>;\n};\n\n/**\n\tAn array of strings representing the names of the type parameters the type\n\thas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\n\tRepresents the runtime rights of a type.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "params": "The array of parameters types.",
      "name": "An array of strings representing the names of the type parameters the type\n\thas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\n\tRepresents the runtime rights of a type.\n*/\nenum Rights {\n\tRNormal;\n\tRNo;\n\tRCall(m:String);\n\tRMethod;\n\tRDynamic;\n\tRInline;\n}\n\n/**\n\tThe list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\n\tThe runtime class field information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the field."
    }
  },
  "haxe.rtti.TypeTree": {
    "doc": "The list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\n\tThe runtime class field information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the field.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the field.\n*/\n\tvar type:CType;\n\n\t/**\n\t\tWhether or not the field is `public`.\n*/\n\tvar isPublic:Bool;\n\n\t/**\n\t\tWhether or not the field is `final`.\n*/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the field overrides another field.\n*/\n\tvar isOverride:Bool;\n\n\t/**\n\t\tThe documentation of the field. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\n\t\tif the field has no documentation, the value is `null`.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\t\tbehavior of the field.\n*/\n\tvar get:Rights;\n\n\t/**\n\t\tThe [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\t\tbehavior of the field.\n*/\n\tvar set:Rights;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters\n\t\tthe field has.\n*/\n\tvar params:TypeParams;\n\n\t/**\n\t\tA list of strings representing the targets where the field is available.\n*/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the field was annotated with.\n*/\n\tvar meta:MetaData;\n\n\t/**\n\t\tThe line number where the field is defined. This information is only\n\t\tavailable if the field has an expression.\n\t\tOtherwise the value is `null`.\n*/\n\tvar line:Null<Int>;\n\n\t/**\n\t\tThe list of available overloads for the fields or `null` if no overloads\n\t\texists.\n*/\n\tvar overloads:Null<Array<ClassField>>;\n\n\t/**\n\t\tThe actual expression of the field or `null` if there is no expression.\n*/\n\tvar expr:Null<String>;\n};\n\n/**\n\tThe general runtime type information.\n*/\ntypedef TypeInfos = {\n\t/**\n\t\tThe type path of the type.\n*/\n\tvar path:Path;\n\n\t/**\n\t\tThe type path of the module containing the type.\n*/\n\tvar module:Path;\n\n\t/**\n\t\tThe full slash path of the .hx file containing the type.\n\t\tThis might be `null` in case there is no such file, e.g. if the\n\t\ttype is defined through a macro.\n*/\n\tvar file:Null<String>;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters the\n\t\ttype has.\n*/\n\tvar params:TypeParams;\n\n\t/**\n\t\tThe documentation of the type. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n*/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tWhether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n*/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tA list of strings representing the targets where the type is available.\n*/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\n\t\tannotated with.\n*/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe runtime class definition information.\n*/\ntypedef Classdef = TypeInfos & {\n\t/**\n\t\tWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n*/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tWhether or not the class is `final`.\n*/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n*/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tThe class' parent class defined by its type path and list of type\n\t\tparameters.\n*/\n\tvar superClass:Null<PathParams>;\n\n\t/**\n\t\tThe list of interfaces defined by their type path and list of type\n\t\tparameters.\n*/\n\tvar interfaces:Array<PathParams>;\n\n\t/**\n\t\tThe list of member [class fields](https://haxe.org/manual/class-field.html).\n*/\n\tvar fields:Array<ClassField>;\n\n\t/**\n\t\tThe list of static class fields.\n*/\n\tvar statics:Array<ClassField>;\n\n\t/**\n\t\tThe type which is dynamically implemented by the class or `null` if no\n\t\tsuch type exists.\n*/\n\tvar tdynamic:Null<CType>;\n};\n\n/**\n\tThe runtime enum constructor information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the constructor.\n*/\n\tvar name:String;\n\n\t/**\n\t\tThe list of arguments the constructor has or `null` if no arguments are\n\t\tavailable.\n*/\n\tvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n\t/**\n\t\tThe documentation of the constructor. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n*/\n\tvar doc:String;\n\n\t/**\n\t\tA list of strings representing the targets where the constructor is\n\t\tavailable.\n*/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the constructor was annotated with.\n*/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe enum runtime type information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n\t/**\n\t\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n*/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe list of enum constructors.\n*/\n\tvar constructors:Array<EnumField>;\n};\n\n/**\n\tThe typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n\t/**\n\t\tThe type of the typedef.\n*/\n\tvar type:CType;\n\n\t/**\n\t\tThe types of the typedef, by platform.\n*/\n\tvar types:Map<String, CType>; // by platform\n\n};\n\n/**\n\tThe abstract type runtime information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n*/\ntypedef Abstractdef = TypeInfos & {\n\tvar to:Array<{t:CType, field:Null<String>}>;\n\tvar from:Array<{t:CType, field:Null<String>}>;\n\tvar impl:Classdef;\n\tvar athis:CType;\n};\n\n/**\n\tThe tree types of the runtime type.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "type": "The typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n\t/**\n\t\tThe type of the typedef.",
      "isPublic": "Whether or not the field is `public`.",
      "isFinal": "Whether or not the class is `final`.",
      "isOverride": "Whether or not the field overrides another field.",
      "doc": "The documentation of the constructor. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.",
      "get": "The [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\t\tbehavior of the field.",
      "set": "The [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\t\tbehavior of the field.",
      "params": "An array of strings representing the names of the type parameters the\n\t\ttype has.",
      "platforms": "A list of strings representing the targets where the constructor is\n\t\tavailable.",
      "meta": "The meta data the constructor was annotated with.",
      "line": "The line number where the field is defined. This information is only\n\t\tavailable if the field has an expression.\n\t\tOtherwise the value is `null`.",
      "overloads": "The list of available overloads for the fields or `null` if no overloads\n\t\texists.",
      "expr": "The actual expression of the field or `null` if there is no expression.",
      "path": "The general runtime type information.\n*/\ntypedef TypeInfos = {\n\t/**\n\t\tThe type path of the type.",
      "module": "The type path of the module containing the type.",
      "file": "The full slash path of the .hx file containing the type.\n\t\tThis might be `null` in case there is no such file, e.g. if the\n\t\ttype is defined through a macro.",
      "isPrivate": "Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).",
      "isExtern": "The enum runtime type information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n\t/**\n\t\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).",
      "isInterface": "Whether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).",
      "superClass": "The class' parent class defined by its type path and list of type\n\t\tparameters.",
      "interfaces": "The list of interfaces defined by their type path and list of type\n\t\tparameters.",
      "fields": "The list of member [class fields](https://haxe.org/manual/class-field.html).",
      "statics": "The list of static class fields.",
      "tdynamic": "The type which is dynamically implemented by the class or `null` if no\n\t\tsuch type exists.",
      "name": "The runtime enum constructor information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the constructor.",
      "args": "The list of arguments the constructor has or `null` if no arguments are\n\t\tavailable.",
      "constructors": "The list of enum constructors.",
      "types": "The types of the typedef, by platform."
    }
  },
  "haxe.rtti.TypeApi": {
    "doc": "Array of `TypeTree`.\n*/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\n\tContains type and equality checks functionalities for RTTI.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.CTypeTools": {
    "doc": "Returns `true` if the given `CType` is a variable or `false` if it is a\n\t\tfunction.\n*/\n\tpublic static function isVar(t:CType) {\n\t\treturn switch (t) {\n\t\t\tcase CFunction(_, _): false;\n\t\t\tdefault: true;\n\t\t}\n\t}\n\n\tstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\n\t\tvar it = l2.iterator();\n\t\tfor (e1 in l1) {\n\t\t\tif (!it.hasNext())\n\t\t\t\treturn false;\n\t\t\tvar e2 = it.next();\n\t\t\tif (!f(e1, e2))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (it.hasNext())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `r1 == r2`, this function performs a deep equality check on\n\t\tthe given `Rights` instances.\n\n\t\tIf `r1` or `r2` are `null`, the result is unspecified.\n*/\n\tpublic static function rightsEq(r1:Rights, r2:Rights) {\n\t\tif (r1 == r2)\n\t\t\treturn true;\n\t\tswitch (r1) {\n\t\t\tcase RCall(m1):\n\t\t\t\tswitch (r2) {\n\t\t\t\t\tcase RCall(m2):\n\t\t\t\t\t\treturn m1 == m2;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tdefault:\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `t1 == t2`, this function performs a deep equality check on\n\t\tthe given `CType` instances.\n\n\t\tIf `t1` or `t2` are `null`, the result is unspecified.\n*/\n\tpublic static function typeEq(t1:CType, t2:CType) {\n\t\tswitch (t1) {\n\t\t\tcase CUnknown:\n\t\t\t\treturn t2 == CUnknown;\n\t\t\tcase CEnum(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CEnum(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CClass(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CClass(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAbstract(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAbstract(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CTypedef(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CTypedef(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CFunction(args2, ret2):\n\t\t\t\t\t\treturn leq(function(a:FunctionArgument, b:FunctionArgument) {\n\t\t\t\t\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t\t\t\t\t}, args, args2) && typeEq(ret, ret2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAnonymous(fields2):\n\t\t\t\t\t\treturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CDynamic(t):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CDynamic(t2):\n\t\t\t\t\t\tif ((t == null) != (t2 == null))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\treturn t == null || typeEq(t, t2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `f1 == f2`, this function performs a deep equality check on\n\t\tthe given `ClassField` instances.\n\n\t\tIf `f1` or `f2` are `null`, the result is unspecified.\n*/\n\tpublic static function fieldEq(f1:ClassField, f2:ClassField) {\n\t\tif (f1.name != f2.name)\n\t\t\treturn false;\n\t\tif (!typeEq(f1.type, f2.type))\n\t\t\treturn false;\n\t\tif (f1.isPublic != f2.isPublic)\n\t\t\treturn false;\n\t\tif (f1.doc != f2.doc)\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.get, f2.get))\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.set, f2.set))\n\t\t\treturn false;\n\t\tif ((f1.params == null) != (f2.params == null))\n\t\t\treturn false;\n\t\tif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `c1 == c2`, this function performs a deep equality check on\n\t\tthe arguments of the enum constructors, if exists.\n\n\t\tIf `c1` or `c2` are `null`, the result is unspecified.\n*/\n\tpublic static function constructorEq(c1:EnumField, c2:EnumField) {\n\t\tif (c1.name != c2.name)\n\t\t\treturn false;\n\t\tif (c1.doc != c2.doc)\n\t\t\treturn false;\n\t\tif ((c1.args == null) != (c2.args == null))\n\t\t\treturn false;\n\t\tif (c1.args != null && !leq(function(a, b) {\n\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t}, c1.args, c2.args))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n\n/**\n\tThe `CTypeTools` class contains some extra functionalities for handling\n\t`CType` instances.",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {
      "rightsEq": "Unlike `r1 == r2`, this function performs a deep equality check on\n\t\tthe given `Rights` instances.\n\n\t\tIf `r1` or `r2` are `null`, the result is unspecified.",
      "typeEq": "Unlike `t1 == t2`, this function performs a deep equality check on\n\t\tthe given `CType` instances.\n\n\t\tIf `t1` or `t2` are `null`, the result is unspecified.",
      "fieldEq": "Unlike `f1 == f2`, this function performs a deep equality check on\n\t\tthe given `ClassField` instances.\n\n\t\tIf `f1` or `f2` are `null`, the result is unspecified.",
      "constructorEq": "Unlike `c1 == c2`, this function performs a deep equality check on\n\t\tthe arguments of the enum constructors, if exists.\n\n\t\tIf `c1` or `c2` are `null`, the result is unspecified.",
      "toString": "The `CTypeTools` class contains some extra functionalities for handling\n\t`CType` instances.\n*/\nclass CTypeTools {\n\t/**\n\t\tGet the string representation of `CType`."
    },
    "fields": {}
  },
  "haxe.rtti.Meta": {
    "doc": "An API to access classes and enums metadata at runtime.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\Meta.hx",
    "functions": {
      "getStatics": "Returns the metadata that were declared for the given class static fields",
      "getFields": "Returns the metadata that were declared for the given class fields or enum constructors"
    },
    "fields": {}
  },
  "haxe.rtti.Rtti": {
    "doc": "Rtti is a helper class which supplements the `@:rtti` metadata.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\Rtti.hx",
    "functions": {
      "hasRtti": "Tells if `c` has runtime type information.\n\n\t\tIf `c` is `null`, the result is unspecified."
    },
    "fields": {}
  },
  "haxe.rtti.XmlParser": {
    "doc": "XmlParser processes the runtime type information (RTTI) which\n\tis stored as a XML string in a static field `__rtti`.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>",
    "path": "haxe\\std\\haxe\\rtti\\XmlParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.xml.Access": {
    "doc": "The `haxe.xml.Access` API helps providing a fast dot-syntax access to the\n\tmost common `Xml` methods.",
    "path": "haxe\\std\\haxe\\xml\\Access.hx",
    "functions": {},
    "fields": {
      "innerData": "The inner PCDATA or CDATA of the node.\n\n\t\tAn exception is thrown if there is no data or if there not only data\n\t\tbut also other nodes.",
      "innerHTML": "The XML string built with all the sub nodes, excluding the current one.",
      "node": "Access to the first sub element with the given name.\n\n\t\tAn exception is thrown if the element doesn't exists.\n\t\tUse `hasNode` to check the existence of a node.\n\n\t\t```haxe\n\t\tvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\n\t\tvar user = access.node.user;\n\t\tvar name = user.node.name;\n\t\ttrace(name.innerData); // John\n\n\t\t// Uncaught Error: Document is missing element password\n\t\tvar password = user.node.password;\n\t\t```",
      "nodes": "Access to the List of elements with the given name.\n\t\t```haxe\n\t\tvar fast = new haxe.xml.Access(Xml.parse(\"\n\t\t\t<users>\n\t\t\t\t<user name='John'/>\n\t\t\t\t<user name='Andy'/>\n\t\t\t\t<user name='Dan'/>\n\t\t\t</users>\"\n\t\t));\n\n\t\tvar users = fast.node.users;\n\t\tfor (user in users.nodes.user) {\n\t\t\ttrace(user.att.name);\n\t\t}\n\t\t```",
      "att": "Access to a given attribute.\n\n\t\tAn exception is thrown if the attribute doesn't exists.\n\t\tUse `has` to check the existence of an attribute.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.has.name) {\n\t\t\ttrace(user.att.name); // Mark\n\t\t}\n\t\t```",
      "has": "Check the existence of an attribute with the given name.",
      "hasNode": "Check the existence of a sub node with the given name.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.hasNode.age) {\n\t\t\ttrace(user.node.age.innerData); // 31\n\t\t}\n\t\t```",
      "elements": "The list of all sub-elements which are the nodes with type `Xml.Element`."
    }
  },
  "haxe.xml.Printer": {
    "doc": "This class provides utility methods to convert Xml instances to\n\tString representation.",
    "path": "haxe\\std\\haxe\\xml\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.zip.InflateImpl": {
    "doc": "A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.",
    "path": "haxe\\std\\haxe\\zip\\InflateImpl.hx",
    "functions": {},
    "fields": {}
  },
  "hl.CArray": {
    "doc": "CArray is a compact array where all objects are memory aligned and stored as a single GC block.\n\tYou must hold a reference to the CArray while any of the objects it contains is still referenced somewhere.",
    "path": "haxe\\std\\hl\\CArray.hx",
    "functions": {},
    "fields": {}
  },
  "hl.Format": {
    "doc": "These are some bindings for the HL `fmt.hdll` library, which contains various low level formats handling.",
    "path": "haxe\\std\\hl\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "hl.UI": {
    "doc": "These are the bindings for the HL `ui.hdll` library, which contains some low level system access.",
    "path": "haxe\\std\\hl\\UI.hx",
    "functions": {},
    "fields": {}
  },
  "js.Lib": {
    "doc": "Platform-specific JavaScript Library. Provides some platform-specific functions\n\tfor the JavaScript target.",
    "path": "haxe\\std\\js\\Lib.hx",
    "functions": {
      "dynamicImport": "Inserts an `import` expression that loads JavaScript object from\n\t\ta module or file specified in the `module` argument.",
      "alert": "Display an alert message box containing the given message.\n\t\t@deprecated Use Browser.alert() instead.",
      "getOriginalException": "Inserts a `require` expression that loads JavaScript object from\n\t\ta module or file specified in the `module` argument.\n\n\t\tThis is only supported in environments where `require` function\n\t\tis available, such as Node.js or RequireJS.\n*/\n\textern public static inline function require(module:String):Dynamic {\n\t\treturn js.Syntax.code(\"require\")(module);\n\t}\n\n\t/**\n\t\tNative JavaScript `parseInt` function.\n\n\t\tIts specification is different from `Std.parseInt`, so one\n\t\tmight want to access the native one.\n*/\n\tpublic static var parseInt(get, never):(string:String, ?radix:Int) -> Float;\n\n\textern static inline function get_parseInt():(string:String, ?radix:Int) -> Float {\n\t\treturn js.Syntax.code(\"parseInt\");\n\t}\n\n\t/**\n\t\tReturns JavaScript `undefined` value.\n\n\t\tNote that this is only needed in very rare cases when working with external JavaScript code.\n\n\t\tIn Haxe, `null` is used to represent the absence of a value.\n*/\n\tpublic static var undefined(get, never):Dynamic;\n\n\tstatic inline function get_undefined():Dynamic {\n\t\treturn js.Syntax.code(\"undefined\");\n\t}\n\n\t/**\n\t\t`nativeThis` is the JavaScript `this`, which is semantically different\n\t\tfrom the Haxe `this`. Use `nativeThis` only when working with external\n\t\tJavaScript code.\n\n\t\tIn Haxe, `this` is always bound to a class instance.\n\t\tIn JavaScript, `this` in a function can be bound to an arbitrary\n\t\tvariable when the function is called using `func.call(thisObj, ...)` or\n\t\t`func.apply(thisObj, [...])`.\n\n\t\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n*/\n\tpublic static var nativeThis(get, never):Dynamic;\n\n\textern static inline function get_nativeThis():Dynamic {\n\t\treturn js.Syntax.code(\"this\");\n\t}\n\n\t/**\n\t\tCall JavaScript `typeof` operator on the `o` value\n\t\tand return a string representing the JavaScript type of a value.\n\n\t\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\n\textern public static inline function typeof(o:Dynamic):String {\n\t\treturn js.Syntax.typeof(o);\n\t}\n\n\t/**\n\t\tAn alias of the JS \"global\" object.\n\n\t\tConcretely, it is set as the first defined value in the list of\n\t\t`window`, `global`, `self`, and `this` in the top-level of the compiled output.\n*/\n\tpublic static var global(get, never):Dynamic;\n\n\textern static inline function get_global():Dynamic {\n\t\treturn untyped __define_feature__(\"js.Lib.global\", js.Syntax.code(\"$global\")); // $global is generated by the compiler\n\t}\n\n\t/**\n\t\tRe-throw last caught exception, preserving original stack information.\n\n\t\tCalling this is only possible inside a catch statement.\n*/\n\t@:pure(false) public static function rethrow() {\n\t\t// function is implemented in the compiler\n\t}\n\n\t/**\n\t\tGet original caught exception object, before unwrapping the `js.Boot.HaxeError`.\n\n\t\tCan be useful if we want to redirect the original error into some external API (e.g. Promise or node.js callbacks).\n\n\t\tCalling this is only possible inside a catch statement.",
      "getNextHaxeUID": "Generate next unique id"
    },
    "fields": {
      "undefined": "Returns JavaScript `undefined` value.\n\n\t\tNote that this is only needed in very rare cases when working with external JavaScript code.\n\n\t\tIn Haxe, `null` is used to represent the absence of a value.",
      "nativeThis": "`nativeThis` is the JavaScript `this`, which is semantically different\n\t\tfrom the Haxe `this`. Use `nativeThis` only when working with external\n\t\tJavaScript code.\n\n\t\tIn Haxe, `this` is always bound to a class instance.\n\t\tIn JavaScript, `this` in a function can be bound to an arbitrary\n\t\tvariable when the function is called using `func.call(thisObj, ...)` or\n\t\t`func.apply(thisObj, [...])`.\n\n\t\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this",
      "global": "Call JavaScript `typeof` operator on the `o` value\n\t\tand return a string representing the JavaScript type of a value.\n\n\t\tRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\n\textern public static inline function typeof(o:Dynamic):String {\n\t\treturn js.Syntax.typeof(o);\n\t}\n\n\t/**\n\t\tAn alias of the JS \"global\" object.\n\n\t\tConcretely, it is set as the first defined value in the list of\n\t\t`window`, `global`, `self`, and `this` in the top-level of the compiled output."
    }
  },
  "js.html.ConsoleInstance": {
    "doc": "The `Console` object provides access to the browser's debugging console (e.g.the Web Console in Firefox). The specifics of how it works variesfrom browser to browser, but there is a de facto set of features that are typically provided.\n\n\tDocumentation [Console](https://developer.mozilla.org/en-US/docs/Web/API/Console) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/Console$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/API/Console>",
    "path": "haxe\\std\\js\\html\\ConsoleInstance.hx",
    "functions": {
      "clear": "Clear the console.",
      "count": "Log the number of times this line has been called with the given label.",
      "countReset": "Resets the value of the counter with the given label.",
      "debug": "Outputs a message to the console with the log level `\"debug\"`.\n\t\t Note: Starting with Chromium 58 this method only appears in Chromium browser consoles when level \"Verbose\" is selected.",
      "error": "Outputs an error message. You may use string substitution and additional arguments with this method.",
      "info": "Informative logging of information. You may use string substitution and additional arguments with this method.",
      "log": "For general output of logging information. You may use string substitution and additional arguments with this method.",
      "table": "Displays tabular data as a table.",
      "trace": "Outputs a stack trace.",
      "warn": "Outputs a warning message. You may use string substitution and additional arguments with this method.",
      "dir": "Displays an interactive listing of the properties of a specified JavaScript object. This listing lets you use disclosure triangles to examine the contents of child objects.",
      "dirxml": "Displays an XML/HTML Element representation of the specified objectif possibleor the JavaScript Object view if it is not possible.",
      "group": "Creates a new inline group, indenting all following output by another level. To move back out a level, call `groupEnd()`.",
      "groupCollapsed": "Creates a new inline group, indenting all following output by another level. However,unlike `group()`this starts with the inline group collapsedrequiring the use of a disclosure button to expand it. To move back out a level, call `groupEnd()`.",
      "groupEnd": "Exits the current inline group.",
      "time": "Starts a timer with a name specified as an input parameter. Up to 10,000 simultaneous timers can run on a given page.",
      "timeLog": "Logs the value of the specified timer to the console.",
      "timeEnd": "Stops the specified timer and logs the elapsed time in seconds since itstarted.",
      "exception": "An alias for `error()`.",
      "timeStamp": "Adds a marker to the browser's Timeline or Waterfall tool.",
      "profile": "Starts the browser's built-in profiler (for example, the Firefox performance tool). You can specify an optional name for the profile.",
      "profileEnd": "Stops the profiler. You can see the resulting profile in the browser's performance tool (for example, the Firefox performance tool)."
    },
    "fields": {}
  },
  "js.html.abstract": {
    "doc": "The `XMLHttpRequestResponseType` type is an enumerated set of strings which are used to specify the type of data contained in the `response` of an `XMLHttpRequest`.\n\n\tDocumentation [XMLHttpRequestResponseType](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType>",
    "path": "haxe\\std\\js\\html\\XMLHttpRequestResponseType.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.ArrayBufferView": {
    "doc": "`ArrayBufferView` is a helper type representing any of the following JavaScript `TypedArray` types:\n\n\tDocumentation [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>",
    "path": "haxe\\std\\js\\lib\\ArrayBufferView.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.BufferSource": {
    "doc": "`BufferSource` is a typedef used to represent objects that are either themselves an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer),\n\tor which are a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) providing an [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView).\n\n\tThis is a helper type to simplify the specification. It isn't an interface and there are no objects implementing it.\n\n\tDocumentation [BufferSource](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/API/BufferSource>",
    "path": "haxe\\std\\js\\lib\\BufferSource.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.HaxeIterator": {
    "doc": "`HaxeIterator` wraps a JavaScript native iterator object to enable for-in iteration in haxe.\n\tIt can be used directly: `new HaxeIterator(jsIterator)` or via using: `using HaxeIterator`.",
    "path": "haxe\\std\\js\\lib\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.KeyValue": {
    "doc": "Key/value access helper.",
    "path": "haxe\\std\\js\\lib\\KeyValue.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.NativeStringTools": {
    "doc": "Documentation [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).",
    "path": "haxe\\std\\js\\lib\\NativeStringTools.hx",
    "functions": {
      "localeCompare": "Returns a number indicating whether a reference string comes before or after or is\n\t\tthe same as the given string in sort order.",
      "toLocaleLowerCase": "The characters within a string are converted to lower case while respecting the current locale.\n\t\tFor most languages, this will return the same as toLowerCase().",
      "toLocaleUpperCase": "The characters within a string are converted to upper case while respecting the current locale.\n\t\tFor most languages, this will return the same as toUpperCase().",
      "charCodeAt": "The `charCodeAt()` method of String values returns an integer between 0\n\t\tand 65535 representing the UTF-16 code unit at the given index.\n\n\t\tIf `index` is out of range of `0`  `str.length - 1`, returns `NaN`.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt",
      "replace": "The `replace()` method of String values returns a new string with one,\n\t\tsome, or all matches of a pattern replaced by a replacement.\n\n\t\tThe pattern can be a `String` or a `js.lib.RegExp`, and the replacement\n\t\tcan be a string or a function called for each match.\n\n\t\tIf pattern is a string, only the first occurrence will be replaced. The\n\t\toriginal string is left unchanged.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
    },
    "fields": {
      "NFD": "Normalization Form Canonical Decomposition.",
      "NFKC": "Normalization Form Compatibility Composition.",
      "NFKD": "Normalization Form Compatibility Decomposition."
    }
  },
  "js.lib.ObjectEntry": {
    "doc": "The `js.lib.Object` constructor creates an object wrapper.\n\n\tDocumentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Object\")\nextern class Object {\n\t/**\n\t\tThe Object.assign() method is used to copy the values of all enumerable\n\t\town properties from one or more source objects to a target object. It\n\t\twill return the target object.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n*/\n\tstatic function assign<TSource:{}, TDest:{}>(target:TSource, sources:Rest<{}>):TDest;\n\n\t/**\n\t\tThe Object.create() method create a new object, using an existing object\n\t\tto provide the newly created object's __proto__ . (see browser console\n\t\tfor visual evidence.)\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n\t@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n\t/**\n\t\tThe Object.defineProperties() method defines new or modifies existing\n\t\tproperties directly on an object, returning the object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\n*/\n\tstatic function defineProperties<T:{}>(obj:T, props:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n\t/**\n\t\tThe static method Object.defineProperty() defines a new property directly\n\t\ton an object, or modifies an existing property on an object, and returns\n\t\tthe object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n*/\n\t@:overload(function<T:{}, TProp>(obj:T, prop:Symbol, descriptor:ObjectPropertyDescriptor<TProp>):T {})\n\tstatic function defineProperty<T:{}, TProp>(obj:T, prop:String, descriptor:ObjectPropertyDescriptor<TProp>):T;\n\n\t/**\n\t\tThe Object.entries() method returns an array of a given object's own\n\t\tenumerable property [key, value] pairs, in the same order as that\n\t\tprovided by a for...in loop (the difference being that a for-in loop\n\t\tenumerates properties in the prototype chain as well).\n\n\t\tNote: this is an ES2017 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n\t@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n\t/**\n\t\tThe Object.freeze() method freezes an object: that is, prevents new\n\t\tproperties from being added to it; prevents existing properties from\n\t\tbeing removed; and prevents existing properties, or their enumerability,\n\t\tconfigurability, or writability, from being changed, it also prevents the\n\t\tprototype from being changed.\n\t\tThe method returns the passed object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n*/\n\tstatic function freeze<T:{}>(obj:T):T;\n\n\t/**\n\t\tReturns a new object from an iterable of key-value pairs\n\t\t(reverses Object.entries).\n*/\n\t@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n\t/**\n\t\tThe Object.getOwnPropertyDescriptor() method returns a property\n\t\tdescriptor for an own property (that is, one directly present on an\n\t\tobject and not in the object's prototype chain) of a given object.\n\n\t\tIn ES5, if the first argument to this method is not an object (a\n\t\tprimitive), then it will cause a TypeError. In ES2015, a non-object\n\t\tfirst argument will be coerced to an object at first.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n\t@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n\t@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n\t@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n\t/**\n\t\tThe Object.getOwnPropertyDescriptors() method returns all own property\n\t\tdescriptors of a given object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n\t@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n\t@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n\t/**\n\t\tThe Object.getOwnPropertyNames() method returns an array of all\n\t\tproperties (including non-enumerable properties except for those which\n\t\tuse Symbol) found directly upon a given object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n\t@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n\t/**\n\t\tThe Object.getOwnPropertySymbols() method returns an array of all symbol\n\t\tproperties found directly upon a given object.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n\t@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n\t/**\n\t\tThe Object.getPrototypeOf() method returns the prototype (i.e. the value\n\t\tof the internal [[Prototype]] property) of the specified object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n\t@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n\t/**\n\t\tThe Object.is() method determines whether two values are the same value.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n\t@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n\t/**\n\t\tThe Object.is() method determines whether two values are the same value.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n\t@:deprecated(\"Use Object.isSame()\")\n\t@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n\t/**\n\t\tThe Object.isExtensible() method determines if an object is extensible\n\t\t(whether it can have new properties added to it).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n\t@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.isFrozen() determines if an object is frozen.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n\t@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.isSealed() method determines if an object is sealed.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n\t@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.keys() method returns an array of a given object's own\n\t\tenumerable properties, in the same order as that provided by a for...in\n\t\tloop (the difference being that a for-in loop enumerates properties in\n\t\tthe prototype chain as well).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n\t@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n\t/**\n\t\tThe Object.preventExtensions() method prevents new properties from ever\n\t\tbeing added to an object (i.e. prevents future extensions to the object).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\n*/\n\tstatic function preventExtensions<T:{}>(obj:T):T;\n\n\t/**\n\t\tThe Object.seal() method seals an object, preventing new properties from\n\t\tbeing added to it and marking all existing properties as\n\t\tnon-configurable. Values of present properties can still be changed as\n\t\tlong as they are writable.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\n*/\n\tstatic function seal<T:{}>(obj:T):T;\n\n\t/**\n\t\tThe Object.setPrototypeOf() method sets the prototype (i.e., the internal\n\t\t[[Prototype]] property) of a specified object to another object or null.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\n*/\n\tstatic function setPrototypeOf<T:{}, TProto:{}>(obj:T, proto:Null<TProto>):T;\n\n\t/**\n\t\tThe Object.values() method returns an array of a given object's own\n\t\tenumerable property values, in the same order as that provided by a\n\t\tfor...in loop (the difference being that a for-in loop enumerates\n\t\tproperties in the prototype chain as well).\n\n\t\tNote: this is an ES2017 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n*/\n\t@:pure static function values<T:{}>(obj:T):Array<Any>;\n\n\t/**\n\t\tAllows the addition of properties to all objects of type Object.\n*/\n\tstatic var prototype(default, never):ObjectPrototype;\n\n\t/**\n\t\tThe Object constructor creates an object wrapper.\n*/\n\t@:pure function new(?value:Any);\n}\n\n/**\n\tType for\n\t@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n\t/**\n\t\tReturns a boolean indicating whether an object contains the specified\n\t\tproperty as a direct property of that object and not inherited through\n\t\tthe prototype chain.\n*/\n\tvar hasOwnProperty(default, never):Function;\n\n\t/**\n\t\tReturns a boolean indicating whether the object this method is called\n\t\tupon is in the prototype chain of the specified object.\n*/\n\tvar isPrototypeOf(default, never):Function;\n\n\t/**\n\t\tReturns a boolean indicating if the internal enumerable attribute is set.\n*/\n\tvar propertyIsEnumerable(default, never):Function;\n\n\t/**\n\t\tCalls `toString()`.\n*/\n\tvar toLocaleString(default, never):Function;\n\n\t/**\n\t\tReturns a string representation of the object.\n*/\n\tvar toString(default, never):Function;\n\n\t/**\n\t\tReturns the primitive value of the specified object.\n*/\n\tvar valueOf(default, never):Function;\n}\n\n/**\n\t@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>\n*/\ntypedef ObjectPropertyDescriptor<TProp> = {\n\t/**\n\t\t`true` if and only if the type of this property descriptor may be\n\t\tchanged and if the property may be deleted from the corresponding object.\n\t\tDefaults to `false`.\n*/\n\tvar ?configurable:Bool;\n\n\t/**\n\t\t`true` if and only if this property shows up during enumeration of the\n\t\tproperties on the corresponding object.\n\t\tDefaults to `false`.\n*/\n\tvar ?enumerable:Bool;\n\n\t/**\n\t\tThe value associated with the property.\n\t\tCan be any valid JavaScript value (number, object, function, etc).\n*/\n\tvar ?value:TProp;\n\n\t/**\n\t\t`true` if and only if the value associated with the property may be\n\t\tchanged with an assignment operator.\n\t\tDefaults to `false`.\n*/\n\tvar ?writable:Bool;\n\n\t/**\n\t\tA function which serves as a getter for the property, or `undefined` if\n\t\tthere is no getter. When the property is accessed, this function is\n\t\tcalled without arguments and with `this` set to the object through which\n\t\tthe property is accessed (this may not be the object on which the\n\t\tproperty is defined due to inheritance).\n\t\tThe return value will be used as the value of the property.\n*/\n\tvar ?get:Void->TProp;\n\n\t/**\n\t\tA function which serves as a setter for the property, or undefined if\n\t\tthere is no setter. When the property is assigned to, this function\n\t\tis called with one argument (the value being assigned to the property)\n\t\tand with `this` set to the object through which the property is assigned.\n*/\n\tvar ?set:TProp->Void;\n}\n\n/**\n\tKey/value access helper for `js.lib.Object.entries()`.",
    "path": "haxe\\std\\js\\lib\\Object.hx",
    "functions": {
      "defineProperties": "The Object.create() method create a new object, using an existing object\n\t\tto provide the newly created object's __proto__ . (see browser console\n\t\tfor visual evidence.)\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n\t@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n\t/**\n\t\tThe Object.defineProperties() method defines new or modifies existing\n\t\tproperties directly on an object, returning the object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties",
      "defineProperty": "The static method Object.defineProperty() defines a new property directly\n\t\ton an object, or modifies an existing property on an object, and returns\n\t\tthe object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "freeze": "The Object.entries() method returns an array of a given object's own\n\t\tenumerable property [key, value] pairs, in the same order as that\n\t\tprovided by a for...in loop (the difference being that a for-in loop\n\t\tenumerates properties in the prototype chain as well).\n\n\t\tNote: this is an ES2017 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n\t@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n\t/**\n\t\tThe Object.freeze() method freezes an object: that is, prevents new\n\t\tproperties from being added to it; prevents existing properties from\n\t\tbeing removed; and prevents existing properties, or their enumerability,\n\t\tconfigurability, or writability, from being changed, it also prevents the\n\t\tprototype from being changed.\n\t\tThe method returns the passed object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze",
      "preventExtensions": "Returns a new object from an iterable of key-value pairs\n\t\t(reverses Object.entries).\n*/\n\t@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n\t/**\n\t\tThe Object.getOwnPropertyDescriptor() method returns a property\n\t\tdescriptor for an own property (that is, one directly present on an\n\t\tobject and not in the object's prototype chain) of a given object.\n\n\t\tIn ES5, if the first argument to this method is not an object (a\n\t\tprimitive), then it will cause a TypeError. In ES2015, a non-object\n\t\tfirst argument will be coerced to an object at first.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n\t@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n\t@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n\t@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n\t/**\n\t\tThe Object.getOwnPropertyDescriptors() method returns all own property\n\t\tdescriptors of a given object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n\t@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n\t@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n\t@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n\t/**\n\t\tThe Object.getOwnPropertyNames() method returns an array of all\n\t\tproperties (including non-enumerable properties except for those which\n\t\tuse Symbol) found directly upon a given object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n\t@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n\t/**\n\t\tThe Object.getOwnPropertySymbols() method returns an array of all symbol\n\t\tproperties found directly upon a given object.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n\t@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n\t/**\n\t\tThe Object.getPrototypeOf() method returns the prototype (i.e. the value\n\t\tof the internal [[Prototype]] property) of the specified object.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n\t@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n\t/**\n\t\tThe Object.is() method determines whether two values are the same value.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n\t@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n\t/**\n\t\tThe Object.is() method determines whether two values are the same value.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n\t@:deprecated(\"Use Object.isSame()\")\n\t@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n\t/**\n\t\tThe Object.isExtensible() method determines if an object is extensible\n\t\t(whether it can have new properties added to it).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n\t@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.isFrozen() determines if an object is frozen.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n\t@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.isSealed() method determines if an object is sealed.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n\t@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n\t/**\n\t\tThe Object.keys() method returns an array of a given object's own\n\t\tenumerable properties, in the same order as that provided by a for...in\n\t\tloop (the difference being that a for-in loop enumerates properties in\n\t\tthe prototype chain as well).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n\t@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n\t/**\n\t\tThe Object.preventExtensions() method prevents new properties from ever\n\t\tbeing added to an object (i.e. prevents future extensions to the object).\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions",
      "seal": "The Object.seal() method seals an object, preventing new properties from\n\t\tbeing added to it and marking all existing properties as\n\t\tnon-configurable. Values of present properties can still be changed as\n\t\tlong as they are writable.\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal",
      "setPrototypeOf": "The Object.setPrototypeOf() method sets the prototype (i.e., the internal\n\t\t[[Prototype]] property) of a specified object to another object or null.\n\n\t\tNote: this is an ES2015 feature\n\n\t\tSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
    },
    "fields": {
      "hasOwnProperty": "The Object constructor creates an object wrapper.\n*/\n\t@:pure function new(?value:Any);\n}\n\n/**\n\tType for\n\t@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n\t/**\n\t\tReturns a boolean indicating whether an object contains the specified\n\t\tproperty as a direct property of that object and not inherited through\n\t\tthe prototype chain.",
      "isPrototypeOf": "Returns a boolean indicating whether the object this method is called\n\t\tupon is in the prototype chain of the specified object.",
      "propertyIsEnumerable": "Returns a boolean indicating if the internal enumerable attribute is set.",
      "toLocaleString": "Calls `toString()`.",
      "toString": "Returns a string representation of the object.",
      "valueOf": "Returns the primitive value of the specified object."
    }
  },
  "js.lib.PromiseHandler": {
    "doc": "The Promise object represents the eventual completion (or failure) of an\n\tasynchronous operation and its resulting value.\n\n\tDocumentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Promise\")\nextern class Promise<T> {\n\t/**\n\t\tReturns a Promise object that is resolved with the given value. If the\n\t\tvalue is Thenable, the returned promise will \"follow\" that\n\t\tthenable, adopting its eventual state;\n\t\totherwise the returned promise will be fulfilled with the value.\n\t\tGenerally, when it's unknown when value is a promise or not,\n\t\tuse `Promise.resolve(value)` instead and work with the return value as\n\t\ta promise.\n*/\n\t@:overload(function<T>(?value:T):Promise<T> {})\n\tstatic function resolve<T>(thenable:Thenable<T>):Promise<T>;\n\n\t/**\n\t\tReturns a Promise object that is rejected with the given reason.\n*/\n\tstatic function reject<T>(?reason:Dynamic):Promise<T>;\n\n\t/**\n\t\tReturns a promise that either fulfills when all of the promises in the\n\t\titerable argument have fulfilled or rejects as soon as one of the\n\t\tpromises in the iterable argument rejects. If the returned promise\n\t\tfulfills, it is fulfilled with an array of the values from the\n\t\tfulfilled promises in the same order as defined in the iterable.\n\t\tIf the returned promise rejects, it is rejected with the reason from\n\t\tthe first promise in the iterable that rejected. This method can be\n\t\tuseful for aggregating results of multiple promises.\n*/\n\t@:overload(function(iterable:Array<Dynamic>):Promise<Array<Dynamic>> {})\n\tstatic function all<T>(iterable:Array<Promise<T>>):Promise<Array<T>>;\n\n\t/**\n\t\tReturns a promise that resolves after all of the given promises have either fulfilled or rejected,\n\t\twith an array of objects that each describes the outcome of each promise.\n\n\t\tIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\n\t\tto complete successfully, or you'd always like to know the result of each promise.\n\n\t\tIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\n\t\ton each other / if you'd like to immediately reject upon any of them rejecting.\n*/\n\t@:overload(function(iterable:Array<Dynamic>):Promise<Array<PromiseSettleOutcome<Dynamic>>> {})\n\tstatic function allSettled<T>(iterable:Array<Promise<T>>):Promise<Array<PromiseSettleOutcome<T>>>;\n\n\t/**\n\t\tReturns a promise that fulfills or rejects as soon as one of the\n\t\tpromises in the iterable fulfills or rejects, with the value or reason\n\t\tfrom that promise.\n*/\n\t@:overload(function(iterable:Array<Dynamic>):Promise<Dynamic> {})\n\tstatic function race<T>(iterable:Array<Promise<T>>):Promise<T>;\n\n\t/** @throws DOMError */\n\tfunction new(init:(resolve:(value:T) -> Void, reject:(reason:Dynamic) -> Void) -> Void):Void;\n\n\t/**\n\t\tAppends fulfillment and rejection handlers to the promise and returns a\n\t\tnew promise resolving to the return value of the called handler, or to\n\t\tits original settled value if the promise was not handled\n\t\t(i.e. if the relevant handler onFulfilled or onRejected is not a function).\n*/\n\tfunction then<TOut>(onFulfilled:Null<PromiseHandler<T, TOut>>, ?onRejected:PromiseHandler<Dynamic, TOut>):Promise<TOut>;\n\n\t/**\n\t\tAppends a rejection handler callback to the promise, and returns a new\n\t\tpromise resolving to the return value of the callback if it is called,\n\t\tor to its original fulfillment value if the promise is instead fulfilled.\n*/\n\t@:native(\"catch\")\n\t@:overload(function<TOut>(onRejected:PromiseHandler<Dynamic, TOut>):Promise<EitherType<T, TOut>> {})\n\tfunction catchError(onRejected:PromiseHandler<Dynamic, T>):Promise<T>;\n\n\t/**\n\t\tReturns a Promise. When the promise is settled, i.e either fulfilled or rejected,\n\t\tthe specified callback function is executed. This provides a way for code to be run\n\t\twhether the promise was fulfilled successfully or rejected once the Promise has been dealt with.\n*/\n\tfunction finally(onFinally:() -> Void):Promise<T>;\n}\n\n/**\n\tHandler type for the Promise object.",
    "path": "haxe\\std\\js\\lib\\Promise.hx",
    "functions": {
      "reject": "Returns a Promise object that is rejected with the given reason.",
      "all": "Returns a promise that either fulfills when all of the promises in the\n\t\titerable argument have fulfilled or rejects as soon as one of the\n\t\tpromises in the iterable argument rejects. If the returned promise\n\t\tfulfills, it is fulfilled with an array of the values from the\n\t\tfulfilled promises in the same order as defined in the iterable.\n\t\tIf the returned promise rejects, it is rejected with the reason from\n\t\tthe first promise in the iterable that rejected. This method can be\n\t\tuseful for aggregating results of multiple promises.",
      "allSettled": "Returns a promise that resolves after all of the given promises have either fulfilled or rejected,\n\t\twith an array of objects that each describes the outcome of each promise.\n\n\t\tIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\n\t\tto complete successfully, or you'd always like to know the result of each promise.\n\n\t\tIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\n\t\ton each other / if you'd like to immediately reject upon any of them rejecting.",
      "race": "Returns a promise that fulfills or rejects as soon as one of the\n\t\tpromises in the iterable fulfills or rejects, with the value or reason\n\t\tfrom that promise.",
      "new": "@throws DOMError",
      "then": "Appends fulfillment and rejection handlers to the promise and returns a\n\t\tnew promise resolving to the return value of the called handler, or to\n\t\tits original settled value if the promise was not handled\n\t\t(i.e. if the relevant handler onFulfilled or onRejected is not a function).",
      "catchError": "Appends a rejection handler callback to the promise, and returns a new\n\t\tpromise resolving to the return value of the callback if it is called,\n\t\tor to its original fulfillment value if the promise is instead fulfilled.",
      "finally": "Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,\n\t\tthe specified callback function is executed. This provides a way for code to be run\n\t\twhether the promise was fulfilled successfully or rejected once the Promise has been dealt with."
    },
    "fields": {}
  },
  "js.lib.RegExpMatch": {
    "doc": "Native JavaScript regular expressions.\n\n\tFor cross-platform regular expressions, use Haxe `EReg` class or\n\t[regexp literals](https://haxe.org/manual/std-regex.html).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>\n*/\n@:native(\"RegExp\")\nextern class RegExp {\n\t/**\n\t\tIndicates whether or not the \"g\" flag is used with the regular expression.\n*/\n\tvar global(default, null):Bool;\n\n\t/**\n\t\tIndicates whether or not the \"i\" flag is used with the regular expression.\n*/\n\tvar ignoreCase(default, null):Bool;\n\n\t/**\n\t\tIndicates whether or not the \"m\" flag is used with the regular expression.\n*/\n\tvar multiline(default, null):Bool;\n\n\t/**\n\t\tThe source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.\n*/\n\tvar source(default, null):String;\n\n\t/**\n\t\tThe index at which to start the next match.\n*/\n\tvar lastIndex:Int;\n\n\t/**\n\t\tCreate a regular expression object for matching text with a pattern.\n*/\n\tfunction new(pattern:String, ?flags:String);\n\n\t/**\n\t\tExecute a search for a match in a specified string.\n\t\tReturns a result array, or null.\n*/\n\tfunction exec(str:String):Null<RegExpMatch>;\n\n\t/**\n\t\tExecute a search for a match between a regular expression and a specified string.\n\t\tReturns true or false.\n*/\n\tfunction test(str:String):Bool;\n\n\t/**\n\t\tReturn a string representing the regular expression.\n*/\n\tfunction toString():String;\n}\n\n/**\n\tA return value of the `RegExp.exec` method.",
    "path": "haxe\\std\\js\\lib\\RegExp.hx",
    "functions": {
      "exec": "Execute a search for a match in a specified string.\n\t\tReturns a result array, or null.",
      "test": "Execute a search for a match between a regular expression and a specified string.\n\t\tReturns true or false.",
      "toString": "Return a string representing the regular expression."
    },
    "fields": {
      "ignoreCase": "Indicates whether or not the \"i\" flag is used with the regular expression.",
      "multiline": "Indicates whether or not the \"m\" flag is used with the regular expression.",
      "source": "The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.",
      "lastIndex": "The index at which to start the next match.",
      "index": "Create a regular expression object for matching text with a pattern.\n*/\n\tfunction new(pattern:String, ?flags:String);\n\n\t/**\n\t\tExecute a search for a match in a specified string.\n\t\tReturns a result array, or null.\n*/\n\tfunction exec(str:String):Null<RegExpMatch>;\n\n\t/**\n\t\tExecute a search for a match between a regular expression and a specified string.\n\t\tReturns true or false.\n*/\n\tfunction test(str:String):Bool;\n\n\t/**\n\t\tReturn a string representing the regular expression.\n*/\n\tfunction toString():String;\n}\n\n/**\n\tA return value of the `RegExp.exec` method.\n*/\nextern class RegExpMatch extends Array<String> {\n\t/**\n\t\tThe index of the search at which the result was found.",
      "input": "A copy of the search string.",
      "groups": "Named capturing groups or undefined if no named capturing groups were defined.\n\t\tSee [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.\n\n\t\tNote: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility)."
    }
  },
  "js.lib.SetKeyValueIterator": {
    "doc": "The `js.Set` object lets you store unique values of any type, whether\n\tprimitive values or object references.\n\n\tDocumentation [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Set\")\nextern class Set<T> {\n\t/**\n\t\tThe number of values in the `js.Set` object.\n*/\n\tvar size(default, null):Int;\n\n\t/**\n\t\tIf an iterable object is passed, all of its elements will be added to\n\t\tthe new `js.Set`.\n*/\n\t@:pure function new(?iterable:Any);\n\n\t/**\n\t\tReturns a boolean asserting whether an element is present with the given\n\t\tvalue in the `js.Set` object or not.\n*/\n\t@:pure function has(value:T):Bool;\n\n\t/**\n\t\tAppends a new element with the given value to the `js.Set` object.\n\t\tReturns the `js.Set` object.\n*/\n\tfunction add(value:T):Set<T>;\n\n\t/**\n\t\tRemoves the element associated to the value and returns the value that\n\t\t`has(value)` would have previously returned.\n\t\t`has(value)` will return `false` afterwards.\n*/\n\tfunction delete(value:T):Bool;\n\n\t/**\n\t\tRemoves all elements from the `js.Set` object.\n*/\n\tfunction clear():Void;\n\n\t/**\n\t\tCalls `callback` once for each key-value pair present in the `js.Set`\n\t\tobject, in insertion order.\n\n\t\tIf a `thisArg` parameter is provided to forEach, it will be used as the\n\t\t`this` value for each callback.\n*/\n\tfunction forEach(callback:(value:T, key:T, set:Set<T>) -> Void, ?thisArg:Any):Void;\n\n\t/**\n\t\tReturns a new `js.lib.Iterator` object that contains the keys for each element\n\t\tin the `js.Set` object in insertion order.\n*/\n\tfunction keys():js.lib.Iterator<T>;\n\n\t/**\n\t\tReturns a new `js.lib.Iterator` object that contains the values for each\n\t\telement in the `js.Set` object in insertion order.\n*/\n\tfunction values():js.lib.Iterator<T>;\n\n\t/**\n\t\tReturns a new `js.lib.Iterator` object that contains an array of\n\t\t`[value, value]` for each element in the `js.Set` object, in insertion\n\t\torder.\n\t\tThis is kept similar to the `js.Map` object, so that each entry has the\n\t\tsame value for its key and value here.\n*/\n\tfunction entries():js.lib.Iterator<KeyValue<T, T>>;\n\n\tinline function iterator():HaxeIterator<T> {\n\t\treturn new HaxeIterator(this.values());\n\t}\n\n\tinline function keyValueIterator():SetKeyValueIterator<T> {\n\t\treturn new SetKeyValueIterator(this);\n\t}\n}\n\n/**\n\tkey => value iterator for js.lib.Set, tracking the entry index for the key to match the behavior of haxe.ds.List",
    "path": "haxe\\std\\js\\lib\\Set.hx",
    "functions": {
      "delete": "Removes the element associated to the value and returns the value that\n\t\t`has(value)` would have previously returned.\n\t\t`has(value)` will return `false` afterwards.",
      "clear": "Removes all elements from the `js.Set` object.",
      "forEach": "Calls `callback` once for each key-value pair present in the `js.Set`\n\t\tobject, in insertion order.\n\n\t\tIf a `thisArg` parameter is provided to forEach, it will be used as the\n\t\t`this` value for each callback.",
      "keys": "Returns a new `js.lib.Iterator` object that contains the keys for each element\n\t\tin the `js.Set` object in insertion order.",
      "values": "Returns a new `js.lib.Iterator` object that contains the values for each\n\t\telement in the `js.Set` object in insertion order.",
      "entries": "Returns a new `js.lib.Iterator` object that contains an array of\n\t\t`[value, value]` for each element in the `js.Set` object, in insertion\n\t\torder.\n\t\tThis is kept similar to the `js.Map` object, so that each entry has the\n\t\tsame value for its key and value here."
    },
    "fields": {}
  },
  "lua.abstract": {
    "doc": "These are all global static methods within Lua.\n*/\n@:native(\"_G\")\nextern class Lua {\n\t/**\n\t\tA global variable that holds a string containing the current interpreter\n\t\tversion.\n*/\n\tstatic var _VERSION:String;\n\n\tstatic var arg:Table<Int, String>;\n\n\t/**\n\t\tPushes onto the stack the metatable in the registry.\n*/\n\tstatic function getmetatable(tbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n\t/**\n\t\tPops a table from the stack and sets it as the new metatable for the value\n\t\tat the given acceptable index.\n*/\n\tstatic function setmetatable(tbl:Table<Dynamic, Dynamic>, mtbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n\t/**\n\t\tPops a table from the stack and sets it as the new environment for the value\n\t\tat the given index. If the value at the given index is neither a function nor\n\t\ta thread nor a userdata, lua_setfenv returns `0`.\n\t\tOtherwise it returns `1`.\n*/\n\tstatic function setfenv(i:Int, tbl:Table<Dynamic, Dynamic>):Void;\n\n\t/**\n\t\tAllows a program to traverse all fields of a table.\n\t\tIts first argument is a table and its second argument is an index in this\n\t\ttable. `next` returns the next index of the table and its associated value.\n\t\tWhen `i` is `null`, `next` returns an initial index and its associated value.\n\t\tWhen called with the last index, or with `null` in an empty table, `next`\n\t\treturns `null`.  In particular, you can use `next(t)` to check whether a\n\t\ttable is empty.\n\n\t\tThe order in which the indices are enumerated is not specified, even for\n\t\tnumeric indices. (To traverse a table in numeric order, use a numerical for\n\t\tor the `ipairs` function).\n\n\t\tThe behavior of next is undefined if, during the traversal, any value\n\t\tto a non-existent field in the table is assigned. Existing fields may\n\t\thowever be modified. In particular, existing fields may be cleared.\n*/\n\tstatic function next<K, V>(k:Table<K, V>, ?i:K):NextResult<K, V>;\n\n\t/**\n\t\tReceives an argument of any type and converts it to a string in a reasonable\n\t\tformat.\n\n\t\tFor complete control of how numbers are converted, use`NativeStringTools.format`.\n*/\n\tstatic function tostring(v:Dynamic):String;\n\n\tstatic function ipairs<K, V>(t:Table<K, V>):IPairsResult<K, V>;\n\n\tstatic function pairs<K, V>(t:Table<K, V>):PairsResult<K, V>;\n\n\tstatic function require(module:String):Dynamic;\n\n\t/**\n\t\tConverts the Lua value at the given acceptable base to `Int`.\n\t\tThe Lua value must be a number or a string convertible to a number,\n\t\totherwise `tonumber` returns `0`.\n*/\n\tstatic function tonumber(str:String, ?base:Int):Int;\n\n\t/**\n\t\tReturns the Lua type of its only argument as a string.\n\t\tThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`\n*/\n\tstatic function type(v:Dynamic):String;\n\n\t/**\n\t\tReceives any number of arguments, and prints their values to stdout,\n\t\tusing the tostring function to convert them to strings.\n\t\t`print` is not intended for formatted output, but only as a quick way to show\n\t\ta value, typically for debugging.\n\n\t\tFor complete control of how numbers are converted, use `NativeStringTools.format`.\n*/\n\tstatic function print(v:haxe.extern.Rest<Dynamic>):Void;\n\n\t/**\n\t\tIf `n` is a number, returns all arguments after argument number `n`.\n\t\tOtherwise, `n` must be the string `\"#\"`, and select returns the total\n\t\tnumber of extra arguments it received.\n*/\n\tstatic function select(n:Dynamic, rest:Rest<Dynamic>):Dynamic;\n\n\t/**\n\t\tGets the real value of `table[index]`, without invoking any metamethod.\n*/\n\tstatic function rawget<K, V>(t:Table<K, V>, k:K):V;\n\n\t/**\n\t\tSets the real value of `table[index]` to value, without invoking any metamethod.\n*/\n\tstatic function rawset<K, V>(t:Table<K, V>, k:K, v:V):Void;\n\n\t/**\n\t\tThis function is a generic interface to the garbage collector.\n\t\tIt performs different functions according to its first argument.\n*/\n\tstatic function collectgarbage(opt:CollectGarbageOption, ?arg:Int):Int;\n\n\t/**\n\t\tIssues an error when the value of its argument `v` is `false` (i.e., `null`\n\t\tor `false`) otherwise, returns all its arguments. message is an error message.\n\t\twhen absent, it defaults to \"assertion failed!\"\n*/\n\tstatic function assert<T>(v:T, ?message:String):T;\n\n\t/**\n\t\tLoads and runs the given file.\n*/\n\tstatic function dofile(filename:String):Void;\n\n\t/**\n\t\tGenerates a Lua error. The error message (which can actually be a Lua value\n\t\tof any type) must be on the stack top. This function does a long jump,\n\t\tand therefore never returns.\n*/\n\tstatic function error(message:String, ?level:Int):Void;\n\n\t/**\n\t\tCalls a function in protected mode.\n*/\n\tstatic function pcall(f:Function, rest:Rest<Dynamic>):PCallResult;\n\n\t/**\n\t\tReturns `true` if the two values in acceptable indices `v1` and `v2` are\n\t\tprimitively equal (that is, without calling metamethods).\n\t\tOtherwise returns `false`.\n\t\tAlso returns `false` if any of the indices are non valid.\n*/\n\tstatic function rawequal(v1:Dynamic, v2:Dynamic):Bool;\n\n\t/**\n\t\tThis function is similar to pcall, except that you can set a new error\n\t\thandler.\n*/\n\tstatic function xpcall(f:Function, msgh:Function, rest:Rest<Dynamic>):PCallResult;\n\n\t/**\n\t\tLoads the chunk from file filename or from the standard input if no filename\n\t\tis given.\n*/\n\tstatic function loadfile(filename:String):LoadResult;\n\n\t/**\n\t\tLoads the chunk from given string.\n*/\n\tstatic function load(code:haxe.extern.EitherType<String, Void->String>):LoadResult;\n}\n\n/**\n\tEnum for describing garbage collection options",
    "path": "haxe\\std\\lua\\Lua.hx",
    "functions": {
      "setmetatable": "Pops a table from the stack and sets it as the new metatable for the value\n\t\tat the given acceptable index.",
      "setfenv": "Pops a table from the stack and sets it as the new environment for the value\n\t\tat the given index. If the value at the given index is neither a function nor\n\t\ta thread nor a userdata, lua_setfenv returns `0`.\n\t\tOtherwise it returns `1`.",
      "next": "Allows a program to traverse all fields of a table.\n\t\tIts first argument is a table and its second argument is an index in this\n\t\ttable. `next` returns the next index of the table and its associated value.\n\t\tWhen `i` is `null`, `next` returns an initial index and its associated value.\n\t\tWhen called with the last index, or with `null` in an empty table, `next`\n\t\treturns `null`.  In particular, you can use `next(t)` to check whether a\n\t\ttable is empty.\n\n\t\tThe order in which the indices are enumerated is not specified, even for\n\t\tnumeric indices. (To traverse a table in numeric order, use a numerical for\n\t\tor the `ipairs` function).\n\n\t\tThe behavior of next is undefined if, during the traversal, any value\n\t\tto a non-existent field in the table is assigned. Existing fields may\n\t\thowever be modified. In particular, existing fields may be cleared.",
      "tostring": "Receives an argument of any type and converts it to a string in a reasonable\n\t\tformat.\n\n\t\tFor complete control of how numbers are converted, use`NativeStringTools.format`.",
      "tonumber": "Converts the Lua value at the given acceptable base to `Int`.\n\t\tThe Lua value must be a number or a string convertible to a number,\n\t\totherwise `tonumber` returns `0`.",
      "type": "Returns the Lua type of its only argument as a string.\n\t\tThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`",
      "print": "Receives any number of arguments, and prints their values to stdout,\n\t\tusing the tostring function to convert them to strings.\n\t\t`print` is not intended for formatted output, but only as a quick way to show\n\t\ta value, typically for debugging.\n\n\t\tFor complete control of how numbers are converted, use `NativeStringTools.format`.",
      "select": "If `n` is a number, returns all arguments after argument number `n`.\n\t\tOtherwise, `n` must be the string `\"#\"`, and select returns the total\n\t\tnumber of extra arguments it received.",
      "rawget": "Gets the real value of `table[index]`, without invoking any metamethod.",
      "rawset": "Sets the real value of `table[index]` to value, without invoking any metamethod.",
      "collectgarbage": "This function is a generic interface to the garbage collector.\n\t\tIt performs different functions according to its first argument.",
      "assert": "Issues an error when the value of its argument `v` is `false` (i.e., `null`\n\t\tor `false`) otherwise, returns all its arguments. message is an error message.\n\t\twhen absent, it defaults to \"assertion failed!\"",
      "dofile": "Loads and runs the given file.",
      "error": "Generates a Lua error. The error message (which can actually be a Lua value\n\t\tof any type) must be on the stack top. This function does a long jump,\n\t\tand therefore never returns.",
      "pcall": "Calls a function in protected mode.",
      "rawequal": "Returns `true` if the two values in acceptable indices `v1` and `v2` are\n\t\tprimitively equal (that is, without calling metamethods).\n\t\tOtherwise returns `false`.\n\t\tAlso returns `false` if any of the indices are non valid.",
      "xpcall": "This function is similar to pcall, except that you can set a new error\n\t\thandler.",
      "loadfile": "Loads the chunk from file filename or from the standard input if no filename\n\t\tis given.",
      "load": "Loads the chunk from given string."
    },
    "fields": {}
  },
  "lua.HaxeIterator": {
    "doc": "An implementation of the Haxe iterator data structure needed for identical\n\tlua iterator behavior.",
    "path": "haxe\\std\\lua\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Lib": {
    "doc": "Platform-specific Lua Library. Provides some platform-specific functions\n\tfor the Lua target, such as conversion from Haxe types to native types\n\tand vice-versa.",
    "path": "haxe\\std\\lua\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.",
      "patternQuote": "Perform Lua-style pattern quoting on a given string.",
      "fillArray": "Fills an array with the result of a simple iterator.",
      "isShellAvailable": "Simple test for the presence of an available shell."
    },
    "fields": {}
  },
  "lua.PairTools": {
    "doc": "A set of utility methods for working with the Lua table extern.",
    "path": "haxe\\std\\lua\\PairTools.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Thread": {
    "doc": "The sole purpose of this extern is to provide a concrete type for\n\tbasic reflection purposes.",
    "path": "haxe\\std\\lua\\Thread.hx",
    "functions": {},
    "fields": {}
  },
  "neko.Lib": {
    "doc": "Platform-specific Neko Library. Provides some platform-specific functions\n\tfor the Neko target, such as conversion from Haxe types to native types\n\tand vice-versa.",
    "path": "haxe\\std\\neko\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.",
      "println": "Print the specified value on the default output followed by a newline character.",
      "rethrow": "Rethrow an exception. This is useful when manually filtering an exception in order\n\t\tto keep the previous exception stack.",
      "serialize": "Serialize using native Neko serialization. This will return a Binary string that can be\n\t\tstored for long term usage. The serialized data is optimized for speed and not for size.",
      "unserialize": "Unserialize a string using native Neko serialization. See `serialize`.",
      "localUnserialize": "Unserialize a string using native Neko serialization. See `serialize`.\n\t\tThis function assume that all the serialized data was serialized with current\n\t\tmodule, even if the module name was different. This can happen if you are unserializing\n\t\tsome data into mod_neko that was serialized on a different server using a different\n\t\tfile path.",
      "nekoToHaxe": "Converts a Neko value to its Haxe equivalent. Used for wrapping String and Arrays raw values into Haxe Objects.",
      "haxeToNeko": "Converts a Haxe value to its Neko equivalent. Used to unwrap String and Arrays Objects into raw Neko values.",
      "getClasses": "Returns an object containing all compiled packages and classes.",
      "stringReference": "Returns a string referencing the data contains in bytes.",
      "bytesReference": "Returns bytes referencing the content of a string."
    },
    "fields": {}
  },
  "neko.Random": {
    "doc": "A seeded pseudo-random generator.",
    "path": "haxe\\std\\neko\\Random.hx",
    "functions": {
      "setSeed": "Set the generator seed.",
      "int": "Return a random integer modulo max.",
      "float": "Return a random float."
    },
    "fields": {}
  },
  "neko.vm.Gc": {
    "doc": "Neko garbage collector utility.",
    "path": "haxe\\std\\neko\\vm\\Gc.hx",
    "functions": {
      "stats": "Return the size of the GC heap and the among of free space,\n\t\tin bytes."
    },
    "fields": {}
  },
  "neko.vm.Loader": {
    "doc": "The Neko object that implements the loader.\n*/\n@:callable\n@:coreType\nabstract LoaderHandle {}\n\n/**\n\tLoaders can be used to dynamically load Neko primitives stored in NDLL libraries.\n\n\n\tLoaders can be used to dynamically load other Neko modules (.n bytecode files).\n\tModules are referenced by names. To lookup the corresponding bytecode file, the\n\tdefault loader first look in its cache, then eventually adds the .n extension\n\tto the name and lookup the bytecode in its path.\n\n\n\tLoaders can be used for sandbox security. When a Module is loaded with a given\n\tLoader, this loader can manager the module security by filtering which\n\tprimitives can be loaded by this module or by rewrapping them at loading-time\n\twith custom secured versions. Loaders are inherited in loaded submodules.",
    "path": "haxe\\std\\neko\\vm\\Loader.hx",
    "functions": {
      "addPath": "Adds a directory to the search path. See `getPath`.",
      "getCache": "The default loader contains a cache of already loaded modules. It's\n\t\tensuring that the same module does not get loaded twice when circular\n\t\treferences are occurring. The same module can eventually be loaded twice\n\t\tbut with different names, for example with two relative paths representing\n\t\tthe same file, since the cache is done on a by-name basic.",
      "setCache": "Set a module in the loader cache.",
      "backupCache": "Change the cache value and returns the old value. This can be used\n\t\tto backup the loader cache and restore it later.",
      "loadPrimitive": "Loads a neko primitive. By default, the name is of the form `[library@method]`.\n\t\tThe primitive might not be used directly in Haxe since some of the Neko values\n\t\tneeds an object wrapper in Haxe.",
      "loadModule": "Loads a Module with the given name. If `loader` is defined, this will be\n\t\tthis Module loader, else this loader will be inherited. When loaded this\n\t\tway, the module is directly executed.",
      "local": "Returns the local Loader. This is the loader that was used to load the\n\t\tmodule in which the code is defined.",
      "make": "Creates a loader using two methods. This loader will not have an accessible cache or path,\n\t\talthough you can implement such mechanism in the methods body."
    },
    "fields": {}
  },
  "neko.vm.Module": {
    "doc": "The abstract Neko module handle.\n*/\n@:callable\n@:coreType\nabstract ModuleHandle {}\n\n/**\n\tA Neko Module represent a execution unit for the Neko Virtual Machine.\n\tEach compiled `.n` bytecode file is a module once loaded by the NekoVM.",
    "path": "haxe\\std\\neko\\vm\\Module.hx",
    "functions": {
      "loader": "Returns the Loader that this Module was loaded with.",
      "codeSize": "Returns the codeSize of the Module.",
      "globalsCount": "Returns the number of globals in this Module global table.",
      "getGlobal": "Get a Module global value.",
      "setGlobal": "Set a Module global value.",
      "getExports": "Each Module has an export table which can be useful to transfer\n\t\tvalues between modules.",
      "exportsTable": "The raw export table.",
      "setExport": "Set a value in the Module export table.",
      "local": "Returns the local Module, which is the one in which this\n\t\tmethod is included.",
      "read": "Reads a module from an Input by using the given Loader.\n\t\tThe module is initialized but has not yet been executed.",
      "readBytes": "Reads a module from Bytes using the given Loader.\n\t\tThe module is initialized but has not yet been executed.",
      "readPath": "Reads a module from a name and using the specified search path and loader.\n\t\tThe module is initialized but has not yet been executed.",
      "readGlobalsNames": "Extract the globals names from the given module"
    },
    "fields": {}
  },
  "neko.vm.Ui": {
    "doc": "Core native User Interface support. This API uses native WIN32 API\n\ton Windows, Carbon API on OSX, and GTK2 on Linux.",
    "path": "haxe\\std\\neko\\vm\\Ui.hx",
    "functions": {
      "loop": "Starts the native UI event loop. This method can only be called\n\t\tfrom the main thread.",
      "stopLoop": "Stop the native UI event loop. This method can only be called\n\t\tfrom the main thread.",
      "sync": "Queue a method call callb to be executed by the main thread while\n\t\trunning the UI event loop. This can be used to perform UI updates\n\t\tin the UI thread using results processed by another thread."
    },
    "fields": {}
  },
  "php.Lib": {
    "doc": "Platform-specific PHP Library. Provides some platform-specific functions\n\tfor the PHP target, such as conversion from Haxe types to native types\n\tand vice-versa.",
    "path": "haxe\\std\\php\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by\n\t\ta newline character.",
      "dump": "Displays structured information about one or more expressions\n\t\tthat includes its type and value. Arrays and objects are\n\t\texplored recursively with values indented to show structure.",
      "serialize": "Serialize using native PHP serialization. This will return a binary\n\t\t`String` that can be stored for long term usage.",
      "unserialize": "Unserialize a `String` using native PHP serialization. See `php.Lib.serialize()`.",
      "extensionLoaded": "Find out whether an extension is loaded.",
      "printFile": "Output file content from the given file name.",
      "mail": "See the documentation for the equivalent PHP function for details on usage:\n\t\t<http://php.net/manual/en/function.mail.php>",
      "getClasses": "Rethrows an exception.\n\t\tIf `e` is not a value caught in `try...catch` or if called outside of `catch` block, then `e` is thrown as\n\t\ta new exception.\n*/\n\textern public static inline function rethrow(e:Dynamic) {\n\t\tif (Syntax.code(\"isset($__hx__caught_e, $__hx__real_e)\") && e == Syntax.code(\"$__hx__real_e\")) {\n\t\t\tSyntax.code(\"throw $__hx__caught_e\");\n\t\t}\n\t\tthrow e;\n\t}\n\n\t/**\n\t\tTries to load all compiled php files and returns list of types.",
      "loadLib": "Loads types defined in the specified directory."
    },
    "fields": {}
  },
  "php.Resource": {
    "doc": "PHP native `resource` type\n\t@see http://php.net/manual/en/language.types.resource.php",
    "path": "haxe\\std\\php\\Resource.hx",
    "functions": {},
    "fields": {}
  },
  "php.Session": {
    "doc": "Session consists of a way to preserve certain data across\n\tsubsequent accesses.",
    "path": "haxe\\std\\php\\Session.hx",
    "functions": {},
    "fields": {}
  },
  "python.KwArgs": {
    "doc": "This type represents python `**kwargs` feature, supporting\n\tpassing named arguments to a function.\n\n\tExample:\n\n\t```haxe\n\tfunction f(kwargs:KwArgs<{a:Int}>) {}\n\tf({a: 10});\n\t```",
    "path": "haxe\\std\\python\\KwArgs.hx",
    "functions": {},
    "fields": {}
  },
  "python.Lib": {
    "doc": "Platform-specific Python Library. Provides some platform-specific functions\n\tfor the Python target, such as conversion from Haxe types to native types\n\tand vice-versa.",
    "path": "haxe\\std\\python\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by a newline character.",
      "dictToAnon": "Returns an anonymous Object which holds the same data as the Dictionary `v`.",
      "anonToDict": "Returns a flat copy of the underlying Dictionary of `o`.",
      "anonAsDict": "Returns the underlying Dictionary of the anonymous object `o`.\n\t\tModifications to this dictionary are reflected in the anonymous Object too.",
      "dictAsAnon": "Returns the Dictionary `d` as an anonymous Object.\n\t\tModifications to the object are reflected in the Dictionary too.",
      "toPythonIterable": "Return Python native iterable from Haxe iterable.",
      "toHaxeIterable": "Return Haxe iterable from Python native iterable.",
      "toHaxeIterator": "Return Haxe iterator instance from Python native iterable."
    },
    "fields": {}
  },
  "python.NativeIterable": {
    "doc": "This type represents native Python iterables (objects that implement `__iter__()` method).\n\tIt supports Haxe iteration and conversion to `Iterable` by creating wrapper objects.",
    "path": "haxe\\std\\python\\NativeIterable.hx",
    "functions": {},
    "fields": {}
  },
  "python.NativeIterator": {
    "doc": "This type represents native Python iterators.\n\tIt supports automatic conversion to Haxe `Iterator` by creating wrapper object.",
    "path": "haxe\\std\\python\\NativeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "python.internal.UBuiltins": {
    "doc": "This class provides unqualified access to python builtins that are safe to use in haxe/python code.\n\tFields listed here must be synchronized with genpy's KeywordHandler.kwds2 list to be properly escaped.",
    "path": "haxe\\std\\python\\internal\\UBuiltins.hx",
    "functions": {},
    "fields": {}
  },
  "sys.FileSystem": {
    "doc": "This class provides information about files and directories.\n\n\tIf `null` is passed as a file path to any function in this class, the\n\tresult is unspecified, and may differ from target to target.\n\n\tSee `sys.io.File` for the complementary file API.",
    "path": "haxe\\std\\sys\\FileSystem.hx",
    "functions": {
      "rename": "Renames/moves the file or directory specified by `path` to `newPath`.\n\n\t\tIf `path` is not a valid file system entry, or if it is not accessible,\n\t\tor if `newPath` is not accessible, an exception is thrown.",
      "stat": "Returns `FileStat` information for the file or directory specified by\n\t\t`path`.",
      "fullPath": "Returns the full path of the file or directory specified by `relPath`,\n\t\twhich is relative to the current working directory. Symlinks will be\n\t\tfollowed and the path will be normalized.",
      "absolutePath": "Returns the full path of the file or directory specified by `relPath`,\n\t\twhich is relative to the current working directory. The path doesn't\n\t\thave to exist.",
      "isDirectory": "Returns `true` if the file or directory specified by `path` is a directory.\n\n\t\tIf `path` is not a valid file system entry or if its destination is not\n\t\taccessible, an exception is thrown.",
      "createDirectory": "Creates a directory specified by `path`.\n\n\t\tThis method is recursive: The parent directories don't have to exist.\n\n\t\tIf the directory cannot be created, an exception is thrown.",
      "deleteFile": "Deletes the file specified by `path`.\n\n\t\tIf `path` does not denote a valid file, or if that file cannot be\n\t\tdeleted, an exception is thrown.",
      "deleteDirectory": "Deletes the directory specified by `path`. Only empty directories can\n\t\tbe deleted.\n\n\t\tIf `path` does not denote a valid directory, or if that directory cannot\n\t\tbe deleted, an exception is thrown.",
      "readDirectory": "Returns the names of all files and directories in the directory specified\n\t\tby `path`. `\".\"` and `\"..\"` are not included in the output.\n\n\t\tIf `path` does not denote a valid directory, an exception is thrown."
    },
    "fields": {}
  },
  "sys.io.File": {
    "doc": "API for reading and writing files.\n\n\tSee `sys.FileSystem` for the complementary file system API.",
    "path": "haxe\\std\\sys\\io\\File.hx",
    "functions": {
      "saveContent": "Stores `content` in the file specified by `path`.\n\n\t\tIf the file cannot be written to, an exception is thrown.\n\n\t\tIf `path` or `content` are null, the result is unspecified.",
      "getBytes": "Retrieves the binary content of the file specified by `path`.\n\n\t\tIf the file does not exist or can not be read, an exception is thrown.\n\n\t\t`sys.FileSystem.exists` can be used to check for existence.\n\n\t\tIf `path` is null, the result is unspecified.",
      "saveBytes": "Stores `bytes` in the file specified by `path` in binary mode.\n\n\t\tIf the file cannot be written to, an exception is thrown.\n\n\t\tIf `path` or `bytes` are null, the result is unspecified.",
      "read": "Returns an `FileInput` handle to the file specified by `path`.\n\n\t\tIf `binary` is true, the file is opened in binary mode. Otherwise it is\n\t\topened in non-binary mode.\n\n\t\tIf the file does not exist or can not be read, an exception is thrown.\n\n\t\tOperations on the returned `FileInput` handle read on the opened file.\n\n\t\tFile handles should be closed via `FileInput.close` once the operation\n\t\tis complete.\n\n\t\tIf `path` is null, the result is unspecified.",
      "write": "Returns an `FileOutput` handle to the file specified by `path`.\n\n\t\tIf `binary` is true, the file is opened in binary mode. Otherwise it is\n\t\topened in non-binary mode.\n\n\t\tIf the file cannot be written to, an exception is thrown.\n\n\t\tOperations on the returned `FileOutput` handle write to the opened file.\n\t\tIf the file existed, its previous content is overwritten.\n\n\t\tFile handles should be closed via `FileOutput.close` once the operation\n\t\tis complete.\n\n\t\tIf `path` is null, the result is unspecified.",
      "append": "Similar to `sys.io.File.write`, but appends to the file if it exists\n\t\tinstead of overwriting its contents.",
      "update": "Similar to `sys.io.File.append`. While `append` can only seek or write\n\t\tstarting from the end of the file's previous contents, `update` can\n\t\tseek to any position, so the file's previous contents can be\n\t\tselectively overwritten.",
      "copy": "Copies the contents of the file specified by `srcPath` to the file\n\t\tspecified by `dstPath`.\n\n\t\tIf the `srcPath` does not exist or cannot be read, or if the `dstPath`\n\t\tfile cannot be written to, an exception is thrown.\n\n\t\tIf the file at `dstPath` exists, its contents are overwritten.\n\n\t\tIf `srcPath` or `dstPath` are null, the result is unspecified."
    },
    "fields": {}
  },
  "sys.io.FileInput": {
    "doc": "Use `sys.io.File.read` to create a `FileInput`.",
    "path": "haxe\\std\\sys\\io\\FileInput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.io.FileOutput": {
    "doc": "Use `sys.io.File.write` to create a `FileOutput`.",
    "path": "haxe\\std\\sys\\io\\FileOutput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Address": {
    "doc": "An address is used to represent a port on a given host ip.\n\tIt is used by `sys.net.UdpSocket`.",
    "path": "haxe\\std\\sys\\net\\Address.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Host": {
    "doc": "A given IP host name.",
    "path": "haxe\\std\\sys\\net\\Host.hx",
    "functions": {
      "toString": "Returns the IP representation of the host",
      "reverse": "Perform a reverse-DNS query to resolve a host name from an IP.",
      "localhost": "Returns the local computer host name"
    },
    "fields": {
      "ip": "The actual IP corresponding to the host."
    }
  },
  "sys.net.Socket": {
    "doc": "A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.",
    "path": "haxe\\std\\sys\\net\\Socket.hx",
    "functions": {
      "close": "Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.",
      "read": "Read the whole data available on the socket.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`,\n\t\tas it will always throw `haxe.io.Error.Blocked`. `input` methods should be used directly instead.",
      "write": "Write the whole data to the socket output.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`, as\n\t\t`haxe.io.Error.Blocked` may be thrown mid-write with no indication of how many bytes have been written.\n\t\t`output.writeBytes()` should be used instead as it returns this information.",
      "connect": "Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.",
      "listen": "Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.",
      "shutdown": "Shutdown the socket, either for reading or writing.",
      "bind": "Bind the socket to the given host/port so it can afterwards listen for connections there.",
      "accept": "Accept a new connected client. This will return a connected socket on which you can read/write some data.",
      "peer": "Return the information about the other side of a connected socket.",
      "host": "Return the information about our side of a connected socket.",
      "setTimeout": "Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.",
      "waitForRead": "Block until some data is available for read on the socket.",
      "setBlocking": "Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.",
      "setFastSend": "Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.",
      "select": "Wait until one of the sockets group is ready for the given operation:\n\n\t\t - `read` contains sockets on which we want to wait for available data to be read,\n\t\t - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,\n\t\t - `others` contains sockets on which we want to wait for exceptional conditions.\n\t\t - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.\n\n\t\tIn case a `timeout` (in seconds) is specified, select might wait at worst until the timeout expires."
    },
    "fields": {
      "output": "The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.",
      "custom": "A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.\n*"
    }
  },
  "sys.net.UdpSocket": {
    "doc": "A UDP socket class",
    "path": "haxe\\std\\sys\\net\\UdpSocket.hx",
    "functions": {
      "sendTo": "Sends data to the specified target host/port address.",
      "readFrom": "Reads data from any incoming address and store the receiver address into the address parameter."
    },
    "fields": {}
  },
  "sys.ssl.Socket": {
    "doc": "A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.",
    "path": "haxe\\std\\sys\\ssl\\Socket.hx",
    "functions": {
      "setCA": "Configure the certificate chain for peer certificate verification.",
      "setHostname": "Configure the hostname for Server Name Indication TLS extension.",
      "setCertificate": "Configure own certificate and private key.",
      "addSNICertificate": "Configure additional certificates and private keys for Server Name Indication extension.\n\t\tThe callback may be called during handshake to determine the certificate to use.",
      "peerCertificate": "Return the certificate received from the other side of a connection."
    },
    "fields": {}
  },
  "sys.thread.NextEventTime": {
    "doc": "When an event loop has an available event to execute.",
    "path": "haxe\\std\\sys\\thread\\EventLoop.hx",
    "functions": {
      "cancel": "Prevent execution of a previously scheduled event in current loop.",
      "promise": "Notify this loop about an upcoming event.\n\t\tThis makes the thread stay alive and wait for as many events as the number of\n\t\ttimes `.promise()` was called. These events should be added via `.runPromised()`.",
      "run": "Execute `event` as soon as possible.",
      "runPromised": "Add previously promised `event` for execution.",
      "progress": "Executes all pending events.\n\n\t\tThe returned time stamps can be used with `Sys.time()` for calculations.\n\n\t\tDepending on a target platform this method may be non-reentrant. It must\n\t\tnot be called from event callbacks.",
      "wait": "Blocks until a new event is added or `timeout` (in seconds) to expires.\n\n\t\tDepending on a target platform this method may also automatically execute arriving\n\t\tevents while waiting. However if any event is executed it will stop waiting.\n\n\t\tReturns `true` if more events are expected.\n\t\tReturns `false` if no more events expected.\n\n\t\tDepending on a target platform this method may be non-reentrant. It must\n\t\tnot be called from event callbacks.",
      "loop": "Execute all pending events.\n\t\tWait and execute as many events as the number of times `promise()` was called.\n\t\tRuns until all repeating events are cancelled and no more events are expected.\n\n\t\tDepending on a target platform this method may be non-reentrant. It must\n\t\tnot be called from event callbacks.",
      "__progress": "`.progress` implementation with a reusable array for internal usage.\n\t\tThe `nextEventAt` field of the return value denotes when the next event\n\t\tis expected to run:\n-1 - never\n-2 - now\nother values - at specified time"
    },
    "fields": {}
  },
  "sys.thread.IThreadPool": {
    "doc": "A thread pool interface.",
    "path": "haxe\\std\\sys\\thread\\IThreadPool.hx",
    "functions": {
      "shutdown": "Initiates a shutdown.\n\t\tAll previously submitted tasks will be executed, but no new tasks will\n\t\tbe accepted.\n\n\t\tMultiple calls to this method have no effect."
    },
    "fields": {
      "isShutdown": "Indicates if `shutdown` method of this pool has been called."
    }
  },
  "sys.thread.Lock": {
    "doc": "A Lock allows blocking execution until it has been unlocked. It keeps track\n\tof how often `release` has been called, and blocks exactly as many `wait`\n\tcalls.\n\n\tThe order of the `release` and `wait` calls is irrelevant. That is, a Lock\n\tcan be released before anyone waits for it. In that case, the `wait` call\n\twill execute immediately.\n\n\tUsage example:\n\n\t```haxe\n\tvar lock = new Lock();\n\tvar elements = [1, 2, 3];\n\tfor (element in elements) {\n\t\t// Create one thread per element\n\t\tnew Thread(function() {\n\t\t\ttrace(element);\n\t\t\tSys.sleep(1);\n\t\t\t// Release once per thread = 3 times\n\t\t\tlock.release();\n\t\t});\n\t}\n\tfor (_ in elements) {\n\t\t// Wait 3 times\n\t\tlock.wait();\n\t}\n\ttrace(\"All threads finished\");\n\t```",
    "path": "haxe\\std\\sys\\thread\\Lock.hx",
    "functions": {
      "wait": "Waits for the lock to be released, or `timeout` (in seconds)\n\t\tto expire. Returns `true` if the lock is released and `false`\n\t\tif a time-out occurs.",
      "release": "Releases the lock once.\n\n\t\tThe thread does not need to own the lock in order to release\n\t\tit. Each call to `release` allows exactly one call to `wait`\n\t\tto execute."
    },
    "fields": {}
  },
  "sys.thread.Mutex": {
    "doc": "Creates a mutex, which can be used to acquire a temporary lock\n\tto access some resource. The main difference with a lock is\n\tthat a mutex must always be released by the owner thread.",
    "path": "haxe\\std\\sys\\thread\\Mutex.hx",
    "functions": {
      "acquire": "The current thread acquire the mutex or wait if not available.\n\t\tThe same thread can acquire several times the same mutex but\n\t\tmust release it as many times it has been acquired.",
      "tryAcquire": "Try to acquire the mutex, returns true if acquire or false\n\t\tif it's already locked by another thread.",
      "release": "Release a mutex that has been acquired by the current thread.\n\t\tThe behavior is undefined if the current thread does not own\n\t\tthe mutex."
    },
    "fields": {}
  },
  "sys.thread.Tls": {
    "doc": "Creates thread local storage.\n\n\t(hl) Warning: At the moment `Tls` does not protect the value from being\n\tgarbage collected. Keep the value reachable to avoid crashes.",
    "path": "haxe\\std\\sys\\thread\\Tls.hx",
    "functions": {},
    "fields": {}
  }
}