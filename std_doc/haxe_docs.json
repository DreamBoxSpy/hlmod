{
  "Date": {
    "doc": "The Date class provides a basic structure for date and time related\ninformation. Date instances can be created by\n\n- `new Date()` for a specific date,\n- `Date.now()` to obtain information about the current time,\n- `Date.fromTime()` with a given timestamp or\n- `Date.fromString()` by parsing from a String.\n\nThere are some extra functions available in the `DateTools` class.\n\nIn the context of Haxe dates, a timestamp is defined as the number of\nmilliseconds elapsed since 1st January 1970 UTC.\n\n## Supported range\n\nDue to platform limitations, only dates in the range 1970 through 2038 are\nsupported consistently. Some targets may support dates outside this range,\ndepending on the OS at runtime. The `Date.fromTime` method will not work with\ntimestamps outside the range on any target.\n",
    "path": "haxe\\std\\Date.hx",
    "functions": {
      "getTime": "Returns the timestamp (in milliseconds) of `this` date.\nOn cpp and neko, this function only has a second resolution, so the\nresult will always be a multiple of `1000.0`, e.g. `1454698271000.0`.\nTo obtain the current timestamp with better precision on cpp and neko,\nsee the `Sys.time` API.\n\nFor measuring time differences with millisecond accuracy on\nall platforms, see `haxe.Timer.stamp`.\n",
      "getHours": "Returns the hours of `this` Date (0-23 range) in the local timezone.\n",
      "getMinutes": "Returns the minutes of `this` Date (0-59 range) in the local timezone.\n",
      "getSeconds": "Returns the seconds of `this` Date (0-59 range) in the local timezone.\n",
      "getFullYear": "Returns the full year of `this` Date (4 digits) in the local timezone.\n",
      "getMonth": "Returns the month of `this` Date (0-11 range) in the local timezone.\nNote that the month number is zero-based.\n",
      "getDate": "Returns the day of `this` Date (1-31 range) in the local timezone.\n",
      "getDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\nin the local timezone.\n",
      "getUTCHours": "Returns the hours of `this` Date (0-23 range) in UTC.\n",
      "getUTCMinutes": "Returns the minutes of `this` Date (0-59 range) in UTC.\n",
      "getUTCSeconds": "Returns the seconds of `this` Date (0-59 range) in UTC.\n",
      "getUTCFullYear": "Returns the full year of `this` Date (4 digits) in UTC.\n",
      "getUTCMonth": "Returns the month of `this` Date (0-11 range) in UTC.\nNote that the month number is zero-based.\n",
      "getUTCDate": "Returns the day of `this` Date (1-31 range) in UTC.\n",
      "getUTCDay": "Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)\nin UTC.\n",
      "getTimezoneOffset": "Returns the time zone difference of `this` Date in the current locale\nto UTC, in minutes.\n\nAssuming the function is executed on a machine in a UTC+2 timezone,\n`Date.now().getTimezoneOffset()` will return `-120`.\n",
      "toString": "Returns a string representation of `this` Date in the local timezone\nusing the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for\nother formatting rules.\n",
      "now": "Returns a Date representing the current local time.\n",
      "fromTime": "Creates a Date from the timestamp (in milliseconds) `t`.\n",
      "fromString": "Creates a Date from the formatted string `s`. The following formats are\naccepted by the function:\n\n- `\"YYYY-MM-DD hh:mm:ss\"`\n- `\"YYYY-MM-DD\"`\n- `\"hh:mm:ss\"`\n\nThe first two formats expressed a date in local time. The third is a time\nrelative to the UTC epoch.\n\nIf `s` does not match these formats, the result is unspecified.\n"
    },
    "fields": {}
  },
  "DateTools": {
    "doc": "The DateTools class contains some extra functionalities for handling `Date`\ninstances and timestamps.\n\nIn the context of Haxe dates, a timestamp is defined as the number of\nmilliseconds elapsed since 1st January 1970.\n",
    "path": "haxe\\std\\DateTools.hx",
    "functions": {
      "delta": "Returns the result of adding timestamp `t` to Date `d`.\n\nThis is a convenience function for calling\n`Date.fromTime(d.getTime() + t)`.\n",
      "getMonthDays": "Returns the number of days in the month of Date `d`.\n\nThis method handles leap years.\n",
      "seconds": "Converts a number of seconds to a timestamp.\n",
      "minutes": "Converts a number of minutes to a timestamp.\n",
      "hours": "Converts a number of hours to a timestamp.\n",
      "days": "Converts a number of days to a timestamp.\n",
      "parse": "Separate a date-time into several components\n",
      "make": "Build a date-time from several components\n"
    },
    "fields": {}
  },
  "EReg": {
    "doc": "The EReg class represents regular expressions.\n\nWhile basic usage and patterns consistently work across platforms, some more\ncomplex operations may yield different results. This is a necessary trade-\noff to retain a certain level of performance.\n\nEReg instances can be created by calling the constructor, or with the\nspecial syntax `~/pattern/modifier`\n\nEReg instances maintain an internal state, which is affected by several of\nits methods.\n\nA detailed explanation of the supported operations is available at\n<https://haxe.org/manual/std-regex.html>\n",
    "path": "haxe\\std\\EReg.hx",
    "functions": {
      "match": "Tells if `this` regular expression matches String `s`.\n\nThis method modifies the internal state.\n\nIf `s` is `null`, the result is unspecified.\n",
      "matched": "Returns the matched sub-group `n` of `this` EReg.\n\nThis method should only be called after `this.match` or\n`this.matchSub`, and then operates on the String of that operation.\n\nThe index `n` corresponds to the n-th set of parentheses in the pattern\nof `this` EReg. If no such sub-group exists, the result is unspecified.\n\nIf `n` equals 0, the whole matched substring is returned.\n",
      "matchedLeft": "Returns the part to the left of the last matched substring.\n\nIf the most recent call to `this.match` or `this.matchSub` did not\nmatch anything, the result is unspecified.\n\nIf the global g modifier was in place for the matching, only the\nsubstring to the left of the leftmost match is returned.\n\nThe result does not include the matched part.\n",
      "matchedRight": "Returns the part to the right of the last matched substring.\n\nIf the most recent call to `this.match` or `this.matchSub` did not\nmatch anything, the result is unspecified.\n\nIf the global g modifier was in place for the matching, only the\nsubstring to the right of the leftmost match is returned.\n\nThe result does not include the matched part.\n",
      "matchedPos": "Returns the position and length of the last matched substring, within\nthe String which was last used as argument to `this.match` or\n`this.matchSub`.\n\nIf the most recent call to `this.match` or `this.matchSub` did not\nmatch anything, the result is unspecified.\n\nIf the global g modifier was in place for the matching, the position and\nlength of the leftmost substring is returned.\n",
      "matchSub": "Tells if `this` regular expression matches a substring of String `s`.\n\nThis function expects `pos` and `len` to describe a valid substring of\n`s`, or else the result is unspecified. To get more robust behavior,\n`this.match(s.substr(pos,len))` can be used instead.\n\nThis method modifies the internal state.\n\nIf `s` is null, the result is unspecified.\n",
      "matchedNum": "Returns the total number of groups captures by the last matched substring.\n\nTo stay consistent with `this.matched`, the matched substring is also\ncounted as a group.\n\nReturns `0` if no substring has been matched.\n",
      "split": "Splits String `s` at all substrings `this` EReg matches.\n\nIf a match is found at the start of `s`, the result contains a leading\nempty String \"\" entry.\n\nIf a match is found at the end of `s`, the result contains a trailing\nempty String \"\" entry.\n\nIf two matching substrings appear next to each other, the result\ncontains the empty String `\"\"` between them.\n\nBy default, this method splits `s` into two parts at the first matched\nsubstring. If the global g modifier is in place, `s` is split at each\nmatched substring.\n\nIf `s` is null, the result is unspecified.\n",
      "replace": "Replaces the first substring of `s` which `this` EReg matches with `by`.\n\nIf `this` EReg does not match any substring, the result is `s`.\n\nBy default, this method replaces only the first matched substring. If\nthe global g modifier is in place, all matched substrings are replaced.\n\nIf `by` contains `$1` to `$9`, the digit corresponds to number of a\nmatched sub-group and its value is used instead. If no such sub-group\nexists, the replacement is unspecified. The string `$$` becomes `$`.\n\nIf `s` or `by` are null, the result is unspecified.\n",
      "map": "Calls the function `f` for the substring of `s` which `this` EReg matches\nand replaces that substring with the result of `f` call.\n\nThe `f` function takes `this` EReg object as its first argument and should\nreturn a replacement string for the substring matched.\n\nIf `this` EReg does not match any substring, the result is `s`.\n\nBy default, this method replaces only the first matched substring. If\nthe global g modifier is in place, all matched substrings are replaced.\n\nIf `s` or `f` are null, the result is unspecified.\n",
      "escape": "Escape the string `s` for use as a part of regular expression.\n\nIf `s` is null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "IntIterator": {
    "doc": "IntIterator is used for implementing interval iterations.\n\nIt is usually not used explicitly, but through its special syntax:\n`min...max`\n\nWhile it is possible to assign an instance of IntIterator to a variable or\nfield, it is worth noting that IntIterator does not reset after being used\nin a for-loop. Subsequent uses of the same instance will then have no\neffect.\n\n@see https://haxe.org/manual/lf-iterators.html\n",
    "path": "haxe\\std\\IntIterator.hx",
    "functions": {
      "hasNext": "Returns true if the iterator has other items, false otherwise.\n",
      "next": "Moves to the next item of the iterator.\n\nIf this is called while hasNext() is false, the result is unspecified.\n"
    },
    "fields": {}
  },
  "Lambda": {
    "doc": "The `Lambda` class is a collection of methods to support functional\nprogramming. It is ideally used with `using Lambda` and then acts as an\nextension to Iterable types.\n\nOn static platforms, working with the Iterable structure might be slower\nthan performing the operations directly on known types, such as Array and\nList.\n\nIf the first argument to any of the methods is null, the result is\nunspecified.\n\n@see https://haxe.org/manual/std-Lambda.html\n",
    "path": "haxe\\std\\Lambda.hx",
    "functions": {
      "list": "Creates a List form Iterable `it`.\n\nIf `it` is a List, this function returns a copy of it.\n",
      "map": "Creates a new Array by applying function `f` to all elements of `it`.\nThe order of elements is preserved.\nIf `f` is null, the result is unspecified.\n",
      "mapi": "Similar to map, but also passes the index of each element to `f`.\nThe order of elements is preserved.\nIf `f` is null, the result is unspecified.\n",
      "flatten": "Concatenate a list of iterables.\nThe order of elements is preserved.\n",
      "flatMap": "A composition of map and flatten.\nThe order of elements is preserved.\nIf `f` is null, the result is unspecified.\n",
      "has": "Tells if `it` contains `elt`.\n\nThis function returns true as soon as an element is found which is equal\nto `elt` according to the `==` operator.\n\nIf no such element is found, the result is false.\n",
      "exists": "Tells if `it` contains an element for which `f` is true.\n\nThis function returns true as soon as an element is found for which a\ncall to `f` returns true.\n\nIf no such element is found, the result is false.\n\nIf `f` is null, the result is unspecified.\n",
      "foreach": "Tells if `f` is true for all elements of `it`.\n\nThis function returns false as soon as an element is found for which a\ncall to `f` returns false.\n\nIf no such element is found, the result is true.\n\nIn particular, this function always returns true if `it` is empty.\n\nIf `f` is null, the result is unspecified.\n",
      "iter": "Calls `f` on all elements of `it`, in order.\n\nIf `f` is null, the result is unspecified.\n",
      "filter": "Returns a Array containing those elements of `it` for which `f` returned\ntrue.\nIf `it` is empty, the result is the empty Array even if `f` is null.\nOtherwise if `f` is null, the result is unspecified.\n",
      "fold": "Functional fold on Iterable `it`, using function `f` with start argument\n`first`.\n\nIf `it` has no elements, the result is `first`.\n\nOtherwise the first element of `it` is passed to `f` alongside `first`.\nThe result of that call is then passed to `f` with the next element of\n`it`, and so on until `it` has no more elements.\n\nIf `it` or `f` are null, the result is unspecified.\n",
      "foldi": "Similar to fold, but also passes the index of each element to `f`.\n\nIf `it` or `f` are null, the result is unspecified.\n",
      "count": "Returns the number of elements in `it` for which `pred` is true, or the\ntotal number of elements in `it` if `pred` is null.\n\nThis function traverses all elements.\n",
      "empty": "Tells if Iterable `it` does not contain any element.\n",
      "indexOf": "Returns the index of the first element `v` within Iterable `it`.\n\nThis function uses operator `==` to check for equality.\n\nIf `v` does not exist in `it`, the result is -1.\n",
      "find": "Returns the first element of `it` for which `f` is true.\n\nThis function returns as soon as an element is found for which a call to\n`f` returns true.\n\nIf no such element is found, the result is null.\n\nIf `f` is null, the result is unspecified.\n",
      "findIndex": "Returns the index of the first element of `it` for which `f` is true.\n\nThis function returns as soon as an element is found for which a call to\n`f` returns true.\n\nIf no such element is found, the result is -1.\n\nIf `f` is null, the result is unspecified.\n",
      "concat": "Returns a new Array containing all elements of Iterable `a` followed by\nall elements of Iterable `b`.\n\nIf `a` or `b` are null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "Reflect": {
    "doc": "The Reflect API is a way to manipulate values dynamically through an\nabstract interface in an untyped manner. Use with care.\n\n@see https://haxe.org/manual/std-reflection.html\n",
    "path": "haxe\\std\\Reflect.hx",
    "functions": {
      "field": "Returns the value of the field named `field` on object `o`.\n\nIf `o` is not an object or has no field named `field`, the result is\nnull.\n\nIf the field is defined as a property, its accessors are ignored. Refer\nto `Reflect.getProperty` for a function supporting property accessors.\n\nIf `field` is null, the result is unspecified.\n",
      "setField": "Sets the field named `field` of object `o` to value `value`.\n\nIf `o` has no field named `field`, this function is only guaranteed to\nwork for anonymous structures.\n\nIf `o` or `field` are null, the result is unspecified.\n",
      "getProperty": "Returns the value of the field named `field` on object `o`, taking\nproperty getter functions into account.\n\nIf the field is not a property, this function behaves like\n`Reflect.field`, but might be slower.\n\nIf `o` or `field` are null, the result is unspecified.\n",
      "setProperty": "Sets the field named `field` of object `o` to value `value`, taking\nproperty setter functions into account.\n\nIf the field is not a property, this function behaves like\n`Reflect.setField`, but might be slower.\n\nIf `field` is null, the result is unspecified.\n",
      "callMethod": "Call a method `func` with the given arguments `args`.\n\nThe object `o` is ignored in most cases. It serves as the `this`-context in the following\nsituations:\n\n(neko) Allows switching the context to `o` in all cases.\n(macro) Same as neko for Haxe 3. No context switching in Haxe 4.\n(js, lua) Require the `o` argument if `func` does not, but should have a context.\nThis can occur by accessing a function field natively, e.g. through `Reflect.field`\nor by using `(object : Dynamic).field`. However, if `func` has a context, `o` is\nignored like on other targets.\n",
      "fields": "Returns the fields of structure `o`.\n\nThis method is only guaranteed to work on anonymous structures. Refer to\n`Type.getInstanceFields` for a function supporting class instances.\n\nIf `o` is null, the result is unspecified.\n",
      "isFunction": "Returns true if `f` is a function, false otherwise.\n\nIf `f` is null, the result is false.\n",
      "compare": "Compares `a` and `b`.\n\nIf `a` is less than `b`, the result is negative. If `b` is less than\n`a`, the result is positive. If `a` and `b` are equal, the result is 0.\n\nThis function is only defined if `a` and `b` are of the same type.\n\nIf that type is a function, the result is unspecified and\n`Reflect.compareMethods` should be used instead.\n\nFor all other types, the result is 0 if `a` and `b` are equal. If they\nare not equal, the result depends on the type and is negative if:\n\n- Numeric types: a is less than b\n- String: a is lexicographically less than b\n- Other: unspecified\n\nIf `a` and `b` are null, the result is 0. If only one of them is null,\nthe result is unspecified.\n",
      "compareMethods": "Compares the functions `f1` and `f2`.\n\nIf `f1` or `f2` are null, the result is false.\nIf `f1` or `f2` are not functions, the result is unspecified.\n\nOtherwise the result is true if `f1` and the `f2` are physically equal,\nfalse otherwise.\n\nIf `f1` or `f2` are member method closures, the result is true if they\nare closures of the same method on the same object value, false otherwise.\n",
      "isObject": "Tells if `v` is an object.\n\nThe result is true if `v` is one of the following:\n\n- class instance\n- structure\n- `Class<T>`\n- `Enum<T>`\n\nOtherwise, including if `v` is null, the result is false.\n",
      "isEnumValue": "Tells if `v` is an enum value.\n\nThe result is true if `v` is of type EnumValue, i.e. an enum\nconstructor.\n\nOtherwise, including if `v` is null, the result is false.\n",
      "deleteField": "Removes the field named `field` from structure `o`.\n\nThis method is only guaranteed to work on anonymous structures.\n\nIf `o` or `field` are null, the result is unspecified.\n",
      "copy": "Copies the fields of structure `o`.\n\nThis is only guaranteed to work on anonymous structures.\n\nIf `o` is null, the result is `null`.\n",
      "makeVarArgs": "Transform a function taking an array of arguments into a function that can\nbe called with any number of arguments.\n"
    },
    "fields": {}
  },
  "Std": {
    "doc": "The Std class provides standard methods for manipulating basic types.\n",
    "path": "haxe\\std\\Std.hx",
    "functions": {
      "isOfType": "Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.\n\nIf `t` is a class or interface with `@:generic` meta, the result is `false`.\n",
      "downcast": "Checks if object `value` is an instance of class or interface `c`.\n\nCompiles only if the type specified by `c` can be assigned to the type\nof `value`.\n\nThis method checks if a downcast is possible. That is, if the runtime\ntype of `value` is assignable to the type specified by `c`, `value` is\nreturned. Otherwise null is returned.\n\nThis method is not guaranteed to work with core types such as `String`,\n`Array` and `Date`.\n\nIf `value` is null, the result is null. If `c` is null, the result is\nunspecified.\n",
      "string": "Converts any value to a String.\n\nIf `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.\n\nIf `s` is an instance of a class and that class or one of its parent classes has\na `toString` method, that method is called. If no such method is present, the result\nis unspecified.\n\nIf `s` is an enum constructor without argument, the constructor's name is returned. If\narguments exists, the constructor's name followed by the String representations of\nthe arguments is returned.\n\nIf `s` is a structure, the field names along with their values are returned. The field order\nand the operator separating field names and values are unspecified.\n\nIf s is null, \"null\" is returned.\n",
      "int": "Converts a `Float` to an `Int`, rounded towards 0.\n\nIf `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.\n",
      "parseInt": "Converts a `String` to an `Int`.\n\nLeading whitespaces are ignored.\n\n`x` may optionally start with a + or - to denote a positive or negative value respectively.\n\nIf the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following\ndigits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.\n\nOtherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary\nnotations are not supported.\n\nParsing continues until an invalid character is detected, in which case the result up to\nthat point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.\n\nIf `x` is `null`, the result is `null`.\nIf `x` cannot be parsed as integer or is empty, the result is `null`.\n\nIf `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal\ndigit, the result is unspecified.\n",
      "parseFloat": "Converts a `String` to a `Float`.\n\nThe parsing rules for `parseInt` apply here as well, with the exception of invalid input\nresulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.\n\nAdditionally, decimal notation may contain a single `.` to denote the start of the fractions.\n\nIt may also end with `e` or `E` followed by optional minus or plus sign and a sequence of\ndigits (defines exponent to base 10).\n",
      "random": "Return a random integer between 0 included and `x` excluded.\n\nIf `x <= 1`, the result is always 0.\n"
    },
    "fields": {}
  },
  "ArrayAccess": {
    "doc": "The standard `Void` type. Only `null` values can be of the type `Void`.\n\n@see https://haxe.org/manual/types-void.html\n*/\n#if jvm\n@:runtimeValue\n#end\n@:coreType abstract Void {}\n\n/**\nThe standard `Float` type, this is a double-precision IEEE 64bit float.\n\nOn static targets, `null` cannot be assigned to Float. If this is necessary,\n`Null<Float>` can be used instead.\n\n`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n`Std.parseFloat` converts a `String` to a `Float`.\n\n@see https://haxe.org/manual/types-basic-types.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0.0)\n@:coreType @:notNull @:runtimeValue abstract Float {}\n\n/**\nThe standard `Int` type. Its precision depends on the platform.\n\nOn static targets, `null` cannot be assigned to `Int`. If this is necessary,\n`Null<Int>` can be used instead.\n\n`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n`Std.parseInt` converts a `String` to an `Int`.\n\n@see https://haxe.org/manual/types-basic-types.html\n@see https://haxe.org/manual/std-math-integer-math.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(0)\n@:coreType @:notNull @:runtimeValue abstract Int to Float {}\n\n#if (java || hl || cpp)\n/**\nSingle-precision IEEE 32bit float (4-byte).\n*/\n@:coreType @:notNull @:runtimeValue abstract Single to Float from Float {}\n#end\n\n/**\n`Null<T>` is a wrapper that can be used to make the basic types `Int`,\n`Float` and `Bool` nullable on static targets.\n\nIf null safety is enabled, only types wrapped in `Null<T>` are nullable.\n\nOtherwise, it has no effect on non-basic-types, but it can be useful as a way to document\nthat `null` is an acceptable value for a method argument, return value or variable.\n\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:forward\n@:coreType\nabstract Null<T> from T to T {}\n\n/**\nThe standard Boolean type, which can either be `true` or `false`.\n\nOn static targets, `null` cannot be assigned to `Bool`. If this is necessary,\n`Null<Bool>` can be used instead.\n\n@see https://haxe.org/manual/types-bool.html\n@see https://haxe.org/manual/types-nullability.html\n*/\n@:defaultValue(false)\n@:coreType @:notNull @:runtimeValue abstract Bool {}\n\n/**\n`Dynamic` is a special type which is compatible with all other types.\n\nUse of `Dynamic` should be minimized as it prevents several compiler\nchecks and optimizations. See `Any` type for a safer alternative for\nrepresenting values of any type.\n\n@see https://haxe.org/manual/types-dynamic.html\n*/\n@:coreType @:runtimeValue abstract Dynamic<T> {}\n\n/**\nAn `Iterator` is a structure that permits iteration over elements of type `T`.\n\nAny class with matching `hasNext()` and `next()` fields is considered an `Iterator`\nand can then be used e.g. in `for`-loops. This makes it easy to implement\ncustom iterators.\n\n@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterator<T> = {\n/**\nReturns `false` if the iteration is complete, `true` otherwise.\n\nUsually iteration is considered to be complete if all elements of the\nunderlying data structure were handled through calls to `next()`. However,\nin custom iterators any logic may be used to determine the completion\nstate.\n*/\nfunction hasNext():Bool;\n\n/**\nReturns the current item of the `Iterator` and advances to the next one.\n\nThis method is not required to check `hasNext()` first. A call to this\nmethod while `hasNext()` is `false` yields unspecified behavior.\n\nOn the other hand, iterators should not require a call to `hasNext()`\nbefore the first call to `next()` if an element is available.\n*/\nfunction next():T;\n}\n\n/**\nAn `Iterable` is a data structure which has an `iterator()` method.\nSee `Lambda` for generic functions on iterable structures.\n\n@see https://haxe.org/manual/lf-iterators.html\n*/\ntypedef Iterable<T> = {\nfunction iterator():Iterator<T>;\n}\n\n/**\nA `KeyValueIterator` is an `Iterator` that has a key and a value.\n*/\ntypedef KeyValueIterator<K, V> = Iterator<{key:K, value:V}>;\n\n/**\nA `KeyValueIterable` is a data structure which has a `keyValueIterator()`\nmethod to iterate over key-value-pairs.\n*/\ntypedef KeyValueIterable<K, V> = {\nfunction keyValueIterator():KeyValueIterator<K, V>;\n}\n\n/**\n`ArrayAccess` is used to indicate a class that can be accessed using brackets.\nThe type parameter represents the type of the elements stored.\n\nThis interface should be used for externs only. Haxe does not support custom\narray access on classes. However, array access can be implemented for\nabstract types.\n\n@see https://haxe.org/manual/types-abstract-array-access.html\n",
    "path": "haxe\\std\\StdTypes.hx",
    "functions": {
      "next": "Returns the current item of the `Iterator` and advances to the next one.\n\nThis method is not required to check `hasNext()` first. A call to this\nmethod while `hasNext()` is `false` yields unspecified behavior.\n\nOn the other hand, iterators should not require a call to `hasNext()`\nbefore the first call to `next()` if an element is available.\n"
    },
    "fields": {}
  },
  "String": {
    "doc": "The basic String class.\n\nA Haxe String is immutable, it is not possible to modify individual\ncharacters. No method of this class changes the state of `this` String.\n\nStrings can be constructed using the String literal syntax `\"string value\"`.\n\nString can be concatenated by using the `+` operator. If an operand is not a\nString, it is passed through `Std.string()` first.\n\n@see https://haxe.org/manual/std-String.html\n",
    "path": "haxe\\std\\String.hx",
    "functions": {
      "toUpperCase": "Returns a String where all characters of `this` String are upper case.\n",
      "toLowerCase": "Returns a String where all characters of `this` String are lower case.\n",
      "charAt": "Returns the character at position `index` of `this` String.\n\nIf `index` is negative or exceeds `this.length`, the empty String `\"\"`\nis returned.\n",
      "charCodeAt": "Returns the character code at position `index` of `this` String.\n\nIf `index` is negative or exceeds `this.length`, `null` is returned.\n\nTo obtain the character code of a single character, `\"x\".code` can be\nused instead to inline the character code at compile time. Note that\nthis only works on String literals of length 1.\n",
      "indexOf": "Returns the position of the leftmost occurrence of `str` within `this` String.\n\nIf `str` is the empty String `\"\"`, then:\nIf `startIndex` is not specified or < 0, 0 is returned.\nIf `startIndex >= this.length`, `this.length` is returned.\nOtherwise, `startIndex` is returned,\n\nOtherwise, if `startIndex` is not specified or < 0, it is treated as 0.\n\nIf `startIndex >= this.length`, -1 is returned.\n\nOtherwise the search is performed within the substring of `this` String starting\nat `startIndex`. If `str` is found, the position of its first character in `this`\nString relative to position 0 is returned.\n\nIf `str` cannot be found, -1 is returned.\n",
      "lastIndexOf": "Returns the position of the rightmost occurrence of `str` within `this`\nString.\n\nIf `startIndex` is given, the search is performed within the substring\nof `this` String from 0 to `startIndex + str.length`. Otherwise the search\nis performed within `this` String. In either case, the returned position\nis relative to the beginning of `this` String.\n\nIf `startIndex` is negative, the result is unspecified.\n\nIf `str` cannot be found, -1 is returned.\n",
      "split": "Splits `this` String at each occurrence of `delimiter`.\n\nIf `this` String is the empty String `\"\"`, the result is not consistent\nacross targets and may either be `[]` (on Js, Cpp) or `[\"\"]`.\n\nIf `delimiter` is the empty String `\"\"`, `this` String is split into an\nArray of `this.length` elements, where the elements correspond to the\ncharacters of `this` String.\n\nIf `delimiter` is not found within `this` String, the result is an Array\nwith one element, which equals `this` String.\n\nIf `delimiter` is null, the result is unspecified.\n\nOtherwise, `this` String is split into parts at each occurrence of\n`delimiter`. If `this` String starts (or ends) with `delimiter`, the\nresult `Array` contains a leading (or trailing) empty String `\"\"` element.\nTwo subsequent delimiters also result in an empty String `\"\"` element.\n",
      "substr": "Returns `len` characters of `this` String, starting at position `pos`.\n\nIf `len` is omitted, all characters from position `pos` to the end of\n`this` String are included.\n\nIf `pos` is negative, its value is calculated from the end of `this`\nString by `this.length + pos`. If this yields a negative value, 0 is\nused instead.\n\nIf the calculated position + `len` exceeds `this.length`, the characters\nfrom that position to the end of `this` String are returned.\n\nIf `len` is negative, the result is unspecified.\n",
      "substring": "Returns the part of `this` String from `startIndex` to but not including `endIndex`.\n\nIf `startIndex` or `endIndex` are negative, 0 is used instead.\n\nIf `startIndex` exceeds `endIndex`, they are swapped.\n\nIf the (possibly swapped) `endIndex` is omitted or exceeds\n`this.length`, `this.length` is used instead.\n\nIf the (possibly swapped) `startIndex` exceeds `this.length`, the empty\nString `\"\"` is returned.\n",
      "toString": "Returns the String itself.\n"
    },
    "fields": {}
  },
  "StringBuf": {
    "doc": "A String buffer is an efficient way to build a big string by appending small\nelements together.\n\nUnlike String, an instance of StringBuf is not immutable in the sense that\nit can be passed as argument to functions which modify it by appending more\nvalues.\n",
    "path": "haxe\\std\\StringBuf.hx",
    "functions": {
      "add": "Appends the representation of `x` to `this` StringBuf.\n\nThe exact representation of `x` may vary per platform. To get more\nconsistent behavior, this function should be called with\nStd.string(x).\n\nIf `x` is null, the String \"null\" is appended.\n",
      "addChar": "Appends the character identified by `c` to `this` StringBuf.\n\nIf `c` is negative or has another invalid value, the result is\nunspecified.\n",
      "addSub": "Appends a substring of `s` to `this` StringBuf.\n\nThis function expects `pos` and `len` to describe a valid substring of\n`s`, or else the result is unspecified. To get more robust behavior,\n`this.add(s.substr(pos,len))` can be used instead.\n\nIf `s` or `pos` are null, the result is unspecified.\n\nIf `len` is omitted or null, the substring ranges from `pos` to the end\nof `s`.\n",
      "clear": "Removes all characters from `this` StringBuf, making it possible to reuse it.\n",
      "toString": "Returns the content of `this` StringBuf as String.\n\nThe buffer is not emptied by this operation.\n"
    },
    "fields": {}
  },
  "StringTools": {
    "doc": "This class provides advanced methods on Strings. It is ideally used with\n`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\nto the `String` class.\n\nIf the first argument to any of the methods is null, the result is\nunspecified.\n",
    "path": "haxe\\std\\StringTools.hx",
    "functions": {
      "htmlUnescape": "Unescapes HTML special characters of the string `s`.\n\nThis is the inverse operation to htmlEscape, i.e. the following always\nholds: `htmlUnescape(htmlEscape(s)) == s`\n\nThe replacements follow:\n\n- `&amp;` becomes `&`\n- `&lt;` becomes `<`\n- `&gt;` becomes `>`\n- `&quot;` becomes `\"`\n- `&#039;` becomes `'`\n",
      "contains": "Returns `true` if `s` contains `value` and  `false` otherwise.\n\nWhen `value` is `null`, the result is unspecified.\n",
      "isSpace": "Tells if the string `s` starts with the string `start`.\n\nIf `start` is `null`, the result is unspecified.\n\nIf `start` is the empty String `\"\"`, the result is true.\n*/\npublic static #if (java || python || (js && js_es >= 6)) inline #end function startsWith(s:String, start:String):Bool {\n#if java\nreturn (cast s : java.NativeString).startsWith(start);\n#elseif hl\nreturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n#elseif python\nreturn python.NativeStringTools.startswith(s, start);\n#elseif (js && js_es >= 6)\nreturn (cast s).startsWith(start);\n#elseif lua\nreturn untyped __lua__(\"{0}:sub(1, #{1}) == {1}\", s, start);\n#else\nreturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n#end\n}\n\n/**\nTells if the string `s` ends with the string `end`.\n\nIf `end` is `null`, the result is unspecified.\n\nIf `end` is the empty String `\"\"`, the result is true.\n*/\npublic static #if (java || python || (js && js_es >= 6)) inline #end function endsWith(s:String, end:String):Bool {\n#if java\nreturn (cast s : java.NativeString).endsWith(end);\n#elseif hl\nvar elen = end.length;\nvar slen = s.length;\nreturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n#elseif python\nreturn python.NativeStringTools.endswith(s, end);\n#elseif (js && js_es >= 6)\nreturn (cast s).endsWith(end);\n#elseif lua\nreturn end == \"\" || untyped __lua__(\"{0}:sub(-#{1}) == {1}\", s, end);\n#else\nvar elen = end.length;\nvar slen = s.length;\nreturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n#end\n}\n\n/**\nTells if the character in the string `s` at position `pos` is a space.\n\nA character is considered to be a space character if its character code\nis 9,10,11,12,13 or 32.\n\nIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n`s`, the result is false.\n",
      "ltrim": "Removes leading space characters of `s`.\n\nThis function internally calls `isSpace()` to decide which characters to\nremove.\n\nIf `s` is the empty String `\"\"` or consists only of space characters, the\nresult is the empty String `\"\"`.\n",
      "rtrim": "Removes trailing space characters of `s`.\n\nThis function internally calls `isSpace()` to decide which characters to\nremove.\n\nIf `s` is the empty String `\"\"` or consists only of space characters, the\nresult is the empty String `\"\"`.\n",
      "lpad": "Removes leading and trailing space characters of `s`.\n\nThis is a convenience function for `ltrim(rtrim(s))`.\n*/\npublic #if java inline #end static function trim(s:String):String {\n#if java\nreturn (cast s : java.NativeString).trim();\n#else\nreturn ltrim(rtrim(s));\n#end\n}\n\n/**\nConcatenates `c` to `s` until `s.length` is at least `l`.\n\nIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n`s` is returned unchanged.\n\nIf `c.length` is 1, the resulting String length is exactly `l`.\n\nOtherwise the length may exceed `l`.\n\nIf `c` is null, the result is unspecified.\n",
      "rpad": "Appends `c` to `s` until `s.length` is at least `l`.\n\nIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n`s` is returned unchanged.\n\nIf `c.length` is 1, the resulting String length is exactly `l`.\n\nOtherwise the length may exceed `l`.\n\nIf `c` is null, the result is unspecified.\n",
      "replace": "Replace all occurrences of the String `sub` in the String `s` by the\nString `by`.\n\nIf `sub` is the empty String `\"\"`, `by` is inserted after each character\nof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\nremains unchanged.\n\nIf `sub` or `by` are null, the result is unspecified.\n",
      "hex": "Encodes `n` into a hexadecimal representation.\n\nIf `digits` is specified, the resulting String is padded with \"0\" until\nits `length` equals `digits`.\n",
      "iterator": "Returns the character code at position `index` of String `s`, or an\nend-of-file indicator at if `position` equals `s.length`.\n\nThis method is faster than `String.charCodeAt()` on some platforms, but\nthe result is unspecified if `index` is negative or greater than\n`s.length`.\n\nEnd of file status can be checked by calling `StringTools.isEof()` with\nthe returned value as argument.\n\nThis operation is not guaranteed to work if `s` contains the `\\0`\ncharacter.\n*/\npublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n#if neko\nreturn untyped __dollar__sget(s.__s, index);\n#elseif cpp\nreturn untyped s.cca(index);\n#elseif flash\nreturn untyped s.cca(index);\n#elseif java\nreturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n#elseif js\nreturn js.lib.NativeStringTools.charCodeAt(s, index);\n#elseif python\nreturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n#elseif hl\nreturn @:privateAccess s.bytes.getUI16(index << 1);\n#elseif lua\n#if lua_vanilla\nreturn lua.NativeStringTools.byte(s, index + 1);\n#else\nreturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n#end\n#else\nreturn untyped s.cca(index);\n#end\n}\n\n/**\nReturns the character code at position `index` of String `s`, or an\nend-of-file indicator at if `position` equals `s.length`.\n\nThis method is faster than `String.charCodeAt()` on some platforms, but\nthe result is unspecified if `index` is negative or greater than\n`s.length`.\n\nThis operation is not guaranteed to work if `s` contains the `\\0`\ncharacter.\n*/\npublic static #if !eval inline #end function unsafeCodeAt(s:String, index:Int):Int {\n#if neko\nreturn untyped __dollar__sget(s.__s, index);\n#elseif cpp\nreturn untyped s.cca(index);\n#elseif flash\nreturn untyped s.cca(index);\n#elseif java\nreturn cast(_charAt(s, index), Int);\n#elseif js\nreturn js.lib.NativeStringTools.charCodeAt(s, index);\n#elseif python\nreturn python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n#elseif hl\nreturn @:privateAccess s.bytes.getUI16(index << 1);\n#elseif lua\n#if lua_vanilla\nreturn lua.NativeStringTools.byte(s, index + 1);\n#else\nreturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n#end\n#else\nreturn untyped s.cca(index);\n#end\n}\n\n/**\nReturns an iterator of the char codes.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different runtimes.\nFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\n",
      "keyValueIterator": "Returns an iterator of the char indexes and codes.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different of runtimes.\nFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\n",
      "quoteUnixArg": "Tells if `c` represents the end-of-file (EOF) character.\n*/\n@:noUsing public static inline function isEof(c:Int):Bool {\n#if (flash || cpp || hl)\nreturn c == 0;\n#elseif js\nreturn c != c; // fast NaN\n#elseif (neko || lua || eval)\nreturn c == null;\n#elseif (java || python)\nreturn c == -1;\n#else\nreturn false;\n#end\n}\n\n/**\nReturns a String that can be used as a single command line argument\non Unix.\nThe input will be quoted, or escaped if necessary.\n",
      "quoteWinArg": "Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n*/\n@:noCompletion\n@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\npublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n/**\nReturns a String that can be used as a single command line argument\non Windows.\nThe input will be quoted, or escaped if necessary, such that the output\nwill be parsed as a single argument using the rule specified in\nhttp://msdn.microsoft.com/en-us/library/ms880421\n\nExamples:\n```haxe\nquoteWinArg(\"abc\") == \"abc\";\nquoteWinArg(\"ab c\") == '\"ab c\"';\n```\n"
    },
    "fields": {}
  },
  "Type": {
    "doc": "The Haxe Reflection API allows retrieval of type information at runtime.\n\nThis class complements the more lightweight Reflect class, with a focus on\nclass and enum instances.\n\n@see https://haxe.org/manual/types.html\n@see https://haxe.org/manual/std-reflection.html\n",
    "path": "haxe\\std\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "ValueType": {
    "doc": "Returns the class of `o`, if `o` is a class instance.\n\nIf `o` is null or of a different type, null is returned.\n\nIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getClass<T>(o:T):Null<Class<T>>;\n\n/**\nReturns the enum of enum instance `o`.\n\nAn enum instance is the result of using an enum constructor. Given an\n`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\nIf `o` is null, null is returned.\n\nIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getEnum(o:EnumValue):Null<Enum<Dynamic>>;\n\n/**\nReturns the super-class of class `c`.\n\nIf `c` has no super class, null is returned.\n\nIf `c` is null, the result is unspecified.\n\nIn general, type parameter information cannot be obtained at runtime.\n*/\nstatic function getSuperClass(c:Class<Dynamic>):Null<Class<Dynamic>>;\n\n/**\nReturns the name of class `c`, including its path.\n\nIf `c` is inside a package, the package structure is returned dot-\nseparated, with another dot separating the class name:\n`pack1.pack2.(...).packN.ClassName`\nIf `c` is a sub-type of a Haxe module, that module is not part of the\npackage structure.\n\nIf `c` has no package, the class name is returned.\n\nIf `c` is null, the result is unspecified.\n\nThe class name does not include any type parameters.\n*/\nstatic function getClassName(c:Class<Dynamic>):String;\n\n/**\nReturns the name of enum `e`, including its path.\n\nIf `e` is inside a package, the package structure is returned dot-\nseparated, with another dot separating the enum name:\n`pack1.pack2.(...).packN.EnumName`\nIf `e` is a sub-type of a Haxe module, that module is not part of the\npackage structure.\n\nIf `e` has no package, the enum name is returned.\n\nIf `e` is null, the result is unspecified.\n\nThe enum name does not include any type parameters.\n*/\nstatic function getEnumName(e:Enum<Dynamic>):String;\n\n/**\nResolves a class by name.\n\nIf `name` is the path of an existing class, that class is returned.\n\nOtherwise null is returned.\n\nIf `name` is null or the path to a different type, the result is\nunspecified.\n\nThe class name must not include any type parameters.\n*/\nstatic function resolveClass(name:String):Null<Class<Dynamic>>;\n\n/**\nResolves an enum by name.\n\nIf `name` is the path of an existing enum, that enum is returned.\n\nOtherwise null is returned.\n\nIf `name` is null the result is unspecified.\n\nIf `name` is the path to a different type, null is returned.\n\nThe enum name must not include any type parameters.\n*/\nstatic function resolveEnum(name:String):Null<Enum<Dynamic>>;\n\n/**\nCreates an instance of class `cl`, using `args` as arguments to the\nclass constructor.\n\nThis function guarantees that the class constructor is called.\n\nDefault values of constructors arguments are not guaranteed to be\ntaken into account.\n\nIf `cl` or `args` are null, or if the number of elements in `args` does\nnot match the expected number of constructor arguments, or if any\nargument has an invalid type,  or if `cl` has no own constructor, the\nresult is unspecified.\n\nIn particular, default values of constructor arguments are not\nguaranteed to be taken into account.\n*/\nstatic function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T;\n\n/**\nCreates an instance of class `cl`.\n\nThis function guarantees that the class constructor is not called.\n\nIf `cl` is null, the result is unspecified.\n*/\nstatic function createEmptyInstance<T>(cl:Class<T>):T;\n\n/**\nCreates an instance of enum `e` by calling its constructor `constr` with\narguments `params`.\n\nIf `e` or `constr` is null, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n*/\nstatic function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T;\n\n/**\nCreates an instance of enum `e` by calling its constructor number\n`index` with arguments `params`.\n\nThe constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc.\n\nIf `e` or `constr` is null, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n*/\nstatic function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T;\n\n/**\nReturns a list of the instance fields of class `c`, including\ninherited fields.\n\nThis only includes fields which are known at compile-time. In\nparticular, using `getInstanceFields(getClass(obj))` will not include\nany fields which were added to `obj` at runtime.\n\nThe order of the fields in the returned Array is unspecified.\n\nIf `c` is null, the result is unspecified.\n*/\nstatic function getInstanceFields(c:Class<Dynamic>):Array<String>;\n\n/**\nReturns a list of static fields of class `c`.\n\nThis does not include static fields of parent classes.\n\nThe order of the fields in the returned Array is unspecified.\n\nIf `c` is null, the result is unspecified.\n*/\nstatic function getClassFields(c:Class<Dynamic>):Array<String>;\n\n/**\nReturns a list of the names of all constructors of enum `e`.\n\nThe order of the constructor names in the returned Array is preserved\nfrom the original syntax.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic function getEnumConstructs(e:Enum<Dynamic>):Array<String>;\n\n/**\nReturns the runtime type of value `v`.\n\nThe result corresponds to the type `v` has at runtime, which may vary\nper platform. Assumptions regarding this should be minimized to avoid\nsurprises.\n*/\nstatic function typeof(v:Dynamic):ValueType;\n\n/**\nRecursively compares two enum instances `a` and `b` by value.\n\nUnlike `a == b`, this function performs a deep equality check on the\narguments of the constructors, if exists.\n\nIf `a` or `b` are null, the result is unspecified.\n*/\nstatic function enumEq<T:EnumValue>(a:T, b:T):Bool;\n\n/**\nReturns the constructor name of enum instance `e`.\n\nThe result String does not contain any constructor arguments.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic function enumConstructor(e:EnumValue):String;\n\n/**\nReturns a list of the constructor arguments of enum instance `e`.\n\nIf `e` has no arguments, the result is [].\n\nOtherwise the result are the values that were used as arguments to `e`,\nin the order of their declaration.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic function enumParameters(e:EnumValue):Array<Dynamic>;\n\n/**\nReturns the index of enum instance `e`.\n\nThis corresponds to the original syntactic position of `e`. The index of\nthe first declared constructor is 0, the next one is 1 etc.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic function enumIndex(e:EnumValue):Int;\n\n/**\nReturns a list of all constructors of enum `e` that require no\narguments.\n\nThis may return the empty Array `[]` if all constructors of `e` require\narguments.\n\nOtherwise an instance of `e` constructed through each of its non-\nargument constructors is returned, in the order of the constructor\ndeclaration.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic function allEnums<T>(e:Enum<T>):Array<T>;\n}\n\n/**\nThe different possible runtime types of a value.\n",
    "path": "haxe\\std\\Type.hx",
    "functions": {
      "getEnum": "Returns the enum of enum instance `o`.\n\nAn enum instance is the result of using an enum constructor. Given an\n`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.\n\nIf `o` is null, null is returned.\n\nIn general, type parameter information cannot be obtained at runtime.\n",
      "getSuperClass": "Returns the super-class of class `c`.\n\nIf `c` has no super class, null is returned.\n\nIf `c` is null, the result is unspecified.\n\nIn general, type parameter information cannot be obtained at runtime.\n",
      "getClassName": "Returns the name of class `c`, including its path.\n\nIf `c` is inside a package, the package structure is returned dot-\nseparated, with another dot separating the class name:\n`pack1.pack2.(...).packN.ClassName`\nIf `c` is a sub-type of a Haxe module, that module is not part of the\npackage structure.\n\nIf `c` has no package, the class name is returned.\n\nIf `c` is null, the result is unspecified.\n\nThe class name does not include any type parameters.\n",
      "getEnumName": "Returns the name of enum `e`, including its path.\n\nIf `e` is inside a package, the package structure is returned dot-\nseparated, with another dot separating the enum name:\n`pack1.pack2.(...).packN.EnumName`\nIf `e` is a sub-type of a Haxe module, that module is not part of the\npackage structure.\n\nIf `e` has no package, the enum name is returned.\n\nIf `e` is null, the result is unspecified.\n\nThe enum name does not include any type parameters.\n",
      "resolveClass": "Resolves a class by name.\n\nIf `name` is the path of an existing class, that class is returned.\n\nOtherwise null is returned.\n\nIf `name` is null or the path to a different type, the result is\nunspecified.\n\nThe class name must not include any type parameters.\n",
      "resolveEnum": "Resolves an enum by name.\n\nIf `name` is the path of an existing enum, that enum is returned.\n\nOtherwise null is returned.\n\nIf `name` is null the result is unspecified.\n\nIf `name` is the path to a different type, null is returned.\n\nThe enum name must not include any type parameters.\n",
      "createInstance": "Creates an instance of class `cl`, using `args` as arguments to the\nclass constructor.\n\nThis function guarantees that the class constructor is called.\n\nDefault values of constructors arguments are not guaranteed to be\ntaken into account.\n\nIf `cl` or `args` are null, or if the number of elements in `args` does\nnot match the expected number of constructor arguments, or if any\nargument has an invalid type,  or if `cl` has no own constructor, the\nresult is unspecified.\n\nIn particular, default values of constructor arguments are not\nguaranteed to be taken into account.\n",
      "createEmptyInstance": "Creates an instance of class `cl`.\n\nThis function guarantees that the class constructor is not called.\n\nIf `cl` is null, the result is unspecified.\n",
      "createEnum": "Creates an instance of enum `e` by calling its constructor `constr` with\narguments `params`.\n\nIf `e` or `constr` is null, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n",
      "createEnumIndex": "Creates an instance of enum `e` by calling its constructor number\n`index` with arguments `params`.\n\nThe constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc.\n\nIf `e` or `constr` is null, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n",
      "getInstanceFields": "Returns a list of the instance fields of class `c`, including\ninherited fields.\n\nThis only includes fields which are known at compile-time. In\nparticular, using `getInstanceFields(getClass(obj))` will not include\nany fields which were added to `obj` at runtime.\n\nThe order of the fields in the returned Array is unspecified.\n\nIf `c` is null, the result is unspecified.\n",
      "getClassFields": "Returns a list of static fields of class `c`.\n\nThis does not include static fields of parent classes.\n\nThe order of the fields in the returned Array is unspecified.\n\nIf `c` is null, the result is unspecified.\n",
      "getEnumConstructs": "Returns a list of the names of all constructors of enum `e`.\n\nThe order of the constructor names in the returned Array is preserved\nfrom the original syntax.\n\nIf `e` is null, the result is unspecified.\n",
      "typeof": "Returns the runtime type of value `v`.\n\nThe result corresponds to the type `v` has at runtime, which may vary\nper platform. Assumptions regarding this should be minimized to avoid\nsurprises.\n",
      "enumEq": "Recursively compares two enum instances `a` and `b` by value.\n\nUnlike `a == b`, this function performs a deep equality check on the\narguments of the constructors, if exists.\n\nIf `a` or `b` are null, the result is unspecified.\n",
      "enumConstructor": "Returns the constructor name of enum instance `e`.\n\nThe result String does not contain any constructor arguments.\n\nIf `e` is null, the result is unspecified.\n",
      "enumParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\nIf `e` has no arguments, the result is [].\n\nOtherwise the result are the values that were used as arguments to `e`,\nin the order of their declaration.\n\nIf `e` is null, the result is unspecified.\n",
      "enumIndex": "Returns the index of enum instance `e`.\n\nThis corresponds to the original syntactic position of `e`. The index of\nthe first declared constructor is 0, the next one is 1 etc.\n\nIf `e` is null, the result is unspecified.\n",
      "allEnums": "Returns a list of all constructors of enum `e` that require no\narguments.\n\nThis may return the empty Array `[]` if all constructors of `e` require\narguments.\n\nOtherwise an instance of `e` constructed through each of its non-\nargument constructors is returned, in the order of the constructor\ndeclaration.\n\nIf `e` is null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "abstract": {
    "doc": "Xml node types.\n\n@see https://haxe.org/manual/std-Xml.html\n",
    "path": "haxe\\std\\Xml.hx",
    "functions": {},
    "fields": {}
  },
  "Xml": {
    "doc": "Represents an XML element type.\n*/\nvar Element = 0;\n\n/**\nRepresents XML parsed character data type.\n*/\nvar PCData = 1;\n\n/**\nRepresents XML character data type.\n*/\nvar CData = 2;\n\n/**\nRepresents an XML comment type.\n*/\nvar Comment = 3;\n\n/**\nRepresents an XML doctype element type.\n*/\nvar DocType = 4;\n\n/**\nRepresents an XML processing instruction type.\n*/\nvar ProcessingInstruction = 5;\n\n/**\nRepresents an XML document type.\n*/\nvar Document = 6;\n\npublic function toString():String {\nreturn switch (cast this : XmlType) {\ncase Element: \"Element\";\ncase PCData: \"PCData\";\ncase CData: \"CData\";\ncase Comment: \"Comment\";\ncase DocType: \"DocType\";\ncase ProcessingInstruction: \"ProcessingInstruction\";\ncase Document: \"Document\";\n};\n}\n}\n\n/**\nCross-platform Xml API.\n\n@see https://haxe.org/manual/std-Xml.html\n",
    "path": "haxe\\std\\Xml.hx",
    "functions": {
      "createElement": "Returns the type of the Xml Node. This should be used before\naccessing other functions since some might raise an exception\nif the node type is not correct.\n*/\npublic var nodeType(default, null):XmlType;\n\n/**\nReturns the node name of an Element.\n*/\n@:isVar public var nodeName(get, set):String;\n\n/**\nReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n@:isVar public var nodeValue(get, set):String;\n\n/**\nReturns the parent object in the Xml hierarchy.\nThe parent can be `null`, an Element or a Document.\n*/\npublic var parent(default, null):Null<Xml>;\n\nvar children:Array<Xml>;\nvar attributeMap:Map<String, String>;\n\n#if !cppia inline #end function get_nodeName() {\nif (nodeType != Element) {\nthrow 'Bad node type, expected Element but found $nodeType';\n}\nreturn nodeName;\n}\n\n#if !cppia inline #end function set_nodeName(v) {\nif (nodeType != Element) {\nthrow 'Bad node type, expected Element but found $nodeType';\n}\nreturn this.nodeName = v;\n}\n\n#if !cppia inline #end function get_nodeValue() {\nif (nodeType == Document || nodeType == Element) {\nthrow 'Bad node type, unexpected $nodeType';\n}\nreturn nodeValue;\n}\n\n#if !cppia inline #end function set_nodeValue(v) {\nif (nodeType == Document || nodeType == Element) {\nthrow 'Bad node type, unexpected $nodeType';\n}\nreturn this.nodeValue = v;\n}\n\n/**\nCreates a node of the given type.\n",
      "createPCData": "Creates a node of the given type.\n",
      "createCData": "Creates a node of the given type.\n",
      "createComment": "Creates a node of the given type.\n",
      "createDocType": "Creates a node of the given type.\n",
      "createProcessingInstruction": "Creates a node of the given type.\n",
      "createDocument": "Creates a node of the given type.\n",
      "get": "Get the given attribute of an Element node. Returns `null` if not found.\nAttributes are case-sensitive.\n",
      "set": "Set the given attribute value for an Element node.\nAttributes are case-sensitive.\n",
      "remove": "Removes an attribute for an Element node.\nAttributes are case-sensitive.\n",
      "exists": "Tells if the Element node has a given attribute.\nAttributes are case-sensitive.\n",
      "attributes": "Returns an `Iterator` on all the attribute names.\n",
      "elements": "Returns an iterator of all child nodes.\nOnly works if the current node is an Element or a Document.\n*/\npublic #if !cppia inline #end function iterator():Iterator<Xml> {\nensureElementType();\nreturn children.iterator();\n}\n\n/**\nReturns an iterator of all child nodes which are Elements.\nOnly works if the current node is an Element or a Document.\n",
      "elementsNamed": "Returns an iterator of all child nodes which are Elements with the given nodeName.\nOnly works if the current node is an Element or a Document.\n",
      "firstElement": "Returns the first child node.\n*/\npublic #if !cppia inline #end function firstChild():Xml {\nensureElementType();\nreturn children[0];\n}\n\n/**\nReturns the first child node which is an Element.\n",
      "addChild": "Adds a child node to the Document or Element.\nA child node can only be inside one given parent node, which is indicated by the `parent` property.\nIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\nIf the child node was previously inside a different node, it will be moved to this Document or Element.\n",
      "removeChild": "Removes a child from the Document or Element.\nReturns true if the child was successfully removed.\n",
      "insertChild": "Inserts a child at the given position among the other childs.\nA child node can only be inside one given parent node, which is indicated by the [parent] property.\nIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\nIf the child node was previously inside a different node, it will be moved to this Document or Element.\n"
    },
    "fields": {
      "PCData": "XML parsed character data type.\n",
      "CData": "XML character data type.\n",
      "Comment": "XML comment type.\n",
      "DocType": "XML doctype element type.\n",
      "ProcessingInstruction": "XML processing instruction type.\n",
      "Document": "XML document type.\n",
      "Element": "Cross-platform Xml API.\n\n@see https://haxe.org/manual/std-Xml.html\n*/\nclass Xml {\n/**\nXML element type.\n",
      "nodeType": "Parses the String into an Xml document.\n*/\nstatic public function parse(str:String):Xml {\nreturn haxe.xml.Parser.parse(str);\n}\n\n/**\nReturns the type of the Xml Node. This should be used before\naccessing other functions since some might raise an exception\nif the node type is not correct.\n",
      "parent": "Returns the node name of an Element.\n*/\n@:isVar public var nodeName(get, set):String;\n\n/**\nReturns the node value. Only works if the Xml node is not an Element or a Document.\n*/\n@:isVar public var nodeValue(get, set):String;\n\n/**\nReturns the parent object in the Xml hierarchy.\nThe parent can be `null`, an Element or a Document.\n"
    }
  },
  "cpp.Finalizable": {
    "doc": "This is just a helper class. It is not actually required to inherit from this\nto use `NativeGc.addFinalizable(this,inPin)`, only a function called\n`finalize` is needed.\n",
    "path": "haxe\\std\\cpp\\Finalizable.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.Lib": {
    "doc": "Platform-specific Cpp Library. Provides some platform-specific functions\nfor the C++ target, such as conversion from Haxe types to native types\nand vice-versa.\n",
    "path": "haxe\\std\\cpp\\Lib.hx",
    "functions": {
      "unloadAllLibraries": "Unloaded all dynamic libraries in reverse order of loading.\nReturns the number of libraries unloaded.\n",
      "loadLazy": "Tries to load, and always returns a valid function, but the function may throw\nif called.\n",
      "bytesReference": "Returns bytes referencing the content of a string.\nUse with extreme caution - changing constant strings will crash.\nChanging one string can cause others to change unexpectedly.\nOnly really safe if you are using it read-only or if it comes from stringReference above\n",
      "print": "Print the specified value on the default output.\n",
      "haxeToNeko": "This function is used to make porting from neko to cpp easy.\nIt does not need to do anything because the c-code can work with any Dynamic\n",
      "nekoToHaxe": "This function is used to make porting from neko to cpp easy.\nIt does not need to do anything because the c-code can work with any Dynamic\n",
      "println": "Print the specified value on the default output followed by a newline character.\n"
    },
    "fields": {}
  },
  "cpp.net.Poll": {
    "doc": "A wrapper around native socket polling functionality for monitoring multiple sockets for I/O readiness.\nThis class provides a high-level abstraction over native `poll` operations, allowing you to monitor sockets for read and write events.",
    "path": "haxe\\std\\cpp\\net\\Poll.hx",
    "functions": {
      "prepare": "Prepares the poll structure for monitoring read and write events on the given sockets.\n\n@param read  An array of sockets to monitor for readability.\n@param write An array of sockets to monitor for writability.",
      "events": "Waits for events on the prepared sockets.\n\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.",
      "poll": "Polls the given sockets for any events (e.g., readability or writability).\n\n@param a An array of sockets to monitor for events.\n@param t The timeout in seconds. Use `-1.0` for an infinite wait. Defaults to `-1.0` if not specified.\n@return An array of sockets that are ready for I/O operations."
    },
    "fields": {
      "writeIndexes": "An array of indices corresponding to sockets ready for writing after polling."
    }
  },
  "cpp.net.ThreadServer": {
    "doc": "The ThreadServer can be used to easily create a multithreaded server where each thread polls multiple connections.\nTo use it, at a minimum you must override or rebind clientConnected, readClientMessage, and clientMessage and you must define your Client and Message.\n",
    "path": "haxe\\std\\cpp\\net\\ThreadServer.hx",
    "functions": {
      "work": "Internally used to delegate something to the worker thread.\n",
      "addSocket": "Called when the server gets a new connection.\n",
      "run": "Start the server at the specified host and port.\n",
      "sendData": "Send data to a client.\n",
      "stopClient": "Shutdown a client's connection and remove them from the server.\n"
    },
    "fields": {
      "nthreads": "Number of server threads.\n",
      "connectLag": "Polling timeout.\n",
      "errorOutput": "Stream to send error messages.\n",
      "initialBufferSize": "Space allocated to buffers when they are created.\n",
      "maxBufferSize": "Maximum size of buffered data read from a socket. An exception is thrown if the buffer exceeds this value.\n",
      "messageHeaderSize": "Minimum message size.\n",
      "updateTime": "Time between calls to update.\n",
      "maxSockPerThread": "The most sockets a thread will handle.\n"
    }
  },
  "cpp.rtti.FieldIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\nallows fast dynamic access to fields by integer id.  This should speed up the CFFI.\n",
    "path": "haxe\\std\\cpp\\rtti\\FieldIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.rtti.FieldNumericIntegerLookup": {
    "doc": "If you implement this interface, then the backend will generate code that\nallows fast numeric access to fields by integer id.  This should speed up the CFFI.\n",
    "path": "haxe\\std\\cpp\\rtti\\FieldNumericIntegerLookup.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Parameter": {
    "doc": "Parameter describes a function parameter. Instances of this class are\nembedded in stack frame objects to describe the function parameters that\nwere used in the invocation of the function that defines that stack frame.\n",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.StackFrame": {
    "doc": "`StackFrame` describes one call stack frame.\n",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.ThreadInfo": {
    "doc": "`ThreadInfo` describes the state of a single thread.\n",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {},
    "fields": {}
  },
  "cpp.vm.Debugger": {
    "doc": "0 is never a valid thread number **/\npublic var number(default, null):Int;\n\npublic var status(default, null):Int;\n\n/** If status is \"stopped breakpoint\", this is the breakpoint number **/\npublic var breakpoint(default, null):Int;\n\n/** If status is \"critical error\", this describes the error **/\npublic var criticalErrorDescription(default, null):String;\n\n/** Stack will be listed with the lowest frame first **/\npublic var stack(default, null):Array<StackFrame>;\n\npublic function new(number:Int, status:Int, breakpoint:Int = -1, criticalErrorDescription:String = null) {\nthis.number = number;\nthis.status = status;\nthis.breakpoint = breakpoint;\nthis.criticalErrorDescription = criticalErrorDescription;\nthis.stack = new Array<StackFrame>();\n}\n}\n\n/**\nThis class wraps the hxcpp C++ implementation to provide a Haxe interface\nto the low level debugging features\n",
    "path": "haxe\\std\\cpp\\vm\\Debugger.hx",
    "functions": {
      "enableCurrentThreadDebugging": "This can be called to turn off (and then back on) all stopping of\ndebugged threads temporarily. It should only be used by classes that\nactually implement the debugger to hide themselves from the debugger as\nnecessary.\n",
      "getCurrentThreadNumber": "Returns the thread number of the calling thread.\n\n@return the thread number of the calling thread.\n",
      "getFiles": "Returns the set of source files known to the debugger. This is a copy\nof the original array and could be quite large. The caller should\ncache this value to avoid multiple copies needing to be made.\n\n@return the set of source files known to the debugger.\n",
      "getFilesFullPath": "Returns the full paths of the set of source files known to the debugger.\nThis is a copy of the original array and could be quite large.\nIt is possible that this set will be empty, in which case the full paths are not known.\nThe index of these files matches the index from `getFiles()`, so the full path for\na given short path can be calculated.\n\n@return the known full paths of the set of source files\n",
      "getClasses": "Returns the set of class names of all classes known to the debugger.\nThis is a copy of the original array and could be quite large. The\ncaller should cache this value to avoid multiple copies needing to be\nmade.\n\n@return the set of class names of all classes known to the debugger.\n",
      "getThreadInfos": "Returns a `ThreadInfo` object describing every thread that existed at the\nmoment that the call was made, except for the debugger thread.\n",
      "getThreadInfo": "Returns a `ThreadInfo` object describing a single thread, or `null` if\nthere is no such thread or the thread queried about was the debugger\nthread and `unsafe` was not `true`.\n",
      "addFileLineBreakpoint": "Adds a new `file:line` breakpoint. The breakpoint number of the newly\nadded breakpoint is returned.\n",
      "addClassFunctionBreakpoint": "Adds a new `class:function` breakpoint. The breakpoint number of the\nnewly added breakpoint is returned.\n",
      "deleteBreakpoint": "Deletes a breakpoint, or all breakpoints.\n",
      "breakNow": "Breaks all threads except the debugger thread (which should be the same\nas the calling thread!).\n\nIf `wait` is `true`, waits up to 2 seconds for all threads to be broken.\nThreads which are in blocking system calls and cannot break after 2\nseconds remain running when this function returns.\n",
      "continueThreads": "Continue execution of all stopped threads. If `specialThreadNumber`\nis a valid thread number, then it will be continued past\n`continueCount` breakpoints instead of just 1 like all of the other\nthreads.\n",
      "stepThread": "Single steps the given thread.\n",
      "getStackVariables": "Returns the list of local variables (including `this`, function\narguments, and local variables) visible to the given thread at the\ngiven stack frame.\n\nReturns a list with a single entry, `THREAD_NOT_STOPPED`, if the\nthread is not stopped and thus variables cannot be fetched and\n`unsafe` is not `true`.\n\n@return the list of local variables (including `this`, function\narguments, and local variables) visible to the given thread at\nthe given stack frame.\n",
      "getStackVariableValue": "Returns the value of a stack variable, or `NONEXISTENT_VALUE` if the\nrequested value does not exist.  If the thread is actively running\nand `unsafe` is not `true`, returns `THREAD_NOT_STOPPED`.\n",
      "setStackVariableValue": "Sets the value of a stack variable and returns that value. If the\nvariable does not exist, on the stack, this function returns\n`NONEXISTENT_VALUE`. If the thread is actively running and `unsafe` is not\n`true`, returns `THREAD_NOT_STOPPED`, and the value is not set.\n",
      "setOnScriptLoadedFunction": "Sets the callback to run whenever a new CPPIA script is loaded.\n\nThis can be helpful for adding breakpoints to a script.\n"
    },
    "fields": {
      "breakpoint": "If status is \"stopped breakpoint\", this is the breakpoint number *",
      "criticalErrorDescription": "If status is \"critical error\", this describes the error *",
      "stack": "Stack will be listed with the lowest frame first *",
      "NONEXISTENT_VALUE": "This class wraps the hxcpp C++ implementation to provide a Haxe interface\nto the low level debugging features\n*/\nclass Debugger {\npublic static inline var THREAD_CREATED = 1;\npublic static inline var THREAD_TERMINATED = 2;\npublic static inline var THREAD_STARTED = 3;\npublic static inline var THREAD_STOPPED = 4;\n\npublic static inline var STEP_INTO = 1;\npublic static inline var STEP_OVER = 2;\npublic static inline var STEP_OUT = 3;\n\n/**\nThis tagging value is returned by `getStackVariableValue()` and\n`setStackVariableValue()` if the requested value does not exist at the\nrequested stack frame\n",
      "THREAD_NOT_STOPPED": "This tagging value is returned by `getStackVariableValue()` and\n`setStackVariableValue()` if the stack variable that is being set is on a\nthread that is running, in which case the set does not take place.\n"
    }
  },
  "eval.luv.DirSync": {
    "doc": "Retrieves the next directory entry.\n*/\nfunction next():Null<Dirent>;\n\n/**\nCleans up after a directory scan.\n*/\nfunction end():Void;\n}\n\n/**\n@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n/**\nOpens the directory at the given path for listing.\n*/\nstatic public function open(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Dir>)->Void):Void;\n\n/**\nCloses the directory.\n*/\npublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nRetrieves a directory entry.\n*/\npublic function read(loop:Loop, ?numberOfEntries:Int, ?request:FileRequest, callback:(result:Result<Array<Dirent>>)->Void):Void;\n\n/**\nBegins directory listing.\n*/\nstatic public function scan(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<DirectoryScan>)->Void):Void;\n}\n\n/**\nSynchronous version of `eval.luv.Dir` API\n",
    "path": "haxe\\std\\eval\\luv\\Dir.hx",
    "functions": {
      "end": "Cleans up after a directory scan.\n",
      "open": "@see https://aantron.github.io/luv/luv/Luv/File#module-Dir\n*/\n@:coreType abstract Dir {\n/**\nOpens the directory at the given path for listing.\n",
      "close": "Closes the directory.\n",
      "read": "Retrieves a directory entry.\n",
      "scan": "Begins directory listing.\n"
    },
    "fields": {}
  },
  "eval.luv.Dns": {
    "doc": "DNS queries.\n\n@see https://aantron.github.io/luv/luv/Luv/Dns\n",
    "path": "haxe\\std\\eval\\luv\\Dns.hx",
    "functions": {
      "getNameInfo": "Retrieves host names.\n"
    },
    "fields": {}
  },
  "eval.luv.Env": {
    "doc": "Environment variables.\n\n@see https://aantron.github.io/luv/luv/Luv/Env\n",
    "path": "haxe\\std\\eval\\luv\\Env.hx",
    "functions": {
      "setEnv": "Sets an environment variable.\n",
      "unsetEnv": "Deletes an environment variable.\n",
      "environ": "Retrieves all environment variables.\n"
    },
    "fields": {}
  },
  "eval.luv.FileMode": {
    "doc": "Permission bits.\n@see https://aantron.github.io/luv/luv/Luv/File/Mode\n",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.FileSync": {
    "doc": "Abstract type for a bit field of permissions bits, i.e., an `int` in which\nmultiple bits may be set. These bit fields are returned by operations such\nas `eval.luv.File.stat`\n*/\n@:coreType abstract FileModeNumeric {}\n\ntypedef FileStatTimeSpec = {\nvar sec:Int64;\nvar nsec:Int64;\n}\n\ntypedef FileStat = {\nvar dev:UInt64;\nvar mode:FileModeNumeric;\nvar nlink:UInt64;\nvar uid:UInt64;\nvar gid:UInt64;\nvar rdev:UInt64;\nvar ino:UInt64;\nvar size:UInt64;\nvar blksize:UInt64;\nvar blocks:UInt64;\nvar flags:UInt64;\nvar gen:UInt64;\nvar atim:FileStatTimeSpec;\nvar mtim:FileStatTimeSpec;\nvar ctim:FileStatTimeSpec;\nvar birthtim:FileStatTimeSpec;\n}\n\ntypedef FileStatFs = {\nvar type:UInt64;\nvar bsize:UInt64;\nvar blocks:UInt64;\nvar bfree:UInt64;\nvar bavail:UInt64;\nvar files:UInt64;\nvar ffree:UInt64;\nvar fspare:Array<UInt64>;\n}\n\nenum abstract FileCopyFlag(Int) {\nvar COPYFILE_EXCL = 0;\nvar COPYFILE_FICLONE = 1;\nvar COPYFILE_FICLONE_FORCE = 2;\n}\n\nenum abstract FileAccessFlag(Int) {\nvar F_OK = 0;\nvar R_OK = 1;\nvar W_OK = 2;\nvar X_OK = 3;\n}\n\nenum abstract FileSymlinkFlag(Int) {\nvar SYMLINK_DIR = 0;\nvar SYMLINK_JUNCTION = 1;\n}\n\n/**\nFiles.\n\n@see https://aantron.github.io/luv/luv/Luv/File\n*/\n@:using(eval.luv.Handle)\n@:coreType abstract File to Handle {\n\nextern static public final stdin:File;\nextern static public final stdout:File;\nextern static public final stderr:File;\n\nstatic public function createRequest():FileRequest;\n\n/**\nChecks whether all the bits in `mask` are set in `bits`.\n\nFor example, if `bits` is equal to octal 0o644, then\n`eval.luv.File.testMode [IRUSR] bits` evaluates to `true`.\n*/\nstatic public function testMode(mask:Array<FileMode>, bits:FileModeNumeric):Bool;\n\n/**\nOpens the file at the given path.\nThe default value of the `mode` argument is equal to octal `0o644`.\n*/\nstatic public function open(loop:Loop, path:NativeString, flags:Array<FileOpenFlag>, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<File>)->Void):Void;\n\n/**\nCloses the file.\n*/\npublic function close(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nReads from the file.\n\nThe incoming data is written consecutively to into the given buffers.\nThe number of bytes that the operation tries to read is the total length\nof the buffers.\n\nEnd of file is indicated by `Result.Ok(0)`. Note that this is different\nfrom `eval.luv.Stream.readStart`.\n*/\npublic function read(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\nWrites to the file.\n*/\npublic function write(loop:Loop, fileOffset:Int64, buffers:Array<Buffer>, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\nDeletes the file at the given path.\n*/\nstatic public function unlink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nMoves the file at the given path to the path given by `toPath`\n*/\nstatic public function rename(loop:Loop, path:NativeString, toPath:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nCreates a temporary file with name based on the given pattern.\n*/\nstatic public function mkstemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<{name:NativeString,file:File}>)->Void):Void;\n\n/**\nCreates a temporary directory with name based on the given pattern.\n*/\nstatic public function mkdtemp(loop:Loop, pattern:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\nCreates a directory.\n*/\nstatic public function mkdir(loop:Loop, path:NativeString, ?mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nDeletes a directory.\n*/\nstatic public function rmdir(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nRetrieves status information for the file at the given path.\n*/\nstatic public function stat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\nLike `eval.luv.File.stat`, but does not dereference symlinks.\n*/\nstatic public function lstat(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\nRetrieves status information for this file.\n*/\npublic function fstat(loop:Loop, ?request:FileRequest, callback:(result:Result<FileStat>)->Void):Void;\n\n/**\nRetrieves status information for the filesystem containing the given path.\n*/\nstatic public function statFs(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<FileStatFs>)->Void):Void;\n\n/**\nFlushes file changes to storage.\n*/\npublic function fsync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nLike `eval.luv.File.fsync`, but may omit some metadata.\n*/\npublic function fdataSync(loop:Loop, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nTruncates the given file to the given length.\n*/\npublic function ftruncate(loop:Loop, length:Int64, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nCopies the file at the given path to the path given by `toPath`.\n*/\nstatic public function copyFile(loop:Loop, path:NativeString, toPath:NativeString, ?flags:Array<FileCopyFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nTransfers data between file descriptors.\n*/\npublic function sendFile(loop:Loop, toFile:File, offset:Int64, length:UInt64, ?request:FileRequest, callback:(result:Result<UInt64>)->Void):Void;\n\n/**\nChecks whether the calling process can access the file at the given path.\n*/\nstatic public function access(loop:Loop, path:NativeString, flags:Array<FileAccessFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nChanges permissions of the file at the given path.\n*/\nstatic public function chmod(loop:Loop, path:NativeString, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nChanges permissions of the file.\n*/\npublic function fchmod(loop:Loop, mode:Array<FileMode>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nSets timestamps of the file at the given path.\n*/\nstatic public function utime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nSets timestamps of the file.\n*/\npublic function futime(loop:Loop, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nSets timestamps of the file at the given path without dereferencing symlinks.\n*/\nstatic public function lutime(loop:Loop, path:NativeString, atime:Float, mtime:Float, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nHardlinks a file at the location given by `link`.\n*/\nstatic public function link(loop:Loop, path:NativeString, link:NativeString, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nSymlinks a file at the location given by `link`.\n*/\nstatic public function symlink(loop:Loop, path:NativeString, link:NativeString, ?flags:Array<FileSymlinkFlag>, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nReads the target path of a symlink.\n*/\nstatic public function readLink(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\nResolves a real absolute path to the given file.\n*/\nstatic public function realPath(loop:Loop, path:NativeString, ?request:FileRequest, callback:(result:Result<NativeString>)->Void):Void;\n\n/**\nChanges ownership of the file at the given path.\n*/\nstatic public function chown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nChanges ownership of the file at the given path. without dereferencing symlinks.\n*/\nstatic public function lchown(loop:Loop, path:NativeString, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nChanges ownership of the file.\n*/\npublic function fchown(loop:Loop, uid:Int, gid:Int, ?request:FileRequest, callback:(result:Result<Result.NoData>)->Void):Void;\n\n/**\nReturns the integer representation of `eval.luv.File`.\n\n`eval.luv.File` is defined as an integer file descriptor by libuv on all\nplatforms at the moment. This is a convenience function for interoperability\nwith `eval.luv.Process`, the API of which assumes that files are represented\nby integers.\n*/\npublic function toInt():Int;\n}\n\n/**\nSynchronous version of `eval.luv.File` API\n",
    "path": "haxe\\std\\eval\\luv\\File.hx",
    "functions": {
      "open": "Opens the file at the given path.\nThe default value of the `mode` argument is equal to octal `0o644`.\n",
      "close": "Closes the file.\n",
      "read": "Reads from the file.\n\nThe incoming data is written consecutively to into the given buffers.\nThe number of bytes that the operation tries to read is the total length\nof the buffers.\n\nEnd of file is indicated by `Result.Ok(0)`. Note that this is different\nfrom `eval.luv.Stream.readStart`.\n",
      "write": "Writes to the file.\n",
      "unlink": "Deletes the file at the given path.\n",
      "rename": "Moves the file at the given path to the path given by `toPath`\n",
      "mkstemp": "Creates a temporary file with name based on the given pattern.\n",
      "mkdtemp": "Creates a temporary directory with name based on the given pattern.\n",
      "mkdir": "Creates a directory.\n",
      "rmdir": "Deletes a directory.\n",
      "stat": "Retrieves status information for the file at the given path.\n",
      "lstat": "Like `eval.luv.File.stat`, but does not dereference symlinks.\n",
      "fstat": "Retrieves status information for this file.\n",
      "statFs": "Retrieves status information for the filesystem containing the given path.\n",
      "fsync": "Flushes file changes to storage.\n",
      "fdataSync": "Like `eval.luv.File.fsync`, but may omit some metadata.\n",
      "ftruncate": "Truncates the given file to the given length.\n",
      "copyFile": "Copies the file at the given path to the path given by `toPath`.\n",
      "sendFile": "Transfers data between file descriptors.\n",
      "access": "Checks whether the calling process can access the file at the given path.\n",
      "chmod": "Changes permissions of the file at the given path.\n",
      "fchmod": "Changes permissions of the file.\n",
      "utime": "Sets timestamps of the file at the given path.\n",
      "futime": "Sets timestamps of the file.\n",
      "lutime": "Sets timestamps of the file at the given path without dereferencing symlinks.\n",
      "link": "Hardlinks a file at the location given by `link`.\n",
      "symlink": "Symlinks a file at the location given by `link`.\n",
      "readLink": "Reads the target path of a symlink.\n",
      "realPath": "Resolves a real absolute path to the given file.\n",
      "chown": "Changes ownership of the file at the given path.\n",
      "lchown": "Changes ownership of the file at the given path. without dereferencing symlinks.\n",
      "fchown": "Changes ownership of the file.\n",
      "toInt": "Returns the integer representation of `eval.luv.File`.\n\n`eval.luv.File` is defined as an integer file descriptor by libuv on all\nplatforms at the moment. This is a convenience function for interoperability\nwith `eval.luv.Process`, the API of which assumes that files are represented\nby integers.\n"
    },
    "fields": {}
  },
  "eval.luv.abstract": {
    "doc": "Error handling.\n\n@see https://aantron.github.io/luv/luv/Luv/Error\n",
    "path": "haxe\\std\\eval\\luv\\UVError.hx",
    "functions": {},
    "fields": {
      "UV_EACCES": "permission denied",
      "UV_EADDRINUSE": "address already in use",
      "UV_EADDRNOTAVAIL": "address not available",
      "UV_EAFNOSUPPORT": "address family not supported",
      "UV_EAGAIN": "resource temporarily unavailable",
      "UV_EAI_ADDRFAMILY": "address family not supported",
      "UV_EAI_AGAIN": "temporary failure",
      "UV_EAI_BADFLAGS": "bad ai_flags value",
      "UV_EAI_BADHINTS": "invalid value for hints",
      "UV_EAI_CANCELED": "request canceled",
      "UV_EAI_FAIL": "permanent failure",
      "UV_EAI_FAMILY": "ai_family not supported",
      "UV_EAI_MEMORY": "out of memory",
      "UV_EAI_NODATA": "no address",
      "UV_EAI_NONAME": "unknown node or service",
      "UV_EAI_OVERFLOW": "argument buffer overflow",
      "UV_EAI_PROTOCOL": "resolved protocol is unknown",
      "UV_EAI_SERVICE": "service not available for socket type",
      "UV_EAI_SOCKTYPE": "socket type not supported",
      "UV_EALREADY": "connection already in progress",
      "UV_EBADF": "bad file descriptor",
      "UV_EBUSY": "resource busy or locked",
      "UV_ECANCELED": "operation canceled",
      "UV_ECONNABORTED": "invalid Unicode character */\n// var UV_ECHARSET = 24; // not defined in Luv ocaml library\n/** software caused connection abort",
      "UV_ECONNREFUSED": "connection refused",
      "UV_ECONNRESET": "connection reset by peer",
      "UV_EDESTADDRREQ": "destination address required",
      "UV_EEXIST": "file already exists",
      "UV_EFAULT": "bad address in system call argument",
      "UV_EFBIG": "file too large",
      "UV_EHOSTUNREACH": "host is unreachable",
      "UV_EINTR": "interrupted system call",
      "UV_EINVAL": "invalid argument",
      "UV_EIO": "i/o error",
      "UV_EISCONN": "socket is already connected",
      "UV_EISDIR": "illegal operation on a directory",
      "UV_ELOOP": "too many symbolic links encountered",
      "UV_EMFILE": "too many open files",
      "UV_EMSGSIZE": "message too long",
      "UV_ENAMETOOLONG": "name too long",
      "UV_ENETDOWN": "network is down",
      "UV_ENETUNREACH": "network is unreachable",
      "UV_ENFILE": "file table overflow",
      "UV_ENOBUFS": "no buffer space available",
      "UV_ENODEV": "no such device",
      "UV_ENOENT": "no such file or directory",
      "UV_ENOMEM": "not enough memory",
      "UV_ENONET": "machine is not on the network",
      "UV_ENOPROTOOPT": "protocol not available",
      "UV_ENOSPC": "no space left on device",
      "UV_ENOSYS": "function not implemented",
      "UV_ENOTCONN": "socket is not connected",
      "UV_ENOTDIR": "not a directory",
      "UV_ENOTEMPTY": "directory not empty",
      "UV_ENOTSOCK": "socket operation on non-socket",
      "UV_ENOTSUP": "operation not supported on socket",
      "UV_EPERM": "operation not permitted",
      "UV_EPIPE": "broken pipe",
      "UV_EPROTO": "protocol error",
      "UV_EPROTONOSUPPORT": "protocol not supported",
      "UV_EPROTOTYPE": "protocol wrong type for socket",
      "UV_ERANGE": "result too large",
      "UV_EROFS": "read-only file system",
      "UV_ESHUTDOWN": "cannot send after transport endpoint shutdown",
      "UV_ESPIPE": "invalid seek",
      "UV_ESRCH": "no such process",
      "UV_ETIMEDOUT": "connection timed out",
      "UV_ETXTBSY": "text file is busy",
      "UV_EXDEV": "cross-device link not permitted",
      "UV_UNKNOWN": "unknown error",
      "UV_EOF": "end of file",
      "UV_ENXIO": "no such device or address",
      "UV_EMLINK": "too many links",
      "UV_ENOTTY": "inappropriate ioctl for device",
      "UV_EFTYPE": "inappropriate file type or format",
      "UV_EILSEQ": "illegal byte sequence",
      "UV_EOVERFLOW": "value too large for defined data type *",
      "UV_ESOCKTNOSUPPORT": "socket type not supported*"
    }
  },
  "eval.luv.LuvException": {
    "doc": "Exceptions thrown by functions in `eval.luv` package.\n",
    "path": "haxe\\std\\eval\\luv\\LuvException.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Metrics": {
    "doc": "Metrics.\n\n@see https://aantron.github.io/luv/luv/Luv/Metrics\n",
    "path": "haxe\\std\\eval\\luv\\Metrics.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Network": {
    "doc": "Network interfaces and hostname.\n\n@see https://aantron.github.io/luv/luv/Luv/Network\n",
    "path": "haxe\\std\\eval\\luv\\Network.hx",
    "functions": {
      "ifIndexToName": "Retrieves a network interface name.\n",
      "ifIndexToIid": "Retrieves a network interface identifier suitable for use in an IPv6 scoped address.\n",
      "getHostName": "Evaluates to the system's hostname.\n"
    },
    "fields": {}
  },
  "eval.luv.Passwd": {
    "doc": "Current user information.\n\n@see https://aantron.github.io/luv/luv/Luv/Passwd\n",
    "path": "haxe\\std\\eval\\luv\\Passwd.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.Path": {
    "doc": "Relevant directories.\n\n@see https://aantron.github.io/luv/luv/Luv/Path\n",
    "path": "haxe\\std\\eval\\luv\\Path.hx",
    "functions": {
      "cwd": "Evaluates to the current working directory.\n",
      "chdir": "Changes the current working directory.\n",
      "homedir": "Evaluates to the path of the home directory.\n",
      "tmpdir": "Evaluates to the path of the temporary directory.\n"
    },
    "fields": {}
  },
  "eval.luv.Pid": {
    "doc": "Process ids.\n\n@see https://aantron.github.io/luv/luv/Luv/Pid\n",
    "path": "haxe\\std\\eval\\luv\\Pid.hx",
    "functions": {
      "getPPid": "Evaluates to the pid of the parent process.\n"
    },
    "fields": {}
  },
  "eval.luv.Random": {
    "doc": "System entropy source.\n\n@see https://aantron.github.io/luv/luv/Luv/Random\n",
    "path": "haxe\\std\\eval\\luv\\Random.hx",
    "functions": {
      "random": "Fills the given buffer with bits from the system entropy source.\n"
    },
    "fields": {}
  },
  "eval.luv.Resource": {
    "doc": "Resource usage.\n\n@see https://aantron.github.io/luv/luv/Luv/Resource\n",
    "path": "haxe\\std\\eval\\luv\\Resource.hx",
    "functions": {
      "loadAvg": "Evaluates to the load average.\n",
      "freeMemory": "Evaluates to the amount of free memory, in bytes.\nReturns `null` when unknown.\n",
      "totalMemory": "Evaluates to the total amount of memory, in bytes.\nReturns `null` when unknown.\n",
      "constrainedMemory": "Gets the amount of memory available to the process (in bytes) based on\nlimits imposed by the OS.\nIf there is no such constraint returns `null`\n",
      "getPriority": "Evaluates to the priority of the process with the given pid.\n",
      "setPriority": "Sets the priority of the process with the given pid.\n",
      "residentSetMemory": "Evaluates to the resident set size for the current process.\n",
      "getRUsage": "Gets the resource usage measures for the current process.\n"
    },
    "fields": {}
  },
  "eval.luv.AddressFamily": {
    "doc": "Network address families.\n",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {},
    "fields": {}
  },
  "eval.luv.SocketType": {
    "doc": "Socket types.\n",
    "path": "haxe\\std\\eval\\luv\\SockAddr.hx",
    "functions": {
      "ipv6": "Converts a string and port number to an IPv6 struct sockaddr.\n",
      "toString": "Converts a network address to a string.\n"
    },
    "fields": {}
  },
  "eval.luv.SystemInfo": {
    "doc": "System information.\n\n@see https://aantron.github.io/luv/luv/Luv/System_info\n",
    "path": "haxe\\std\\eval\\luv\\SystemInfo.hx",
    "functions": {
      "uname": "Gets information about the CPUs on the system.\n"
    },
    "fields": {}
  },
  "eval.luv.ThreadPool": {
    "doc": "Thread pool.\n\n@see https://aantron.github.io/luv/luv/Luv/Thread_pool\n",
    "path": "haxe\\std\\eval\\luv\\ThreadPool.hx",
    "functions": {
      "setSize": "Sets thread pool size.\n\nThis function should be called as soon during process startup as possible.\n"
    },
    "fields": {}
  },
  "eval.luv.Time": {
    "doc": "Current time.\n\n@see https://aantron.github.io/luv/luv/Luv/Time\n",
    "path": "haxe\\std\\eval\\luv\\Time.hx",
    "functions": {
      "hrTime": "Samples the high-resolution timer.\n",
      "sleep": "Suspends the calling thread for at least the given number of milliseconds.\n"
    },
    "fields": {}
  },
  "eval.luv.Version": {
    "doc": "Version information for the vendored libuv.\n\n@see https://aantron.github.io/luv/luv/Luv/Version\n",
    "path": "haxe\\std\\eval\\luv\\Version.hx",
    "functions": {},
    "fields": {}
  },
  "eval.vm.Gc": {
    "doc": "The memory management counters are returned in a stat record.\nThe total amount of memory allocated by the program since it was started is (in words) minor_words + major_words - promoted_words. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.\n*/\ntypedef Stat = {\n/**\nNumber of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.\n*/\nvar minor_words:Float;\n\n/**\nNumber of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.\n*/\nvar promoted_words:Float;\n\n/**\nNumber of words allocated in the major heap, including the promoted words, since the program was started.\n*/\nvar major_words:Float;\n\n/**\nNumber of minor collections since the program was started.\n*/\nvar minor_collections:Float;\n\n/**\nNumber of major collection cycles completed since the program was started.\n*/\nvar major_collections:Float;\n\n/**\nTotal size of the major heap, in words.\n*/\nvar heap_words:Int;\n\n/**\nNumber of contiguous pieces of memory that make up the major heap.\n*/\nvar heap_chunks:Int;\n\n/**\nNumber of words of live data in the major heap, including the header words.\n*/\nvar live_words:Int;\n\n/**\nNumber of live blocks in the major heap.\n*/\nvar live_blocks:Int;\n\n/**\nNumber of words in the free list.\n*/\nvar free_words:Int;\n\n/**\nNumber of blocks in the free list.\n*/\nvar free_blocks:Int;\n\n/**\nSize (in words) of the largest block in the free list.\n*/\nvar largest_free:Int;\n\n/**\nNumber of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.\n*/\nvar fragments:Int;\n\n/**\nNumber of heap compactions since the program was started.\n*/\nvar compactions:Int;\n\n/**\nMaximum size reached by the major heap, in words.\n*/\nvar top_heap_words:Int;\n\n/**\nCurrent size of the stack, in words.\n*/\nvar stack_size:Int;\n}\n\n/**\nThe GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n/**\nThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.\n*/\nvar minor_heap_size:Int;\n\n/**\nHow much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.\n*/\nvar major_heap_increment:Int;\n\n/**\nThe major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.\n*/\nvar space_overhead:Int;\n\n/**\nThis value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.\n*/\nvar verbose:Int;\n\n/**\nHeap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.\n*/\nvar max_overhead:Int;\n\n/**\nThe maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.\n*/\nvar stack_limit:Int;\n\n/**\nThe policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.\n*/\nvar allocation_policy:Int;\n}\n\n/**\nMemory management control and statistics; finalised values.\n",
    "path": "haxe\\std\\eval\\vm\\Gc.hx",
    "functions": {
      "compact": "Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.\n",
      "counters": "Return (minor_words, promoted_words, major_words). This function is as fast as quick_stat.\n",
      "finalise": "Registers f as a finalisation function for v. v must be heap-allocated. f will be called with v as argument at some point between the first time v becomes unreachable (including through weak pointers) and the time v is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before v becomes unreachable).\nThe GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to finalise. If finalise is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.\n\nIn the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.\n",
      "full_major": "Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.\n",
      "get": "Return the current values of the GC parameters in a control record.\n",
      "major": "Do a minor collection and finish the current major collection cycle.\n",
      "major_slice": "Do a minor collection and a slice of major collection. n is the size of the slice: the GC will do enough work to free (on average) n words of memory. If n = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).\n",
      "minor": "Trigger a minor collection.\n",
      "print_stat": "Print the current values of the memory management counters (in human-readable form) into the channel argument.\n",
      "quick_stat": "Same as stat except that live_words, live_blocks, free_words, free_blocks, largest_free, and fragments are set to 0. This function is much faster than stat because it does not need to go through the heap.\n",
      "set": "Changes the GC parameters according to the control record r.\n",
      "stat": "Return the current values of the memory management counters in a stat record. This function examines every heap block to get the statistics.\n"
    },
    "fields": {
      "promoted_words": "Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.\n",
      "major_words": "Number of words allocated in the major heap, including the promoted words, since the program was started.\n",
      "minor_collections": "Number of minor collections since the program was started.\n",
      "major_collections": "Number of major collection cycles completed since the program was started.\n",
      "heap_words": "Total size of the major heap, in words.\n",
      "heap_chunks": "Number of contiguous pieces of memory that make up the major heap.\n",
      "live_words": "Number of words of live data in the major heap, including the header words.\n",
      "live_blocks": "Number of live blocks in the major heap.\n",
      "free_words": "Number of words in the free list.\n",
      "free_blocks": "Number of blocks in the free list.\n",
      "largest_free": "Size (in words) of the largest block in the free list.\n",
      "fragments": "Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.\n",
      "compactions": "Number of heap compactions since the program was started.\n",
      "top_heap_words": "Maximum size reached by the major heap, in words.\n",
      "stack_size": "Current size of the stack, in words.\n",
      "minor_heap_size": "The GC parameters are given as a control record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.\n*/\ntypedef Control = {\n/**\nThe size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.\n",
      "major_heap_increment": "How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.\n",
      "space_overhead": "The major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if space_overhead is smaller. Default: 80.\n",
      "verbose": "This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:\n0x001 Start of major GC cycle.\n0x002 Minor collection and major GC slice.\n0x004 Growing and shrinking of the heap.\n0x008 Resizing of stacks and memory manager tables.\n0x010 Heap compaction.\n0x020 Change of GC parameters.\n0x040 Computation of major GC slice size.\n0x080 Calling of finalisation functions.\n0x100 Bytecode executable and shared library search at start-up.\n0x200 Computation of compaction-triggering condition.\n0x400 Output GC statistics at program exit. Default: 0.\n",
      "max_overhead": "Heap compaction is triggered when the estimated amount of \"wasted\" memory is more than max_overhead percent of the amount of live data. If max_overhead is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If max_overhead >= 1000000, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set allocation_policy to 1. Default: 500.\n",
      "stack_limit": "The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.\n",
      "allocation_policy": "The policy used for allocating in the heap. Possible values are 0 and 1. 0 is the next-fit policy, which is quite fast but can result in fragmentation. 1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.\n"
    }
  },
  "flash.Lib": {
    "doc": "Platform-specific Flash Library. Provides some platform-specific\nfunctions for the Flash target.\n",
    "path": "haxe\\std\\flash\\Lib.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.UnsafeStringMap": {
    "doc": "This is similar to `StringMap` excepts that it does not sanitize the keys.\nAs a result, it will be faster to access the map for reading, but it might fail\nwith some reserved keys such as `constructor` or `prototype`.\n",
    "path": "haxe\\std\\flash\\_std\\haxe\\ds\\UnsafeStringMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.StackItem": {
    "doc": "Elements return by `CallStack` methods.\n",
    "path": "haxe\\std\\haxe\\CallStack.hx",
    "functions": {
      "exceptionStack": "Return the exception stack : this is the stack elements between\nthe place the last exception was thrown and the place it was\ncaught, or an empty array if not available.\nSet `fullStack` parameter to true in order to return the full exception stack.\n\nMay not work if catch type was a derivative from `haxe.Exception`.\n",
      "toString": "Returns a representation of the stack as a printable string.\n",
      "subtract": "Returns a range of entries of current stack from the beginning to the the\ncommon part of this and `stack`.\n",
      "copy": "Make a copy of the stack.\n"
    },
    "fields": {}
  },
  "haxe.FlatEnum": {
    "doc": "This type unifies with any function type.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.\n*/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\nThis type unifies with an enum instance if all constructors of the enum\nrequire no arguments.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.\n",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.NotVoid": {
    "doc": "This type unifies with anything but `Void`.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.\n",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Constructible": {
    "doc": "This type unifies with any instance of classes that have a constructor\nwhich\n\nis `public` and\nunifies with the type used for type parameter `T`.\n\nIf a type parameter `A` is assigned to a type parameter `B` which is constrained\nto `Constructible<T>`, A must be explicitly constrained to\n`Constructible<T>` as well.\n\nIt is intended to be used as a type parameter constraint. If used as a real\ntype, the underlying type will be `Dynamic`.\n",
    "path": "haxe\\std\\haxe\\Constraints.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.DynamicAccess": {
    "doc": "DynamicAccess is an abstract type for working with anonymous structures\nthat are intended to hold collections of objects by the string key.\n\nFor example, these types of structures are often created from JSON.\n\nBasically, it wraps `Reflect` calls in a `Map`-like interface.\n",
    "path": "haxe\\std\\haxe\\DynamicAccess.hx",
    "functions": {
      "get": "Returns a value by specified `key`.\n\nIf the structure does not contain the given key, `null` is returned.\n\nIf `key` is `null`, the result is unspecified.\n",
      "set": "Sets a `value` for a specified `key`.\n\nIf the structure contains the given key, its value will be overwritten.\n\nReturns the given value.\n\nIf `key` is `null`, the result is unspecified.\n",
      "exists": "Tells if the structure contains a specified `key`.\n\nIf `key` is `null`, the result is unspecified.\n",
      "remove": "Removes a specified `key` from the structure.\n\nReturns true, if `key` was present in structure, or false otherwise.\n\nIf `key` is `null`, the result is unspecified.\n",
      "keys": "Returns an array of `keys` in a structure.\n",
      "copy": "Returns a shallow copy of the structure\n",
      "iterator": "Returns an Iterator over the values of this `DynamicAccess`.\n\nThe order of values is undefined.\n",
      "keyValueIterator": "Returns an Iterator over the keys and values of this `DynamicAccess`.\n\nThe order of values is undefined.\n"
    },
    "fields": {}
  },
  "haxe.EntryPoint": {
    "doc": "If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\nThis class can be redefined by custom frameworks so they can handle their own main loop logic.\n",
    "path": "haxe\\std\\haxe\\EntryPoint.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumFlags": {
    "doc": "A typed interface for bit flags. This is not a real object, only a typed\ninterface for an actual Int. Each flag can be tested/set with the\ncorresponding enum instance. Up to 32 flags can be stored that way.\n\nEnum constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc. The methods are optimized if the\nenum instance is passed directly, e.g. as `has(EnumCtor)`. Otherwise\n`Type.enumIndex()` reflection is used.\n",
    "path": "haxe\\std\\haxe\\EnumFlags.hx",
    "functions": {
      "has": "Checks if the index of enum instance `v` is set.\n\nThis method is optimized if `v` is an enum instance expression such as\n`SomeEnum.SomeCtor`.\n\nIf `v` is `null`, the result is unspecified.\n",
      "set": "Sets the index of enum instance `v`.\n\nThis method is optimized if `v` is an enum instance expression such as\n`SomeEnum.SomeCtor`.\n\nIf `v` is `null`, the result is unspecified.\n",
      "unset": "Unsets the index of enum instance `v`.\n\nThis method is optimized if `v` is an enum instance expression such as\n`SomeEnum.SomeCtor`.\n\nIf `v` is `null`, the result is unspecified.\n",
      "setTo": "Depending on the value of `condition` sets (`condition=true`) or unsets (`condition=false`)\nthe index of enum instance `v`.\n\nThis method is optimized if `v` is an enum instance expression such as\n`SomeEnum.SomeCtor`.\n\nIf `v` is `null`, the result is unspecified.\n",
      "ofInt": "Convert a integer bitflag into a typed one (this is a no-op, it does not\nhave any impact on speed).\n",
      "toInt": "Convert the typed bitflag into the corresponding int value (this is a\nno-op, it doesn't have any impact on speed).\n"
    },
    "fields": {}
  },
  "haxe.EnumTools": {
    "doc": "This class provides advanced methods on enums. It is ideally used with\n`using EnumTools` and then acts as an\n[extension](https://haxe.org/manual/lf-static-extension.html) to the\n`enum` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.\n",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.EnumValueTools": {
    "doc": "Returns the name of enum `e`, including its path.\n\nIf `e` is inside a package, the package structure is returned dot-\nseparated, with another dot separating the enum name:\n\npack1.pack2.(...).packN.EnumName\n\nIf `e` is a sub-type of a Haxe module, that module is not part of the\npackage structure.\n\nIf `e` has no package, the enum name is returned.\n\nIf `e` is `null`, the result is unspecified.\n\nThe enum name does not include any type parameters.\n*/\nstatic inline function getName<T>(e:Enum<T>):String {\nreturn Type.getEnumName(e);\n}\n\n/**\nCreates an instance of enum `e` by calling its constructor `constr` with\narguments `params`.\n\nIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n*/\nstatic inline function createByName<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\nreturn Type.createEnum(e, constr, params);\n}\n\n/**\nCreates an instance of enum `e` by calling its constructor number\n`index` with arguments `params`.\n\nThe constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc.\n\nIf `e` or `index` is `null`, or if enum `e` has no constructor\ncorresponding to index `index`, or if the number of elements in `params`\ndoes not match the expected number of constructor arguments, or if any\nargument has an invalid type, the result is unspecified.\n*/\nstatic inline function createByIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\nreturn Type.createEnumIndex(e, index, params);\n}\n\n/**\nReturns a list of all constructors of enum `e` that require no\narguments.\n\nThis may return the empty Array `[]` if all constructors of `e` require\narguments.\n\nOtherwise an instance of `e` constructed through each of its non-\nargument constructors is returned, in the order of the constructor\ndeclaration.\n\nIf `e` is `null`, the result is unspecified.\n*/\nstatic inline function createAll<T>(e:Enum<T>):Array<T> {\nreturn Type.allEnums(e);\n}\n\n/**\nReturns a list of the names of all constructors of enum `e`.\n\nThe order of the constructor names in the returned Array is preserved\nfrom the original syntax.\n\nIf `c` is `null`, the result is unspecified.\n*/\nstatic inline function getConstructors<T>(e:Enum<T>):Array<String> {\nreturn Type.getEnumConstructs(e);\n}\n\n#if jvm\n@:noCompletion\nextern static function values<T>(en:Enum<T>):jvm.NativeArray<java.lang.Enum<T>>;\n#end\n}\n\n/**\nThis class provides advanced methods on enum values. It is ideally used with\n`using EnumValueTools` and then acts as an\n[extension](https://haxe.org/manual/lf-static-extension.html) to the\n`EnumValue` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.\n",
    "path": "haxe\\std\\haxe\\EnumTools.hx",
    "functions": {
      "createByName": "Creates an instance of enum `e` by calling its constructor `constr` with\narguments `params`.\n\nIf `e` or `constr` is `null`, or if enum `e` has no constructor named\n`constr`, or if the number of elements in `params` does not match the\nexpected number of constructor arguments, or if any argument has an\ninvalid type, the result is unspecified.\n",
      "createByIndex": "Creates an instance of enum `e` by calling its constructor number\n`index` with arguments `params`.\n\nThe constructor indices are preserved from Haxe syntax, so the first\ndeclared is index 0, the next index 1 etc.\n\nIf `e` or `index` is `null`, or if enum `e` has no constructor\ncorresponding to index `index`, or if the number of elements in `params`\ndoes not match the expected number of constructor arguments, or if any\nargument has an invalid type, the result is unspecified.\n",
      "createAll": "Returns a list of all constructors of enum `e` that require no\narguments.\n\nThis may return the empty Array `[]` if all constructors of `e` require\narguments.\n\nOtherwise an instance of `e` constructed through each of its non-\nargument constructors is returned, in the order of the constructor\ndeclaration.\n\nIf `e` is `null`, the result is unspecified.\n",
      "getConstructors": "Returns a list of the names of all constructors of enum `e`.\n\nThe order of the constructor names in the returned Array is preserved\nfrom the original syntax.\n\nIf `c` is `null`, the result is unspecified.\n",
      "equals": "This class provides advanced methods on enum values. It is ideally used with\n`using EnumValueTools` and then acts as an\n[extension](https://haxe.org/manual/lf-static-extension.html) to the\n`EnumValue` types.\n\nIf the first argument to any of the methods is `null`, the result is\nunspecified.\n*/\nextern class EnumValueTools {\n/**\nRecursively compares two enum instances `a` and `b` by value.\n\nUnlike `a == b`, this function performs a deep equality check on the\narguments of the constructors (if there are any).\n\nIf `a` or `b` are `null`, the result is unspecified.\n",
      "getName": "Returns the constructor name of enum instance `e`.\n\nThe result String does not contain any constructor arguments.\n\nIf `e` is `null`, the result is unspecified.\n",
      "getParameters": "Returns a list of the constructor arguments of enum instance `e`.\n\nIf `e` has no arguments, the result is `[]`.\n\nOtherwise the result are the values that were used as arguments to `e`,\nin the order of their declaration.\n\nIf `e` is `null`, the result is unspecified.\n",
      "getIndex": "Returns the index of enum instance `e`.\n\nThis corresponds to the original syntactic position of `e`. The index of\nthe first declared constructor is 0, the next one is 1 etc.\n\nIf `e` is `null`, the result is unspecified.\n"
    },
    "fields": {}
  },
  "haxe.Exception": {
    "doc": "Base class for exceptions.\n\nIf this class (or derivatives) is used to catch an exception, then\n`haxe.CallStack.exceptionStack()` will not return a stack for the exception\ncaught. Use `haxe.Exception.stack` property instead:\n```haxe\ntry {\nthrowSomething();\n} catch(e:Exception) {\ntrace(e.stack);\n}\n```\n\nCustom exceptions should extend this class:\n```haxe\nclass MyException extends haxe.Exception {}\n//...\nthrow new MyException('terrible exception');\n```\n\n`haxe.Exception` is also a wildcard type to catch any exception:\n```haxe\ntry {\nthrow 'Catch me!';\n} catch(e:haxe.Exception) {\ntrace(e.message); // Output: Catch me!\n}\n```\n\nTo rethrow an exception just throw it again.\nHaxe will try to rethrow an original native exception whenever possible.\n```haxe\ntry {\nvar a:Array<Int> = null;\na.push(1); // generates target-specific null-pointer exception\n} catch(e:haxe.Exception) {\nthrow e; // rethrows native exception instead of haxe.Exception\n}\n```\n",
    "path": "haxe\\std\\haxe\\Exception.hx",
    "functions": {
      "thrown": "Used internally for wrapping non-throwable values for `throw` expressions.\n",
      "new": "Create a new Exception instance.\n\nThe `previous` argument could be used for exception chaining.\n\nThe `native` argument is for internal usage only.\nThere is no need to provide `native` argument manually and no need to keep it\nupon extending `haxe.Exception` unless you know what you're doing.\n",
      "unwrap": "Extract an originally thrown value.\n\nUsed internally for catching non-native exceptions.\nDo _not_ override unless you know what you are doing.\n",
      "toString": "Returns exception message.\n",
      "details": "Detailed exception description.\n\nIncludes message, stack and the chain of previous exceptions (if set).\n"
    },
    "fields": {
      "stack": "The call stack at the moment of the exception creation.\n",
      "previous": "Contains an exception, which was passed to `previous` constructor argument.\n",
      "native": "Native exception, which caused this exception.\n"
    }
  },
  "haxe.Int64Helper": {
    "doc": "Helper for parsing to `Int64` instances.\n",
    "path": "haxe\\std\\haxe\\Int64Helper.hx",
    "functions": {
      "fromFloat": "Create `Int64` from given float.\n"
    },
    "fields": {}
  },
  "haxe.Json": {
    "doc": "Cross-platform JSON API: it will automatically use the optimized native API if available.\nUse `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:\nThis will provide extra encoding (but not decoding) features such as enums (replaced by their index) and StringMaps.\n\n@see https://haxe.org/manual/std-Json.html\n",
    "path": "haxe\\std\\haxe\\Json.hx",
    "functions": {
      "stringify": "Encodes the given `value` and returns the resulting JSON string.\n\nIf `replacer` is given and is not null, it is used to retrieve the\nactual object to be encoded. The `replacer` function takes two parameters,\nthe key and the value being encoded. Initial key value is an empty string.\n\nIf `space` is given and is not null, the result will be pretty-printed.\nSuccessive levels will be indented by this string.\n\n@see https://haxe.org/manual/std-Json-encoding.html\n"
    },
    "fields": {}
  },
  "haxe.Log": {
    "doc": "Log primarily provides the `trace()` method, which is invoked upon a call to\n`trace()` in Haxe code.\n",
    "path": "haxe\\std\\haxe\\Log.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Resource": {
    "doc": "Resource can be used to access resources that were added through the\n`--resource file@name` command line parameter.\n\nDepending on their type they can be obtained as `String` through\n`getString(name)`, or as binary data through `getBytes(name)`.\n\nA list of all available resource names can be obtained from `listNames()`.\n",
    "path": "haxe\\std\\haxe\\Resource.hx",
    "functions": {
      "getString": "Retrieves the resource identified by `name` as a `String`.\n\nIf `name` does not match any resource name, `null` is returned.\n",
      "getBytes": "Retrieves the resource identified by `name` as an instance of\nhaxe.io.Bytes.\n\nIf `name` does not match any resource name, `null` is returned.\n"
    },
    "fields": {}
  },
  "haxe.Serializer": {
    "doc": "The Serializer class can be used to encode values and objects into a `String`,\nfrom which the `Unserializer` class can recreate the original representation.\n\nThis class can be used in two ways:\n\n- create a `new Serializer()` instance, call its `serialize()` method with\nany argument and finally retrieve the String representation from\n`toString()`\n- call `Serializer.run()` to obtain the serialized representation of a\nsingle argument\n\nSerialization is guaranteed to work for all haxe-defined classes, but may\nor may not work for instances of external/native classes.\n\nThe specification of the serialization format can be found here:\n<https://haxe.org/manual/std-serialization-format.html>\n",
    "path": "haxe\\std\\haxe\\Serializer.hx",
    "functions": {
      "reset": "Resets the internal state of the Serializer, allowing it to be reused.\n\nThis does not affect the `useCache` or `useEnumIndex` properties;\ntheir values will remain unchanged after calling this method.\n",
      "toString": "Return the String representation of `this` Serializer.\n\nThe exact format specification can be found here:\nhttps://haxe.org/manual/serialization/format\n",
      "serialize": "Serializes `v`.\n\nAll haxe-defined values and objects with the exception of functions can\nbe serialized. Serialization of external/native objects is not\nguaranteed to work. This is also true for classes extending external/native\nclasses. On some targets, this might include exceptions, too.\n\nThe values of `this.useCache` and `this.useEnumIndex` may affect\nserialization output.\n",
      "run": "Serializes `v` and returns the String representation.\n\nThis is a convenience function for creating a new instance of\nSerializer, serialize `v` into it and obtain the result through a call\nto `toString()`.\n"
    },
    "fields": {
      "USE_ENUM_INDEX": "Serializes enum values using constructor indices instead of names.\n\nWhen `USE_ENUM_INDEX` is set to `true`, enum constructors are serialized by\ntheir numeric index. This can reduce the size of the serialized data,\nespecially for enums with long or frequently used constructor names.\n\nHowever, using indices makes serialized data more fragile for long-term\nstorage. If enum definitions change (e.g., by adding or removing constructors),\nthe indices may no longer match the intended constructors.\n\nThis is a global default. You can override it per instance using the\n`useEnumIndex` field on a `Serializer`.",
      "useCache": "Determines whether this `Serializer` instance uses object caching.\n\nWhen enabled, repeated references to the same object are serialized using references\ninstead of duplicating data, reducing output size and preserving object identity.\n\nSee `USE_CACHE` for a complete description.",
      "useEnumIndex": "Determines whether this `Serializer` instance serializes enum values using their index\ninstead of their constructor name.\n\nUsing indexes can reduce the size of the serialized data but may be less readable and\nmore fragile if enum definitions change.\n\nSee `USE_ENUM_INDEX` for a complete description."
    }
  },
  "haxe.Template": {
    "doc": "`Template` provides a basic templating mechanism to replace values in a source\nString, and to have some basic logic.\n\nA complete documentation of the supported syntax is available at:\n<https://haxe.org/manual/std-template.html>\n",
    "path": "haxe\\std\\haxe\\Template.hx",
    "functions": {
      "execute": "Executes `this` `Template`, taking into account `context` for\nreplacements and `macros` for callback functions.\n\nIf `context` has a field `name`, its value replaces all occurrences of\n`::name::` in the `Template`. Otherwise `Template.globals` is checked instead,\nIf `name` is not a field of that either, `::name::` is replaced with `null`.\n\nIf `macros` has a field `name`, all occurrences of `$$name(args)` are\nreplaced with the result of calling that field. The first argument is\nalways the `resolve()` method, followed by the given arguments.\nIf `macros` has no such field, the result is unspecified.\n\nIf `context` is `null`, the result is unspecified. If `macros` is `null`,\nno macros are used.\n"
    },
    "fields": {}
  },
  "haxe.Timer": {
    "doc": "The `Timer` class allows you to create asynchronous timers on platforms that\nsupport events.\n\nThe intended usage is to create an instance of the `Timer` class with a given\ninterval, set its `run()` method to a custom function to be invoked and\neventually call `stop()` to stop the `Timer`.\n\nNote that a running `Timer` may or may not prevent the program to exit\nautomatically when `main()` returns.\n\nIt is also possible to extend this class and override its `run()` method in\nthe child class.\n\nNotice for threaded targets:\n`Timer` instances require threads they were created in to run with Haxe's event loops.\nMain thread of a Haxe program always contains an event loop. For other cases use\n`sys.thread.Thread.createWithEventLoop` and `sys.thread.Thread.runWithEventLoop` methods.\n",
    "path": "haxe\\std\\haxe\\Timer.hx",
    "functions": {
      "stop": "Stops `this` Timer.\n\nAfter calling this method, no additional invocations of `this.run`\nwill occur.\n\nIt is not possible to restart `this` Timer once stopped.\n",
      "delay": "This method is invoked repeatedly on `this` Timer.\n\nIt can be overridden in a subclass, or rebound directly to a custom\nfunction:\n\n```haxe\nvar timer = new haxe.Timer(1000); // 1000ms delay\ntimer.run = function() { ... }\n```\n\nOnce bound, it can still be rebound to different functions until `this`\nTimer is stopped through a call to `this.stop`.\n*/\npublic dynamic function run() {}\n\n/**\nInvokes `f` after `time_ms` milliseconds.\n\nThis is a convenience function for creating a new Timer instance with\n`time_ms` as argument, binding its `run()` method to `f` and then stopping\n`this` Timer upon the first invocation.\n\nIf `f` is `null`, the result is unspecified.\n",
      "measure": "Measures the time it takes to execute `f`, in seconds with fractions.\n\nThis is a convenience function for calculating the difference between\n`Timer.stamp()` before and after the invocation of `f`.\n\nThe difference is passed as argument to `Log.trace()`, with `\"s\"` appended\nto denote the unit. The optional `pos` argument is passed through.\n\nIf `f` is `null`, the result is unspecified.\n",
      "stamp": "Returns a timestamp, in seconds with fractions.\n\nThe value itself might differ depending on platforms, only differences\nbetween two values make sense.\n",
      "milliseconds": "Returns a monotonically increasing timestamp with millisecond resolution.\n\nThe precision and epoch of the timer is platform defined."
    },
    "fields": {}
  },
  "haxe.Unit": {
    "doc": "A unit type that only has one value.\n",
    "path": "haxe\\std\\haxe\\Unit.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.Unserializer": {
    "doc": "The `Unserializer` class is the complement to the `Serializer` class. It parses\na serialization `String` and creates objects from the contained data.\n\nThis class can be used in two ways:\n\n- create a `new Unserializer()` instance with a given serialization\nString, then call its `unserialize()` method until all values are\nextracted\n- call `Unserializer.run()`  to unserialize a single value from a given\nString\n\nThe specification of the serialization format can be found here:\n<https://haxe.org/manual/serialization/format>\n",
    "path": "haxe\\std\\haxe\\Unserializer.hx",
    "functions": {
      "setResolver": "Sets the type resolver of `this` Unserializer instance to `r`.\n\nIf `r` is `null`, a special resolver is used which returns `null` for all\ninput values.\n\nSee `DEFAULT_RESOLVER` for more information on type resolvers.\n",
      "getResolver": "Gets the type resolver of `this` Unserializer instance.\n\nSee `DEFAULT_RESOLVER` for more information on type resolvers.\n",
      "unserialize": "Unserializes the next part of `this` Unserializer instance and returns\nthe according value.\n\nThis function may call `this.resolver.resolveClass` to determine a\nClass from a String, and `this.resolver.resolveEnum` to determine an\nEnum from a String.\n\nIf `this` Unserializer instance contains no more or invalid data, an\nexception is thrown.\n\nThis operation may fail on structurally valid data if a type cannot be\nresolved or if a field cannot be set. This can happen when unserializing\nStrings that were serialized on a different Haxe target, in which the\nserialization side has to make sure not to include platform-specific\ndata.\n\nClasses are created from `Type.createEmptyInstance`, which means their\nconstructors are not called.\n",
      "run": "Unserializes `v` and returns the according value.\n\nThis is a convenience function for creating a new instance of\nUnserializer with `v` as buffer and calling its `unserialize()` method\nonce.\n"
    },
    "fields": {
      "index": "Creates a new Unserializer instance, with its internal buffer\ninitialized to `buf`.\n\nThis does not parse `buf` immediately. It is parsed only when calls to\n`this.unserialize` are made.\n\nEach Unserializer instance maintains its own cache.\n*/\npublic function new(buf:String) {\nthis.buf = buf;\nlength = this.buf.fastLength();\npos = 0;\n#if neko\nupos = 0;\n#end\nscache = new Array();\ncache = new Array();\nvar r = DEFAULT_RESOLVER;\nif (r == null) {\nr = new DefaultResolver();\nDEFAULT_RESOLVER = r;\n}\nresolver = r;\n}\n\n/**\nSets the type resolver of `this` Unserializer instance to `r`.\n\nIf `r` is `null`, a special resolver is used which returns `null` for all\ninput values.\n\nSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\npublic function setResolver(r) {\nif (r == null)\nresolver = NullResolver.instance;\nelse\nresolver = r;\n}\n\n/**\nGets the type resolver of `this` Unserializer instance.\n\nSee `DEFAULT_RESOLVER` for more information on type resolvers.\n*/\npublic function getResolver() {\nreturn resolver;\n}\n\ninline function get(p:Int):Int {\n#if php\nreturn p >= length ? 0 : buf.fastCharCodeAt(p);\n#else\nreturn StringTools.fastCodeAt(buf, p);\n#end\n}\n\nfunction readDigits() {\nvar k = 0;\nvar s = false;\nvar fpos = pos;\nwhile (true) {\nvar c = get(pos);\nif (StringTools.isEof(c))\nbreak;\nif (c == \"-\".code) {\nif (pos != fpos)\nbreak;\ns = true;\npos++;\ncontinue;\n}\nif (c < \"0\".code || c > \"9\".code)\nbreak;\nk = k * 10 + (c - \"0\".code);\npos++;\n}\nif (s)\nk *= -1;\nreturn k;\n}\n\nfunction readFloat() {\nvar p1 = pos;\nwhile (true) {\nvar c = get(pos);\nif (StringTools.isEof(c))\nbreak;\n// + - . , 0-9\nif ((c >= 43 && c < 58) || c == \"e\".code || c == \"E\".code)\npos++;\nelse\nbreak;\n}\nreturn Std.parseFloat(buf.fastSubstr(p1, pos - p1));\n}\n\nfunction unserializeObject(o:{}) {\nwhile (true) {\nif (pos >= length)\nthrow \"Invalid object\";\nif (get(pos) == \"g\".code)\nbreak;\nvar k:Dynamic = unserialize();\nif (!Std.isOfType(k, String))\nthrow \"Invalid object key\";\nvar v = unserialize();\nReflect.setField(o, k, v);\n}\npos++;\n}\n\nfunction unserializeEnum<T>(edecl:Enum<T>, tag:String) {\nif (get(pos++) != \":\".code)\nthrow \"Invalid enum format\";\nvar nargs = readDigits();\nif (nargs == 0)\nreturn Type.createEnum(edecl, tag);\nvar args = new Array();\nwhile (nargs-- > 0)\nargs.push(unserialize());\nreturn Type.createEnum(edecl, tag, args);\n}\n\n/**\nUnserializes the next part of `this` Unserializer instance and returns\nthe according value.\n\nThis function may call `this.resolver.resolveClass` to determine a\nClass from a String, and `this.resolver.resolveEnum` to determine an\nEnum from a String.\n\nIf `this` Unserializer instance contains no more or invalid data, an\nexception is thrown.\n\nThis operation may fail on structurally valid data if a type cannot be\nresolved or if a field cannot be set. This can happen when unserializing\nStrings that were serialized on a different Haxe target, in which the\nserialization side has to make sure not to include platform-specific\ndata.\n\nClasses are created from `Type.createEmptyInstance`, which means their\nconstructors are not called.\n*/\npublic function unserialize():Dynamic {\nswitch (get(pos++)) {\ncase \"n\".code:\nreturn null;\ncase \"t\".code:\nreturn true;\ncase \"f\".code:\nreturn false;\ncase \"z\".code:\nreturn 0;\ncase \"i\".code:\nreturn readDigits();\ncase \"d\".code:\nreturn readFloat();\ncase \"y\".code:\nvar len = readDigits();\nif (get(pos++) != \":\".code || length - pos < len)\nthrow \"Invalid string length\";\nvar s = buf.fastSubstr(pos, len);\npos += len;\ns = StringTools.urlDecode(s);\nscache.push(s);\nreturn s;\ncase \"k\".code:\nreturn Math.NaN;\ncase \"m\".code:\nreturn Math.NEGATIVE_INFINITY;\ncase \"p\".code:\nreturn Math.POSITIVE_INFINITY;\ncase \"a\".code:\nvar buf = buf;\nvar a = new Array<Dynamic>();\n#if cpp\nvar cachePos = cache.length;\n#end\ncache.push(a);\nwhile (true) {\nvar c = get(pos);\nif (c == \"h\".code) {\npos++;\nbreak;\n}\nif (c == \"u\".code) {\npos++;\nvar n = readDigits();\na[a.length + n - 1] = null;\n} else\na.push(unserialize());\n}\n#if cpp\nreturn cache[cachePos] = cpp.NativeArray.resolveVirtualArray(a);\n#else\nreturn a;\n#end\ncase \"o\".code:\nvar o = {};\ncache.push(o);\nunserializeObject(o);\nreturn o;\ncase \"r\".code:\nvar n = readDigits();\nif (n < 0 || n >= cache.length)\nthrow \"Invalid reference\";\nreturn cache[n];\ncase \"R\".code:\nvar n = readDigits();\nif (n < 0 || n >= scache.length)\nthrow \"Invalid string reference\";\nreturn scache[n];\ncase \"x\".code:\nthrow unserialize();\ncase \"c\".code:\nvar name = unserialize();\nvar cl = resolver.resolveClass(name);\nif (cl == null)\nthrow \"Class not found \" + name;\nvar o = Type.createEmptyInstance(cl);\ncache.push(o);\nunserializeObject(o);\nreturn o;\ncase \"w\".code:\nvar name = unserialize();\nvar edecl = resolver.resolveEnum(name);\nif (edecl == null)\nthrow \"Enum not found \" + name;\nvar e = unserializeEnum(edecl, unserialize());\ncache.push(e);\nreturn e;\ncase \"j\".code:\nvar name = unserialize();\nvar edecl = resolver.resolveEnum(name);\nif (edecl == null)\nthrow \"Enum not found \" + name;\npos++; /* skip ':'"
    }
  },
  "haxe.ValueException": {
    "doc": "An exception containing arbitrary value.\n\nThis class is automatically used for throwing values, which don't extend `haxe.Exception`\nor native exception type.\nFor example:\n```haxe\nthrow \"Terrible error\";\n```\nwill be compiled to\n```haxe\nthrow new ValueException(\"Terrible error\");\n```\n",
    "path": "haxe\\std\\haxe\\ValueException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Adler32": {
    "doc": "Calculates the Adler32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Adler32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Base64": {
    "doc": "Allows one to encode/decode String and bytes using Base64 encoding.\n",
    "path": "haxe\\std\\haxe\\crypto\\Base64.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.BaseCode": {
    "doc": "Allows one to encode/decode String and bytes using a power of two base dictionary.\n",
    "path": "haxe\\std\\haxe\\crypto\\BaseCode.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Crc32": {
    "doc": "Calculates the Crc32 of the given Bytes.",
    "path": "haxe\\std\\haxe\\crypto\\Crc32.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.HashMethod": {
    "doc": "Hash methods for Hmac calculation.\n",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Hmac": {
    "doc": "Calculates a Hmac of the given Bytes using a HashMethod.\n",
    "path": "haxe\\std\\haxe\\crypto\\Hmac.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Md5": {
    "doc": "Creates a MD5 of a String.\n",
    "path": "haxe\\std\\haxe\\crypto\\Md5.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha1": {
    "doc": "Creates a Sha1 of a String.\n",
    "path": "haxe\\std\\haxe\\crypto\\Sha1.hx",
    "functions": {
      "rol": "Bitwise rotate a 32-bit number to the left\n",
      "ft": "Perform the appropriate triplet combination function for the current iteration\n",
      "kt": "Determine the appropriate additive constant for the current iteration\n"
    },
    "fields": {}
  },
  "haxe.crypto.Sha224": {
    "doc": "Creates a Sha224 of a String.\n",
    "path": "haxe\\std\\haxe\\crypto\\Sha224.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.crypto.Sha256": {
    "doc": "Creates a Sha256 of a String.\n",
    "path": "haxe\\std\\haxe\\crypto\\Sha256.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.display.abstract": {
    "doc": "This type is already available with it's unqualified name for one of these reasons:\n- it's a toplevel type\n- it's imported with an `import` in the current module\n- it's imported in an `import.hx` file\n*/\nvar Imported;\n\n/**\nThe type is currently not imported. It can be accessed either\nwith its fully qualified name or by inserting an import.\n*/\nvar Unimported;\n\n/**\nA type with the same name is already imported in the module.\nThe fully qualified name has to be used to access it.\n*/\nvar Shadowed;\n}\n\n/* Type instance */\ntypedef JsonPackagePath = {\nvar pack:Array<String>;\n}\n\ntypedef JsonModulePath = JsonPackagePath & {\nvar moduleName:String;\nvar ?importStatus:ImportStatus;\n}\n\ntypedef JsonTypePath = JsonModulePath & {\nvar typeName:String;\n}\n\ntypedef JsonStaticFieldPath = JsonTypePath & {\nvar fieldName:String;\n}\n\ntypedef JsonTypePathWithParams = {\nvar path:JsonTypePath;\nvar params:JsonTypes;\n}\n\ntypedef JsonFunctionArgument = {\nvar name:String;\nvar opt:Bool;\nvar t:JsonType<Dynamic>;\nvar ?value:{\nvar string:String;\n};\n}\n\ntypedef JsonFunctionSignature = {\nvar args:Array<JsonFunctionArgument>;\nvar ret:JsonType<Dynamic>;\n}\n\nenum abstract JsonAnonStatusKind<T>(String) {\nvar AClosed;\nvar AOpened;\nvar AConst;\nvar AExtend:JsonAnonStatusKind<JsonTypes>;\nvar AClassStatics:JsonAnonStatusKind<JsonTypePath>;\nvar AEnumStatics:JsonAnonStatusKind<JsonTypePath>;\nvar AAbstractStatics:JsonAnonStatusKind<JsonTypePath>;\n}\n\ntypedef JsonAnonStatus<T> = {\nvar kind:JsonAnonStatusKind<T>;\nvar args:T;\n}\n\ntypedef JsonAnon = {\nvar fields:JsonClassFields;\nvar status:JsonAnonStatus<Dynamic>;\n}\n\nenum abstract JsonTypeKind<T>(String) {\nvar TMono;\nvar TInst:JsonTypeKind<JsonTypePathWithParams>;\nvar TEnum:JsonTypeKind<JsonTypePathWithParams>;\nvar TType:JsonTypeKind<JsonTypePathWithParams>;\nvar TAbstract:JsonTypeKind<JsonTypePathWithParams>;\nvar TFun:JsonTypeKind<JsonFunctionSignature>;\nvar TAnonymous:JsonTypeKind<JsonAnon>;\nvar TDynamic:JsonTypeKind<Null<JsonType<Dynamic>>>;\n}\n\ntypedef JsonType<T> = {\nvar kind:JsonTypeKind<T>;\nvar args:T;\n}\n\ntypedef JsonTypes = Array<JsonType<Dynamic>>;\n\n/* Type parameters */\ntypedef JsonTypeParameter = {\nvar name:String;\nvar constraints:JsonTypes;\n}\n\ntypedef JsonTypeParameters = Array<JsonTypeParameter>;\n\n/* Expr",
    "path": "haxe\\std\\haxe\\display\\JsonModuleTypes.hx",
    "functions": {},
    "fields": {
      "Unimported": "The type is currently not imported. It can be accessed either\nwith its fully qualified name or by inserting an import.\n",
      "Shadowed": "A type with the same name is already imported in the module.\nThe fully qualified name has to be used to access it.\n"
    }
  },
  "haxe.ds.ArraySort": {
    "doc": "ArraySort provides a stable implementation of merge sort through its `sort`\nmethod. It should be used instead of `Array.sort` in cases where the order\nof equal elements has to be retained on all targets.\n",
    "path": "haxe\\std\\haxe\\ds\\ArraySort.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.BalancedTree": {
    "doc": "BalancedTree allows key-value mapping with arbitrary keys, as long as they\ncan be ordered. By default, `Reflect.compare` is used in the `compare`\nmethod, which can be overridden in subclasses.\n\nOperations have a logarithmic average and worst-case cost.\n\nIteration over keys and values, using `keys` and `iterator` respectively,\nare in-order.\n",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.TreeNode": {
    "doc": "Creates a new BalancedTree, which is initially empty.\n*/\npublic function new() {}\n\n/**\nBinds `key` to `value`.\n\nIf `key` is already bound to a value, that binding disappears.\n\nIf `key` is null, the result is unspecified.\n*/\npublic function set(key:K, value:V) {\nroot = setLoop(key, value, root);\n}\n\n/**\nReturns the value `key` is bound to.\n\nIf `key` is not bound to any value, `null` is returned.\n\nIf `key` is null, the result is unspecified.\n*/\npublic function get(key:K):Null<V> {\nvar node = root;\nwhile (node != null) {\nvar c = compare(key, node.key);\nif (c == 0)\nreturn node.value;\nif (c < 0)\nnode = node.left;\nelse\nnode = node.right;\n}\nreturn null;\n}\n\n/**\nRemoves the current binding of `key`.\n\nIf `key` has no binding, `this` BalancedTree is unchanged and false is\nreturned.\n\nOtherwise the binding of `key` is removed and true is returned.\n\nIf `key` is null, the result is unspecified.\n*/\npublic function remove(key:K) {\ntry {\nroot = removeLoop(key, root);\nreturn true;\n} catch (e:String) {\nreturn false;\n}\n}\n\n/**\nTells if `key` is bound to a value.\n\nThis method returns true even if `key` is bound to null.\n\nIf `key` is null, the result is unspecified.\n*/\npublic function exists(key:K) {\nvar node = root;\nwhile (node != null) {\nvar c = compare(key, node.key);\nif (c == 0)\nreturn true;\nelse if (c < 0)\nnode = node.left;\nelse\nnode = node.right;\n}\nreturn false;\n}\n\n/**\nIterates over the bound values of `this` BalancedTree.\n\nThis operation is performed in-order.\n*/\npublic function iterator():Iterator<V> {\nvar ret = [];\niteratorLoop(root, ret);\nreturn ret.iterator();\n}\n\n/**\nSee `Map.keyValueIterator`\n*/\n@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\nreturn new haxe.iterators.MapKeyValueIterator(this);\n}\n\n/**\nIterates over the keys of `this` BalancedTree.\n\nThis operation is performed in-order.\n*/\npublic function keys():Iterator<K> {\nvar ret = [];\nkeysLoop(root, ret);\nreturn ret.iterator();\n}\n\npublic function copy():BalancedTree<K, V> {\nvar copied = new BalancedTree<K, V>();\ncopied.root = root;\nreturn copied;\n}\n\nfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\nif (node == null)\nreturn new TreeNode<K, V>(null, k, v, null);\nvar c = compare(k, node.key);\nreturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\nvar nl = setLoop(k, v, node.left);\nbalance(nl, node.key, node.value, node.right);\n} else {\nvar nr = setLoop(k, v, node.right);\nbalance(node.left, node.key, node.value, nr);\n}\n}\n\nfunction removeLoop(k:K, node:TreeNode<K, V>) {\nif (node == null)\nthrow \"Not_found\";\nvar c = compare(k, node.key);\nreturn if (c == 0) merge(node.left,\nnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\nnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n}\n\nstatic function iteratorLoop<K,V>(node:TreeNode<K, V>, acc:Array<V>) {\nif (node != null) {\niteratorLoop(node.left, acc);\nacc.push(node.value);\niteratorLoop(node.right, acc);\n}\n}\n\nfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\nif (node != null) {\nkeysLoop(node.left, acc);\nacc.push(node.key);\nkeysLoop(node.right, acc);\n}\n}\n\nstatic function sizeLoop<K,V>(node:TreeNode<K, V>):Int {\nif (node != null) {\nreturn sizeLoop(node.left) + 1 + sizeLoop(node.right);\n} else {\nreturn 0;\n}\n}\n\nfunction merge(t1, t2) {\nif (t1 == null)\nreturn t2;\nif (t2 == null)\nreturn t1;\nvar t = minBinding(t2);\nreturn balance(t1, t.key, t.value, removeMinBinding(t2));\n}\n\nfunction minBinding(t:TreeNode<K, V>) {\nreturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n}\n\nfunction removeMinBinding(t:TreeNode<K, V>) {\nreturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n}\n\nfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\nvar hl = l.get_height();\nvar hr = r.get_height();\nreturn if (hl > hr + 2) {\nif (l.left.get_height() >= l.right.get_height())\nnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\nelse\nnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\nnew TreeNode<K, V>(l.right.right, k, v, r));\n} else if (hr > hl + 2) {\nif (r.right.get_height() > r.left.get_height())\nnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\nelse\nnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\nnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n} else {\nnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n}\n}\n\nfunction compare(k1:K, k2:K) {\nreturn Reflect.compare(k1, k2);\n}\n\npublic function toString() {\nreturn root == null ? \"[]\" : '[${root.toString()}]';\n}\n\n/**\nRemoves all keys from `this` BalancedTree.\n*/\npublic function clear():Void {\nroot = null;\n}\n\npublic function size():Int {\nreturn sizeLoop(root);\n}\n}\n\n/**\nA tree node of `haxe.ds.BalancedTree`.\n",
    "path": "haxe\\std\\haxe\\ds\\BalancedTree.hx",
    "functions": {
      "set": "Binds `key` to `value`.\n\nIf `key` is already bound to a value, that binding disappears.\n\nIf `key` is null, the result is unspecified.\n",
      "get": "Returns the value `key` is bound to.\n\nIf `key` is not bound to any value, `null` is returned.\n\nIf `key` is null, the result is unspecified.\n",
      "remove": "Removes the current binding of `key`.\n\nIf `key` has no binding, `this` BalancedTree is unchanged and false is\nreturned.\n\nOtherwise the binding of `key` is removed and true is returned.\n\nIf `key` is null, the result is unspecified.\n",
      "exists": "Tells if `key` is bound to a value.\n\nThis method returns true even if `key` is bound to null.\n\nIf `key` is null, the result is unspecified.\n",
      "iterator": "Iterates over the bound values of `this` BalancedTree.\n\nThis operation is performed in-order.\n",
      "keys": "See `Map.keyValueIterator`\n*/\n@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\nreturn new haxe.iterators.MapKeyValueIterator(this);\n}\n\n/**\nIterates over the keys of `this` BalancedTree.\n\nThis operation is performed in-order.\n",
      "clear": "Removes all keys from `this` BalancedTree.\n"
    },
    "fields": {}
  },
  "haxe.ds.Either": {
    "doc": "Either represents values which are either of type `L` (Left) or type `R`\n(Right).\n",
    "path": "haxe\\std\\haxe\\ds\\Either.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.EnumValueMap": {
    "doc": "EnumValueMap allows mapping of enum value keys to arbitrary values.\n\nKeys are compared by value and recursively over their parameters. If any\nparameter is not an enum value, `Reflect.compare` is used to compare them.\n",
    "path": "haxe\\std\\haxe\\ds\\EnumValueMap.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.HashMap": {
    "doc": "HashMap allows mapping of hashable objects to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html\n",
    "path": "haxe\\std\\haxe\\ds\\HashMap.hx",
    "functions": {
      "exists": "See `Map.set`\n*/\n@:arrayAccess public inline function set(k:K, v:V) {\nthis.keys.set(k.hashCode(), k);\nthis.values.set(k.hashCode(), v);\n}\n\n/**\nSee `Map.get`\n*/\n@:arrayAccess public inline function get(k:K) {\nreturn this.values.get(k.hashCode());\n}\n\n/**\nSee `Map.exists`\n",
      "remove": "See `Map.remove`\n",
      "keys": "See `Map.keys`\n",
      "copy": "See `Map.copy`\n",
      "iterator": "See `Map.iterator`\n",
      "keyValueIterator": "See `Map.keyValueIterator`\n",
      "clear": "See `Map.clear`\n",
      "size": "See `Map.size`\n"
    },
    "fields": {}
  },
  "haxe.ds.IntMap": {
    "doc": "IntMap allows mapping of Int keys to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html\n",
    "path": "haxe\\std\\haxe\\ds\\IntMap.hx",
    "functions": {
      "set": "See `Map.set`\n",
      "get": "See `Map.get`\n",
      "exists": "See `Map.exists`\n",
      "remove": "See `Map.remove`\n",
      "keys": "See `Map.keys`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "iterator": "See `Map.iterator`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<Int, T> {\nreturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<Int, T>;\n#end\n\n/**\nSee `Map.copy`\n",
      "toString": "See `Map.toString`\n",
      "clear": "See `Map.clear`\n"
    },
    "fields": {}
  },
  "haxe.ds.List": {
    "doc": "A linked-list of elements. The list is composed of element container objects\nthat are chained together. It is optimized so that adding or removing an\nelement does not imply copying the whole list content every time.\n\n@see https://haxe.org/manual/std-List.html\n",
    "path": "haxe\\std\\haxe\\ds\\List.hx",
    "functions": {
      "add": "Adds element `item` at the end of `this` List.\n\n`this.length` increases by 1.\n",
      "push": "Adds element `item` at the beginning of `this` List.\n\n`this.length` increases by 1.\n",
      "first": "Returns the first element of `this` List, or null if no elements exist.\n\nThis function does not modify `this` List.\n",
      "last": "Returns the last element of `this` List, or null if no elements exist.\n\nThis function does not modify `this` List.\n",
      "pop": "Returns the first element of `this` List, or null if no elements exist.\n\nThe element is removed from `this` List.\n",
      "isEmpty": "Tells if `this` List is empty.\n",
      "clear": "Empties `this` List.\n\nThis function does not traverse the elements, but simply sets the\ninternal references to null and `this.length` to 0.\n",
      "remove": "Removes the first occurrence of `v` in `this` List.\n\nIf `v` is found by checking standard equality, it is removed from `this`\nList and the function returns true.\n\nOtherwise, false is returned.\n",
      "iterator": "Returns an iterator on the elements of the list.\n",
      "toString": "Returns an iterator of the List indices and values.\n*/\n@:pure @:runtime public inline function keyValueIterator():ListKeyValueIterator<T> {\nreturn new ListKeyValueIterator(h);\n}\n\n/**\nReturns a string representation of `this` List.\n\nThe result is enclosed in { } with the individual elements being\nseparated by a comma.\n",
      "join": "Returns a string representation of `this` List, with `sep` separating\neach element.\n",
      "filter": "Returns a list filtered with `f`. The returned list will contain all\nelements for which `f(x) == true`.\n",
      "map": "Returns a new list where all elements have been converted by the\nfunction `f`.\n"
    },
    "fields": {}
  },
  "haxe.ds.ListSort": {
    "doc": "ListSort provides a stable implementation of merge sort through its `sort`\nmethod. It has a O(N.log(N)) complexity and does not require additional memory allocation.\n",
    "path": "haxe\\std\\haxe\\ds\\ListSort.hx",
    "functions": {
      "sortSingleLinked": "Same as `sort` but on single linked list.\n"
    },
    "fields": {}
  },
  "haxe.ds.ObjectMap": {
    "doc": "ObjectMap allows mapping of object keys to arbitrary values.\n\nOn static targets, the keys are considered to be strong references. Refer\nto `haxe.ds.WeakMap` for a weak reference version.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html\n",
    "path": "haxe\\std\\haxe\\ds\\ObjectMap.hx",
    "functions": {
      "set": "See `Map.set`\n",
      "get": "See `Map.get`\n",
      "exists": "See `Map.exists`\n",
      "remove": "See `Map.remove`\n",
      "keys": "See `Map.keys`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "iterator": "See `Map.iterator`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<K, V> {\nreturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<K, V>;\n#end\n\n/**\nSee `Map.copy`\n",
      "toString": "See `Map.toString`\n",
      "clear": "See `Map.clear`\n"
    },
    "fields": {}
  },
  "haxe.ds.Option": {
    "doc": "An Option is a wrapper type which can either have a value (Some) or not a\nvalue (None).\n\n@see https://haxe.org/manual/std-Option.html\n",
    "path": "haxe\\std\\haxe\\ds\\Option.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.ds.StringMap": {
    "doc": "StringMap allows mapping of String keys to arbitrary values.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html\n",
    "path": "haxe\\std\\haxe\\ds\\StringMap.hx",
    "functions": {
      "set": "See `Map.set`\n",
      "get": "See `Map.get`\n",
      "exists": "See `Map.exists`\n",
      "remove": "See `Map.remove`\n",
      "keys": "See `Map.keys`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "iterator": "See `Map.iterator`\n\n(java) Implementation detail: Do not `set()` any new value while\niterating, as it may cause a resize, which will break iteration.\n",
      "copy": "See `Map.keyValueIterator`\n*/\n#if eval\n@:runtime inline function keyValueIterator():KeyValueIterator<String, T> {\nreturn new haxe.iterators.MapKeyValueIterator(this);\n}\n#else\nfunction keyValueIterator():KeyValueIterator<String, T>;\n#end\n\n/**\nSee `Map.copy`\n",
      "toString": "See `Map.toString`\n",
      "clear": "See `Map.clear`\n"
    },
    "fields": {}
  },
  "haxe.ds.Vector": {
    "doc": "A Vector is a storage of fixed size. It can be faster than Array on some\ntargets, and is never slower.\n\n@see https://haxe.org/manual/std-vector.html\n",
    "path": "haxe\\std\\haxe\\ds\\Vector.hx",
    "functions": {
      "toData": "Copies `length` of elements from `src` Vector, beginning at `srcPos` to\n`dest` Vector, beginning at `destPos`\n\nThe results are unspecified if `length` results in out-of-bounds access,\nor if `src` or `dest` are null\n*/\npublic static #if (java || neko || cpp || eval) inline #end function blit<T>(src:Vector<T>, srcPos:Int, dest:Vector<T>, destPos:Int, len:Int):Void {\n#if neko\nuntyped __dollar__ablit(dest, destPos, src, srcPos, len);\n#elseif java\njava.lang.System.arraycopy(src, srcPos, dest, destPos, len);\n#elseif cpp\ndest.toData().blit(destPos, src.toData(), srcPos, len);\n#elseif eval\nsrc.toData().blit(srcPos, dest.toData(), destPos, len);\n#else\nif (src == dest) {\nif (srcPos < destPos) {\nvar i = srcPos + len;\nvar j = destPos + len;\nfor (k in 0...len) {\ni--;\nj--;\nsrc[j] = src[i];\n}\n} else if (srcPos > destPos) {\nvar i = srcPos;\nvar j = destPos;\nfor (k in 0...len) {\nsrc[j] = src[i];\ni++;\nj++;\n}\n}\n} else {\nfor (i in 0...len) {\ndest[destPos + i] = src[srcPos + i];\n}\n}\n#end\n}\n\n/**\nCreates a new Array, copy the content from the Vector to it, and returns it.\n*/\npublic #if (flash || cpp || js || java || eval) inline #end function toArray():Array<T> {\n#if cpp\nreturn this.copy();\n#elseif python\nreturn this.copy();\n#elseif js\nreturn this.slice(0);\n#elseif eval\nreturn this.toArray();\n#else\nvar a = new Array();\nvar len = length;\n#if (neko)\n// prealloc good size\nif (len > 0)\na[len - 1] = get(0);\n#end\nfor (i in 0...len)\na[i] = get(i);\nreturn a;\n#end\n}\n\n/**\nExtracts the data of `this` Vector.\n\nThis returns the internal representation type.\n",
      "fromData": "Initializes a new Vector from `data`.\n\nSince `data` is the internal representation of Vector, this is a no-op.\n\nIf `data` is null, the corresponding Vector is also `null`.\n",
      "fromArrayCopy": "Creates a new Vector by copying the elements of `array`.\n\nThis always creates a copy, even on platforms where the internal\nrepresentation is Array.\n\nThe elements are not copied and retain their identity, so\n`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.\n\nIf `array` is null, the result is unspecified.\n",
      "sort": "Returns a shallow copy of `this` Vector.\n\nThe elements are not copied and retain their identity, so\n`a[i] == a.copy()[i]` is true for any valid `i`. However,\n`a == a.copy()` is always false.\n*/\nextern public inline function copy<T>():Vector<T> {\n#if eval\nreturn fromData(this.copy());\n#else\nvar r = new Vector<T>(length);\nVector.blit(cast this, 0, r, 0, length);\nreturn r;\n#end\n}\n\n/**\nReturns a string representation of `this` Vector, with `sep` separating\neach element.\n\nThe result of this operation is equal to `Std.string(this[0]) + sep +\nStd.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`\n\nIf `this` Vector has length 0, the result is the empty String `\"\"`.\nIf `this` has exactly one element, the result is equal to a call to\n`Std.string(this[0])`.\n\nIf `sep` is null, the result is unspecified.\n*/\nextern public inline function join<T>(sep:String):String {\n#if (flash10 || cpp || eval)\nreturn this.join(sep);\n#else\nvar b = new StringBuf();\nvar len = length;\nfor (i in 0...len) {\nb.add(Std.string(get(i)));\nif (i < len - 1) {\nb.add(sep);\n}\n}\nreturn b.toString();\n#end\n}\n\n/**\nCreates a new Vector by applying function `f` to all elements of `this`.\n\nThe order of elements is preserved.\n\nIf `f` is null, the result is unspecified.\n*/\nextern public inline function map<S>(f:T->S):Vector<S> {\n#if eval\nreturn fromData(this.map(f));\n#else\nvar length = length;\nvar r = new Vector<S>(length);\nvar len = length;\nfor (i in 0...len) {\nvar v = f(get(i));\nr.set(i, v);\n}\nreturn r;\n#end\n}\n\n/**\nSorts `this` Vector according to the comparison function `f`, where\n`f(x,y)` returns 0 if x == y, a positive Int if x > y and a\nnegative Int if x < y.\n\nThis operation modifies `this` Vector in place.\n\nThe sort operation is not guaranteed to be stable, which means that the\norder of equal elements may not be retained.\n\nIf `f` is null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "haxe.ds.WeakMap": {
    "doc": "WeakMap allows mapping of object keys to arbitrary values.\n\nThe keys are considered to be weak references on static targets.\n\nSee `Map` for documentation details.\n\n@see https://haxe.org/manual/std-Map.html\n",
    "path": "haxe\\std\\haxe\\ds\\WeakMap.hx",
    "functions": {
      "set": "See `Map.set`\n",
      "get": "See `Map.get`\n",
      "exists": "See `Map.exists`\n",
      "remove": "See `Map.remove`\n",
      "keys": "See `Map.keys`\n",
      "iterator": "See `Map.iterator`\n",
      "keyValueIterator": "See `Map.keyValueIterator`\n",
      "copy": "See `Map.copy`\n",
      "toString": "See `Map.toString`\n",
      "clear": "See `Map.clear`\n",
      "size": "See `Map.size`\n"
    },
    "fields": {}
  },
  "haxe.exceptions.ArgumentException": {
    "doc": "An exception that is thrown when an invalid value provided for an argument of a function.\n",
    "path": "haxe\\std\\haxe\\exceptions\\ArgumentException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.NotImplementedException": {
    "doc": "An exception that is thrown when requested function or operation does not have an implementation.\n",
    "path": "haxe\\std\\haxe\\exceptions\\NotImplementedException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.exceptions.PosException": {
    "doc": "An exception that carry position information of a place where it was created.\n",
    "path": "haxe\\std\\haxe\\exceptions\\PosException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonParser": {
    "doc": "An implementation of JSON parser in Haxe.\n\nThis class is used by `haxe.Json` when native JSON implementation\nis not available.\n\n@see https://haxe.org/manual/std-Json-parsing.html\n",
    "path": "haxe\\std\\lua\\_std\\haxe\\format\\JsonParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.format.JsonPrinter": {
    "doc": "An implementation of JSON printer in Haxe.\n\nThis class is used by `haxe.Json` when native JSON implementation\nis not available.\n\n@see https://haxe.org/manual/std-Json-encoding.html\n",
    "path": "haxe\\std\\haxe\\format\\JsonPrinter.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.http.HttpBase": {
    "doc": "This class can be used to handle Http requests consistently across\nplatforms. There are two intended usages:\n\n- call `haxe.Http.requestUrl(url)` and receive the result as a `String`\n(only available on `sys` targets)\n- create a `new haxe.Http(url)`, register your callbacks for `onData`,\n`onError` and `onStatus`, then call `request()`.\n",
    "path": "haxe\\std\\haxe\\http\\HttpBase.hx",
    "functions": {
      "setHeader": "Sets the header identified as `name` to value `value`.\n\nIf `name` or `value` are null, the result is unspecified.\n\nThis method provides a fluent interface.\n",
      "setParameter": "Sets the parameter identified as `name` to value `value`.\n\nIf `name` or `value` are null, the result is unspecified.\n\nThis method provides a fluent interface.\n",
      "setPostData": "Sets the post data of `this` Http request to `data` string.\n\nThere can only be one post data per request. Subsequent calls to\nthis method or to `setPostBytes()` overwrite the previously set value.\n\nIf `data` is null, the post data is considered to be absent.\n\nThis method provides a fluent interface.\n",
      "setPostBytes": "Sets the post data of `this` Http request to `data` bytes.\n\nThere can only be one post data per request. Subsequent calls to\nthis method or to `setPostData()` overwrite the previously set value.\n\nIf `data` is null, the post data is considered to be absent.\n\nThis method provides a fluent interface.\n",
      "request": "Sends `this` Http request to the Url specified by `this.url`.\n\nIf `post` is true, the request is sent as POST request, otherwise it is\nsent as GET request.\n\nDepending on the outcome of the request, this method calls the\n`onStatus()`, `onError()`, `onData()` or `onBytes()` callback functions.\n\nIf `this.url` is null, the result is unspecified.\n\nIf `this.url` is an invalid or inaccessible Url, the `onError()` callback\nfunction is called.\n\n[js] If `this.async` is false, the callback functions are called before\nthis method returns.\n",
      "hasOnData": "This method is called upon a successful request, with `data` containing\nthe result String.\n\nThe intended usage is to bind it to a custom function:\n`httpInstance.onData = function(data) { // handle result }`\n*/\npublic dynamic function onData(data:String) {}\n\n/**\nThis method is called upon a successful request, with `data` containing\nthe result String.\n\nThe intended usage is to bind it to a custom function:\n`httpInstance.onBytes = function(data) { // handle result }`\n*/\npublic dynamic function onBytes(data:Bytes) {}\n\n/**\nThis method is called upon a request error, with `msg` containing the\nerror description.\n\nThe intended usage is to bind it to a custom function:\n`httpInstance.onError = function(msg) { // handle error }`\n*/\npublic dynamic function onError(msg:String) {}\n\n/**\nThis method is called upon a Http status change, with `status` being the\nnew status.\n\nThe intended usage is to bind it to a custom function:\n`httpInstance.onStatus = function(status) { // handle status }`\n*/\npublic dynamic function onStatus(status:Int) {}\n\n/**\nOverride this if extending `haxe.Http` with overriding `onData`\n"
    },
    "fields": {}
  },
  "haxe.http.abstract": {
    "doc": "HTTP Request Status\n",
    "path": "haxe\\std\\haxe\\http\\HttpStatus.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Encoding": {
    "doc": "String binary encoding supported by Haxe I/O\n",
    "path": "haxe\\std\\haxe\\io\\Encoding.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Eof": {
    "doc": "This exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n",
    "path": "haxe\\std\\haxe\\io\\Eof.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.FPHelper": {
    "doc": "Helper that converts between floating point and binary representation.\nAlways works in low-endian encoding.\n",
    "path": "haxe\\std\\haxe\\io\\FPHelper.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.class": {
    "doc": "An Output is an abstract write. A specific output implementation will only\nhave to override the `writeByte` and maybe the `write`, `flush` and `close`\nmethods. See `File.write` and `String.write` for two ways of creating an\nOutput.\n",
    "path": "haxe\\std\\haxe\\io\\Output.hx",
    "functions": {
      "writeBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\nReturns the actual length of written data that can differ from `len`.\n\nSee `writeFullBytes` that tries to write the exact amount of specified bytes.\n",
      "flush": "Flush any buffered data.\n",
      "close": "Close the output.\n\nBehaviour while writing after calling this method is unspecified.\n",
      "write": "Write all bytes stored in `s`.\n",
      "writeFullBytes": "Write `len` bytes from `s` starting by position specified by `pos`.\n\nUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.\n",
      "writeFloat": "Write `x` as 32-bit floating point number.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeDouble": "Write `x` as 64-bit double-precision floating point number.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeInt8": "Write `x` as 8-bit signed integer.\n",
      "writeInt16": "Write `x` as 16-bit signed integer.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeUInt16": "Write `x` as 16-bit unsigned integer.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeInt24": "Write `x` as 24-bit signed integer.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeUInt24": "Write `x` as 24-bit unsigned integer.\n\nEndianness is specified by the `bigEndian` property.\n",
      "writeInt32": "Write `x` as 32-bit signed integer.\n\nEndianness is specified by the `bigEndian` property.\n",
      "prepare": "Inform that we are about to write at least `nbytes` bytes.\n\nThe underlying implementation can allocate proper working space depending\non this information, or simply ignore it. This is not a mandatory call\nbut a tip and is only used in some specific cases.\n",
      "writeInput": "Read all available data from `i` and write it.\n\nThe `bufsize` optional argument specifies the size of chunks by\nwhich data is read and written. Its default value is 4096.\n",
      "writeString": "Write `s` string.\n"
    },
    "fields": {}
  },
  "haxe.io.abstract": {
    "doc": "A scheme consists of a sequence of characters beginning with a letter and followed\nby any combination of letters, digits, plus (`+`, period (`.`), or hyphen (`-`).\n\nAlthough schemes are case-insensitive, the canonical form is lowercase\nand documents that specify schemes must do so with lowercase letters.\nIt is followed by a colon (`:`).\n",
    "path": "haxe\\std\\haxe\\io\\Scheme.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.io.Path": {
    "doc": "This class provides a convenient way of working with paths. It supports the\ncommon path formats:\n\n- `directory1/directory2/filename.extension`\n- `directory1\\directory2\\filename.extension`\n",
    "path": "haxe\\std\\haxe\\io\\Path.hx",
    "functions": {
      "toString": "Returns a String representation of `this` path.\n\nIf `this.backslash` is `true`, backslash is used as directory separator,\notherwise slash is used. This only affects the separator between\n`this.dir` and `this.file`.\n\nIf `this.directory` or `this.extension` is `null`, their representation\nis the empty String `\"\"`.\n",
      "withoutExtension": "Returns the String representation of `path` without the file extension.\n\nIf `path` is `null`, the result is unspecified.\n",
      "withoutDirectory": "Returns the String representation of `path` without the directory.\n\nIf `path` is `null`, the result is unspecified.\n",
      "directory": "Returns the directory of `path`.\n\nIf the directory is `null`, the empty String `\"\"` is returned.\n\nIf `path` is `null`, the result is unspecified.\n",
      "extension": "Returns the extension of `path`.\n\nIf `path` has no extension, the empty String `\"\"` is returned.\n\nIf `path` is `null`, the result is unspecified.\n",
      "withExtension": "Returns a String representation of `path` where the extension is `ext`.\n\nIf `path` has no extension, `ext` is added as extension.\n\nIf `path` or `ext` are `null`, the result is unspecified.\n",
      "join": "Joins all paths in `paths` together.\n\nIf `paths` is empty, the empty String `\"\"` is returned. Otherwise the\npaths are joined with a slash between them.\n\nIf `paths` is `null`, the result is unspecified.\n",
      "normalize": "Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).\n\nAlso replaces backslashes `\\` with slashes `/` and afterwards turns\nmultiple slashes into a single one.\n\nIf `path` is `null`, the result is unspecified.\n",
      "addTrailingSlash": "Adds a trailing slash to `path`, if it does not have one already.\n\nIf the last slash in `path` is a backslash, a backslash is appended to\n`path`.\n\nIf the last slash in `path` is a slash, or if no slash is found, a slash\nis appended to `path`. In particular, this applies to the empty String\n`\"\"`.\n\nIf `path` is `null`, the result is unspecified.\n",
      "removeTrailingSlashes": "Removes trailing slashes from `path`.\n\nIf `path` does not end with a `/` or `\\`, `path` is returned unchanged.\n\nOtherwise the substring of `path` excluding the trailing slashes or\nbackslashes is returned.\n\nIf `path` is `null`, the result is unspecified.\n",
      "isAbsolute": "Returns `true` if the path is an absolute path, and `false` otherwise.\n"
    },
    "fields": {
      "file": "The file name.\n\nThis is the part of the part between the directory and the extension.\n\nIf there is no file name, e.g. for `\".htaccess\"` or `\"/dir/\"`, the value\nis the empty String `\"\"`.\n",
      "ext": "The file extension.\n\nIt is separated from the file name by a dot. This dot is not part of\nthe extension.\n\nIf the path has no extension, the value is `null`.\n",
      "backslash": "`true` if the last directory separator is a backslash, `false` otherwise.\n"
    }
  },
  "haxe.iterators.ArrayIterator": {
    "doc": "This iterator is used only when `Array<T>` is passed to `Iterable<T>`\n",
    "path": "haxe\\std\\haxe\\iterators\\ArrayIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`\n",
      "next": "See `Iterator.next`\n"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessIterator": {
    "doc": "This iterator can be used to iterate over the values of `haxe.DynamicAccess`.\n",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessIterator.hx",
    "functions": {
      "next": "See `Iterator.next`\n"
    },
    "fields": {}
  },
  "haxe.iterators.DynamicAccessKeyValueIterator": {
    "doc": "This Key/Value iterator can be used to iterate over `haxe.DynamicAccess`.\n",
    "path": "haxe\\std\\haxe\\iterators\\DynamicAccessKeyValueIterator.hx",
    "functions": {
      "next": "See `Iterator.next`\n"
    },
    "fields": {}
  },
  "haxe.iterators.StringIterator": {
    "doc": "This iterator can be used to iterate over char codes in a string.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different of runtimes.\n",
    "path": "haxe\\std\\haxe\\iterators\\StringIterator.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`\n",
      "next": "See `Iterator.next`\n"
    },
    "fields": {}
  },
  "haxe.iterators.StringIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\nway. It handles surrogate pairs on platforms that require it. On each\niteration, it returns the next character code.\n\nNote that this has different semantics than a standard for-loop over the\nString's length due to the fact that it deals with surrogate pairs.\n",
    "path": "haxe\\std\\haxe\\iterators\\StringIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`\n",
      "next": "See `Iterator.next`\n",
      "unicodeIterator": "Convenience function which can be used as a static extension.\n"
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIterator": {
    "doc": "This iterator can be used to iterate over char indexes and char codes in a string.\n\nNote that char codes may differ across platforms because of different\ninternal encoding of strings in different runtimes.\n",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIterator.hx",
    "functions": {
      "hasNext": "See `KeyValueIterator.hasNext`\n",
      "next": "See `KeyValueIterator.next`\n"
    },
    "fields": {}
  },
  "haxe.iterators.StringKeyValueIteratorUnicode": {
    "doc": "This iterator can be used to iterate across strings in a cross-platform\nway. It handles surrogate pairs on platforms that require it. On each\niteration, it returns the next character offset as key and the next\ncharacter code as value.\n\nNote that in the general case, because of surrogate pairs, the key values\nshould not be used as offsets for various String API operations. For the\nsame reason, the last key value returned might be less than `s.length - 1`.\n",
    "path": "haxe\\std\\haxe\\iterators\\StringKeyValueIteratorUnicode.hx",
    "functions": {
      "hasNext": "See `Iterator.hasNext`\n",
      "next": "See `Iterator.next`\n",
      "unicodeKeyValueIterator": "Convenience function which can be used as a static extension.\n"
    },
    "fields": {}
  },
  "haxe.macro.CompilationServer": {
    "doc": "Disables file modification checks, avoiding some filesystem operations.\n*/\nvar NoFileSystemCheck = 0;\n\n/**\nDefault behavior: check last modification time.\n*/\nvar CheckFileModificationTime = 1;\n\n/**\nIf a file is modified, also checks if its content changed. This check\nis not free, but useful when .hx files are auto-generated.\n*/\nvar CheckFileContentModification = 2;\n}\n\ntypedef CompilationStats = {\nvar filesParsed:Int;\nvar modulesTyped:Int;\nvar modulesRestoredFromHxb:Int;\nvar classesBuilt:Int;\nvar methodsTyped:Int;\nvar macrosCalled:Int;\n}\n\n/**\nThis class provides some methods which can be invoked from command line using\n`--macro server.field(args)`.\n",
    "path": "haxe\\std\\haxe\\macro\\CompilationServer.hx",
    "functions": {
      "invalidateModule": "Invalidates a module, removing it from the cache.\n\nIf the module has already been loaded in current context, a\n`haxe.macro.Expr.Error` compiler error will be raised which can be\ncaught using `try ... catch`.\n",
      "invalidateFiles": "Invalidates all files given in `filePaths`, removing them from the cache.\n",
      "getStats": "Get current compilation server stats counters.\n\nCan be called at different compilation stages, or even in the middle of\na macro execution.\n\nCounters are reset at the beginning of each request.\n"
    },
    "fields": {
      "CheckFileModificationTime": "Default behavior: check last modification time.\n",
      "CheckFileContentModification": "If a file is modified, also checks if its content changed. This check\nis not free, but useful when .hx files are auto-generated.\n"
    }
  },
  "haxe.macro.Compiler": {
    "doc": "All these methods can be called for compiler configuration macros.\n",
    "path": "haxe\\std\\haxe\\macro\\Compiler.hx",
    "functions": {
      "define": "Set a conditional compiler flag.\n\nUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n",
      "addClassPath": "Add a class path where \".hx\" source files or packages (sub-directories) can be found.\n\nUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n",
      "getConfiguration": "Returns all the configuration settings applied to the compiler.\n\nUsage of this function outside a macro context returns `null`.\n",
      "setPlatformConfiguration": "Sets the target configuration.\n\nUsage of this function outside a macro context does nothing.\n",
      "addNativeLib": "Adds a native library depending on the platform (e.g. `-swf-lib` for Flash).\n\nUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n",
      "include": "Includes all modules in package `pack` in the compilation.\n\nIn order to include single modules, their paths can be listed directly\non command line: `haxe ... ModuleName pack.ModuleName`.\n\nBy default `Compiler.include` will search for modules in the directories defined with `-cp`.\nIf you want to specify a different set of paths to search for modules, you can use the optional\nargument `classPath`.\n\nUsage of this function outside of initialization macros is deprecated and may cause compilation server issues.\n\n@param pack The package dot-path as String. Use `''` to include the root package.\n@param rec If true, recursively adds all sub-packages.\n@param ignore Array of module names to ignore for inclusion.\nYou can use `module*` with a * at the end for Wildcard matching\n@param classPaths An alternative array of paths (directory names) to use to search for modules to include.\nNote that if you pass this argument, only the specified paths will be used for inclusion.\n@param strict If true and given package wasn't found in any of class paths, fail with an error.\n",
      "excludeBaseType": "Exclude a class or an enum without changing it to `@:nativeGen`.\n",
      "exclude": "Exclude a specific class, enum, or all classes and enums in a\npackage from being generated. Excluded types become `extern`.\n\n@param pack The package dot-path as String. Use `''` to exclude the root package.\n@param rec If true, recursively excludes all sub-packages.\n",
      "excludeFile": "Exclude classes and enums listed in an extern file (one per line) from being generated.\n",
      "keep": "Marks types or packages to be kept by DCE.\n\nThis also extends to the sub-types of resolved modules.\n\nIn order to include module sub-types directly, their full dot path\nincluding the containing module has to be used\n(e.g. `msignal.Signal.Signal0`).\n\nThis operation has no effect if the type has already been loaded, e.g.\nthrough `Context.getType`.\n\n@param path A package, module or sub-type dot path to keep.\n@param paths An Array of package, module or sub-type dot paths to keep.\n@param recursive If true, recurses into sub-packages for package paths.\n",
      "nullSafety": "Enables null safety for a type or a package.\n\n@param path A package, module or sub-type dot path to enable null safety for.\n@param recursive If true, recurses into sub-packages for package paths.\n",
      "addGlobalMetadata": "Adds metadata `meta` to all types (if `toTypes = true`) or fields (if\n`toFields = true`) whose dot-path matches `pathFilter`.\n\nIf `recursive` is true a dot-path is considered matched if it starts\nwith `pathFilter`. This automatically applies to path filters of\npackages. Otherwise an exact match is required.\n\nIf `pathFilter` is the empty String `\"\"` it matches everything (if\n`recursive = true`) or only top-level types (if `recursive = false`).\n\nThis operation has no effect if the type has already been loaded, e.g.\nthrough `Context.getType`.\n",
      "registerMetadataDescriptionFile": "Reference a json file describing user-defined metadata\nSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/meta.json\n",
      "registerDefinesDescriptionFile": "Reference a json file describing user-defined defines\nSee https://github.com/HaxeFoundation/haxe/blob/development/src-json/define.json\n",
      "registerCustomMetadata": "Register a custom metadata for documentation and completion purposes\n",
      "registerCustomDefine": "Register a custom define for documentation purposes\n",
      "setCustomJSGenerator": "Change the default JS output by using a custom generator callback\n",
      "flushDiskCache": "Clears cached results of file lookups\n",
      "getHxbWriterConfiguration": "Gets the current hxb writer configuration, if any.\n",
      "setHxbWriterConfiguration": "Sets the hxb writer configuration to `config`. If no hxb writer configuration\nexists, it is created.\n\nThe intended usage is\n\n```\nvar config = Compiler.getHxbWriterConfiguration();\nconfig.archivePath = \"newPath.zip\";\n// Other changes\nCompiler.setHxbWriterConfiguration(config);\n```\n\nIf `config` is `null`, hxb writing is disabled.\n\n@see haxe.hxb.WriterConfig\n"
    },
    "fields": {
      "Closure": "Prepend the file content to the body of the top-level closure.\n\nSince the closure is in strict-mode, there may be run-time error if the input is not strict-mode-compatible.\n",
      "Inline": "Directly inject the file content at the call site.\n",
      "Off": "Disable null safety.\n",
      "Loose": "Loose safety.\nIf an expression is checked `!= null`, then it's considered safe even if it could be modified after the check.\nE.g.\n```haxe\nfunction example(o:{field:Null<String>}) {\nif(o.field != null) {\nmutate(o);\nvar notNullable:String = o.field; //no error\n}\n}\n\nfunction mutate(o:{field:Null<String>}) {\no.field = null;\n}\n```\n",
      "Strict": "Full scale null safety.\nIf a field is checked `!= null` it stays safe until a call is made or any field of any object is reassigned,\nbecause that could potentially alter an object of the checked field.\nE.g.\n```haxe\nfunction example(o:{field:Null<String>}, b:{o:{field:Null<String>}}) {\nif(o.field != null) {\nvar notNullable:String = o.field; //no error\nsomeCall();\nvar notNullable:String = o.field; // Error!\n}\nif(o.field != null) {\nvar notNullable:String = o.field; //no error\nb.o = {field:null};\nvar notNullable:String = o.field; // Error!\n}\n}\n```\n",
      "StrictThreaded": "Full scale null safety for a multi-threaded environment.\nWith this mode checking a field `!= null` does not make it safe, because it could be changed from another thread\nat the same time or immediately after the check.\nThe only nullable thing could be safe are local variables.\n"
    }
  },
  "haxe.macro.ComplexTypeTools": {
    "doc": "This class provides some utility methods to work with AST-level types. It is\nbest used through `using haxe.macro.ComplexTypeTools` syntax and then provides\nadditional methods on `haxe.macro.ComplexType` instances.\n",
    "path": "haxe\\std\\haxe\\macro\\ComplexTypeTools.hx",
    "functions": {
      "toType": "Returns a type corresponding to `c`.\n\nIf `c` is null, the result is null.\n"
    },
    "fields": {}
  },
  "haxe.macro.Context": {
    "doc": "Context provides an API for macro programming.\n\nIt contains common functions that interact with the macro interpreter to\nquery or set information. Other API functions are available in the tools\nclasses:\n\n- `haxe.macro.ComplexTypeTools`\n- `haxe.macro.ExprTools`\n- `haxe.macro.TypeTools`\n",
    "path": "haxe\\std\\haxe\\macro\\Context.hx",
    "functions": {
      "fatalError": "Displays a compilation error `msg` at the given `Position` `pos`\nand aborts the compilation.\n",
      "reportError": "Displays a compilation error `msg` at the given `Position` `pos`\nwithout aborting the current macro call.\n",
      "warning": "Displays a compilation warning `msg` at the given `Position` `pos`.\n",
      "info": "Displays a compilation info `msg` at the given `Position` `pos`.\n",
      "getMessages": "Gets a list of all current compilation info/warning messages.\n",
      "filterMessages": "Filters all current info/warning messages. Filtered out messages will\nnot be displayed by the compiler.\n",
      "initMacrosDone": "Check if compiler is past initializations macros or not.\nWhen it is, configuration phase is over and parsing/typing can start.\n",
      "resolvePath": "Resolves a file name `file` based on the current class paths.\n\nThe resolution follows the usual class path rules where the last\ndeclared class path has priority.\n\nIf a class path was declared relative, this method returns the relative\nfile path. Otherwise it returns the absolute file path.\n\nIf no type can be found, an exception of type `String` is thrown.\n",
      "getClassPath": "Returns an `Array` of current class paths in the order of their\ndeclaration.\n\nModifying the returned array has no effect on the compiler. Class paths\ncan be added using `haxe.macro.Compiler.addClassPath`.\n",
      "containsDisplayPosition": "Check if current display position is within `pos`.\n",
      "currentPos": "Returns the position at which the macro was called.\n",
      "getMacroStack": "Get the call stack (excluding the call to `Context.getMacroStack()`\nthat led to current macro.\n",
      "getExpectedType": "Returns the type which is expected at the place the macro is called.\n\nThis affects usages such as `var x:Int = macroCall()`, where the\nexpected type will be reported as `Int`.\n\nMight return `null` if no specific type is expected or if the calling\nmacro is not an expression-macro.\n",
      "getCallArguments": "Returns the call arguments that lead to the invocation of the current\n`@:genericBuild` macro, if available.\n\nReturns `null` if the current macro is not a `@:genericBuild` macro.\n",
      "getLocalClass": "Returns the current class in which the macro was called.\n\nIf no such class exists, `null` is returned.\n",
      "getLocalModule": "Returns the current module path in/on which the macro was called.\n",
      "getLocalType": "Returns the current type in/on which the macro was called.\n\nIf no such type exists, `null` is returned.\n",
      "getLocalMethod": "Returns the name of the method from which the macro was called.\n\nIf no such method exists, `null` is returned.\n",
      "getLocalUsing": "Returns an `Array` of classes which are available for `using` usage in\nthe context the macro was called.\n\nModifying the returned array has no effect on the compiler.\n",
      "getLocalImports": "Returns an `Array` of all imports in the context the macro was called.\n\nModifying the returned array has no effect on the compiler.\n",
      "getLocalVars": "Returns a map of local variables accessible in the context the macro was\ncalled.\n\nThe keys of the returned map are the variable names, the values are\ntheir types.\n\nModifying the returned map has no effect on the compiler.\n",
      "getLocalTVars": "Similar to `getLocalVars`, but returns elements of type `TVar` instead\nof `Type`.\n",
      "defined": "Tells if the conditional compilation flag `s` has been set.\n\nCompiler flags are set using the `-D` command line parameter, or\nby calling `haxe.macro.Compiler.define`.\n\n@see https://haxe.org/manual/lf-condition-compilation.html\n",
      "definedValue": "Returns the value defined for the conditional compilation flag `key`.\n\nIf no value is defined for `key`, `null` is returned.\n\nCompiler flags values are set using the `-D key=value` command line\nparameter, or by calling `haxe.macro.Compiler.define`.\n\nThe default value is `\"1\"`.\n\n@see https://haxe.org/manual/lf-condition-compilation.html\n",
      "getDefines": "Returns a map of all conditional compilation flags that have been set.\n\nCompiler flags are set using the `-D` command line parameter, or\nby calling `haxe.macro.Compiler.define`.\n\nModifying the returned map has no effect on the compiler.\n\n@see https://haxe.org/manual/lf-condition-compilation.html\n",
      "getType": "Resolves a type identified by `name`.\n\nThe resolution follows the usual class path rules where the last\ndeclared class path has priority.\n\nIf no type can be found, an exception of type `String` is thrown.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "getModule": "Resolves a module identified by `name` and returns an `Array` of all\nits contained types.\n\nThe resolution follows the usual class path rules where the last\ndeclared class path has priority.\n\nIf no module can be found, an exception of type `String` is thrown.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "getMainExpr": "Returns the typed expression of the call to the main function.\n\nThis function will only work in the generation phase. Any calls\nmade outside a function passed to `haxe.macro.Context.onGenerate`\nor `haxe.macro.Context.onAfterGenerate` will return `null`.\n",
      "getAllModuleTypes": "Returns an array of module types to be generated in the output.\n\nThis list may change depending on the phase of compilation and\nshould not be treated as conclusive until the generation phase.\n\nModifying the returned array has no effect on the compilation.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "parse": "Parses `expr` as Haxe code, returning the corresponding AST.\n\nString interpolation of single quote strings within `expr` is not\nsupported.\n\nThe provided `Position` `pos` is used for all generated inner AST nodes.\n",
      "parseInlineString": "Similar to `parse`, but error positions are reported within the provided\nString `expr`.\n",
      "registerFileContents": "Parse file content for newlines, allowing positions to be resolved\nproperly inside that file later on (using `Context.parseInlineString`\nfor example). Works with both real and virtual files.\n",
      "makeExpr": "Builds an expression from `v`.\n\nThis method generates AST nodes depending on the macro-runtime value of\n`v`. As such, only basic types and enums are supported and the behavior\nfor other types is undefined.\n\nThe provided `Position` `pos` is used for all generated inner AST nodes.\n",
      "signature": "Returns a hashed MD5 signature of value `v`.\n",
      "onGenerate": "Adds a callback function `callback` which is invoked after the\ncompiler's typing phase, just before its generation phase.\n\nThe callback receives an `Array` containing all types which are about\nto be generated. Modifications are limited to metadata, it is mainly\nintended to obtain information.\n\nBy default, the callback is made before types are stored in the compilation\nserver, if active. This means that any effect persists for the next compilation.\nIf `persistent` is set to `false`, changes to types made by the callback only\naffect the current compilation. If no compilation server is used, this flag has\nno effect.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.\n",
      "onAfterGenerate": "Adds a callback function `callback` which is invoked after the compiler\ngeneration phase.\n\nCompilation has completed at this point and cannot be influenced\nanymore. However, contextual information is still available.\n\nNote*: the callback is still invoked when generation is disabled with  `--no-output`.\n",
      "onAfterTyping": "Adds a callback function `callback` which is invoked after the compiler\nis done typing, but before optimization. The callback receives the types\nwhich have been typed.\n\nIt is possible to define new types in the callback, in which case it\nwill be called again with the new types as argument.\n",
      "onAfterInitMacros": "Adds a callback function `callback` which is invoked after the compiler\nis done running initialization macros, when typing begins.\n\n`onAfterInitMacros` should be used to delay typer-dependant code from\nyour initialization macros, to properly separate configuration phase and\nactual typing.\n",
      "onTypeNotFound": "Adds a callback function `callback` which is invoked when a type name\ncannot be resolved.\n\nThe callback may return a type definition, which is then used for the\nexpected type. If it returns `null`, the type is considered to still not\nexist.\n",
      "typeof": "Types expression `e` and returns its type.\n\nTyping the expression may result in a compiler error which can be\ncaught using `try ... catch`.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "typeExpr": "Types expression `e` and returns the corresponding `TypedExpr`.\n\nTyping the expression may result in a compiler error which can be\ncaught using `try ... catch`. Note that not all compiler errors can\nbe caught this way because the compiler might delay various checks\nto a later stage, at which point the exception handler is no longer\nactive.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "resolveType": "Resolve type `t` and returns the corresponding `Type`.\n\nResolving the type may result in a compiler error which can be\ncaught using `try ... catch`.\nResolution is performed based on the current context in which the macro is called.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "resolveComplexType": "Resolve type `t` and returns the corresponding `ComplexType`.\n\nResolving the type may result in a compiler error which can be\ncaught using `try ... catch`.\nResolution is performed based on the current context in which the macro is called.\nThe difference with `resolveType` is that it only performs type resolution, it does not\nbuild any type or trigger macros.\n",
      "toComplexType": "Returns the `ComplexType` corresponding to the given `Type` `t`.\n\nSee `haxe.macro.TypeTools.toComplexType` for details.\n",
      "unify": "Tries to unify `t1` and `t2` and returns `true` if successful.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "follow": "Follows a type.\n\nSee `haxe.macro.TypeTools.follow` for details.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "followWithAbstracts": "Follows a type, including abstracts' underlying implementation\n\nSee `haxe.macro.TypeTools.followWithAbstracts` for details.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "getPosInfos": "Returns the information stored in `Position` `p`.\n",
      "makePosition": "Builds a `Position` from `inf`.\n",
      "getResources": "Returns a map of all registered resources for this compilation unit.\n\nModifying the returned map has no effect on the compilation, use\n`haxe.macro.Context.addResource` to add new resources to the compilation unit.\n",
      "addResource": "Makes resource `data` available as `name`.\n\nThe resource is then available using the `haxe.macro.Resource` API.\n\nIf a previous resource was bound to `name`, it is overwritten.\n\nCompilation server : when using the compilation server, the resource is bound\nto the Haxe module which calls the macro, so it will be included again if\nthat module is reused. If this resource concerns several modules, prefix its\nname with a `$` sign, this will bind it to the macro module instead.\n",
      "getBuildFields": "Returns an `Array` of fields of the class which is to be built.\n\nThis is only defined for `@:build/@:autoBuild` macros.\n",
      "defineType": "Defines a new type from `TypeDefinition` `t`.\n\nIf a matching module has already been loaded in current context, a\n`haxe.macro.Expr.Error` compiler error will be raised which can be\ncaught using `try ... catch`.\n\nIf `moduleDependency` is given and is not `null`, it should contain\na module path that will be used as a dependency for the newly defined module\ninstead of the current module.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "makeMonomorph": "Creates and returns a new instance of monomorph (`TMono`) type.\n\nReturned monomorph can be used with e.g. `Context.unify` to make the compiler\nbind the monomorph to an actual type and let macro further process the resulting type.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "defineModule": "Defines a new module as `modulePath` with several `TypeDefinition`\n`types`. This is analogous to defining a .hx file.\n\nIf a matching module has already been loaded in current context, a\n`haxe.macro.Expr.Error` compiler error will be raised which can be\ncaught using `try ... catch`.\n\nThe individual `types` can reference each other and any identifier\nrespects the `imports` and `usings` as usual, expect that imports are\nnot allowed to have `.*` wildcards or `as s` shorthands.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "getTypedExpr": "Returns a syntax-level expression corresponding to typed expression `t`.\n\nThis process may lose some information.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "storeTypedExpr": "Store typed expression `t` internally and give a syntax-level expression\nthat can be returned from a macro and will be replaced by the stored\ntyped expression.\n\nIf `t` is `null` or invalid, an exception is thrown.\n\nNOTE: the returned value references an internally stored typed expression\nthat is reset between compilations, so care should be taken when storing\nthe expression returned by this method in a static variable and using the\ncompilation server.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "storeExpr": "Types expression `e`, stores the resulting typed expression internally and\nreturns a syntax-level expression that can be returned from a macro and\nwill be replaced by the stored typed expression.\n\nIf `e` is `null` or invalid, an exception is thrown.\n\nA call to `storeExpr(e)` is equivalent to `storeTypedExpr(typeExpr(e))` without\nthe overhead of encoding and decoding between regular and macro runtime.\n\nNOTE: the returned value references an internally stored typed expression\nthat is reset between compilations, so care should be taken when storing\nthe expression returned by this method in a static variable and using the\ncompilation server.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "typeAndStoreExpr": "This function works like `storeExpr`, but also returns access to the expression's\ntype through the `type` field of the return value.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "registerModuleDependency": "Manually adds a dependency between module `modulePath` and an external\nfile `externFile`.\n\nThis affects the compilation cache, causing the module to be typed if\n`externFile` has changed.\n\nHas no effect if the compilation cache is not used.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "timer": "Creates a timer which will be printed in the compilation report\nif `--times` compilation argument is set.\n\nNote that a timer may be omitted from the report if the amount of time\nmeasured is too small.\n\nThis method immediately starts a timer and returns a function to stop it:\n```\nvar stopTimer = haxe.macro.Context.timer(\"my heavy task\");\nrunTask();\nstopTimer();\n```\n",
      "withImports": "Executes `code` in a context that has `imports` and `usings` added.\n\nThis is equivalent to temporarily having `import` and `using` statements in a file. These\nare only active during the execution of `code` and do not affect anything afterwards. This\nis true even if `code` throws an exception.\n\nIf any argument is `null`, the result is unspecified.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n",
      "withOptions": "Executes `code` in a context that has some compiler options set, restore the compiler to its\ndefault behavior afterwards.\n\n`allowInlining`: enable or disable inlining during typing with `typeExpr`.\n\n`allowTransform`: when disabled, the code typed with `typeExpr` will be almost exactly the same\nas the input code. This will disable some abstract types transformations.\n\nUsage of this function from initialization macros is deprecated and may\ncause compilation server issues. Use `Context.onAfterInitMacros` to\nrun your code once typer is ready to be used.\n"
    },
    "fields": {}
  },
  "haxe.macro.Constant": {
    "doc": "Represents a position in a file.\n*/\ntypedef Position = {\n/**\nReference to the filename.\n*/\nvar file:String;\n\n/**\nPosition of the first character.\n*/\nvar min:Int;\n\n/**\nPosition of the last character.\n*/\nvar max:Int;\n}\n#end\n\nenum StringLiteralKind {\nDoubleQuotes;\nSingleQuotes;\n}\n\n/**\nRepresents a constant.\n@see https://haxe.org/manual/expression-constants.html\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "min": "Position of the first character.\n",
      "max": "Position of the last character.\n",
      "expr": "Represents a constant.\n@see https://haxe.org/manual/expression-constants.html\n*/\nenum Constant {\n/**\nRepresents an integer literal.\n*/\nCInt(v:String, ?s:String);\n\n/**\nRepresents a float literal.\n*/\nCFloat(f:String, ?s:String);\n\n/**\nRepresents a string literal.\n*/\nCString(s:String, ?kind:StringLiteralKind);\n\n/**\nRepresents an identifier.\n*/\nCIdent(s:String);\n\n/**\nRepresents a regular expression literal.\n\nExample: `~/haxe/i`\n\n- The first argument `haxe` is a string with regular expression pattern.\n- The second argument `i` is a string with regular expression flags.\n\n@see https://haxe.org/manual/std-regex.html\n*/\nCRegexp(r:String, opt:String);\n}\n\n/**\nA binary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Binop {\n/**\n`+`\n*/\nOpAdd;\n\n/**\n`*`\n*/\nOpMult;\n\n/**\n`/`\n*/\nOpDiv;\n\n/**\n`-`\n*/\nOpSub;\n\n/**\n`=`\n*/\nOpAssign;\n\n/**\n`==`\n*/\nOpEq;\n\n/**\n`!=`\n*/\nOpNotEq;\n\n/**\n`>`\n*/\nOpGt;\n\n/**\n`>=`\n*/\nOpGte;\n\n/**\n`<`\n*/\nOpLt;\n\n/**\n`<=`\n*/\nOpLte;\n\n/**\n`&`\n*/\nOpAnd;\n\n/**\n`|`\n*/\nOpOr;\n\n/**\n`^`\n*/\nOpXor;\n\n/**\n`&&`\n*/\nOpBoolAnd;\n\n/**\n`||`\n*/\nOpBoolOr;\n\n/**\n`<<`\n*/\nOpShl;\n\n/**\n`>>`\n*/\nOpShr;\n\n/**\n`>>>`\n*/\nOpUShr;\n\n/**\n`%`\n*/\nOpMod;\n\n/**\n`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\nOpAssignOp(op:Binop);\n\n/**\n`...`\n*/\nOpInterval;\n\n/**\n`=>`\n*/\nOpArrow;\n\n/**\n`in`\n*/\nOpIn;\n\n/**\n`??`\n*/\nOpNullCoal;\n}\n\n/**\nA unary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n*/\nenum Unop {\n/**\n`++`\n*/\nOpIncrement;\n\n/**\n`--`\n*/\nOpDecrement;\n\n/**\n`!`\n*/\nOpNot;\n\n/**\n`-`\n*/\nOpNeg;\n\n/**\n`~`\n*/\nOpNegBits;\n\n/**\n`...`\n*/\nOpSpread;\n}\n\nenum EFieldKind {\nNormal;\nSafe;\n}\n\n/**\nRepresents a node in the AST.\n@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n/**\nThe expression kind.\n"
    }
  },
  "haxe.macro.Binop": {
    "doc": "Represents an integer literal.\n*/\nCInt(v:String, ?s:String);\n\n/**\nRepresents a float literal.\n*/\nCFloat(f:String, ?s:String);\n\n/**\nRepresents a string literal.\n*/\nCString(s:String, ?kind:StringLiteralKind);\n\n/**\nRepresents an identifier.\n*/\nCIdent(s:String);\n\n/**\nRepresents a regular expression literal.\n\nExample: `~/haxe/i`\n\n- The first argument `haxe` is a string with regular expression pattern.\n- The second argument `i` is a string with regular expression flags.\n\n@see https://haxe.org/manual/std-regex.html\n*/\nCRegexp(r:String, opt:String);\n}\n\n/**\nA binary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Unop": {
    "doc": "`+`\n*/\nOpAdd;\n\n/**\n`*`\n*/\nOpMult;\n\n/**\n`/`\n*/\nOpDiv;\n\n/**\n`-`\n*/\nOpSub;\n\n/**\n`=`\n*/\nOpAssign;\n\n/**\n`==`\n*/\nOpEq;\n\n/**\n`!=`\n*/\nOpNotEq;\n\n/**\n`>`\n*/\nOpGt;\n\n/**\n`>=`\n*/\nOpGte;\n\n/**\n`<`\n*/\nOpLt;\n\n/**\n`<=`\n*/\nOpLte;\n\n/**\n`&`\n*/\nOpAnd;\n\n/**\n`|`\n*/\nOpOr;\n\n/**\n`^`\n*/\nOpXor;\n\n/**\n`&&`\n*/\nOpBoolAnd;\n\n/**\n`||`\n*/\nOpBoolOr;\n\n/**\n`<<`\n*/\nOpShl;\n\n/**\n`>>`\n*/\nOpShr;\n\n/**\n`>>>`\n*/\nOpUShr;\n\n/**\n`%`\n*/\nOpMod;\n\n/**\n`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`\n*/\nOpAssignOp(op:Binop);\n\n/**\n`...`\n*/\nOpInterval;\n\n/**\n`=>`\n*/\nOpArrow;\n\n/**\n`in`\n*/\nOpIn;\n\n/**\n`??`\n*/\nOpNullCoal;\n}\n\n/**\nA unary operator.\n@see https://haxe.org/manual/types-numeric-operators.html\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.QuoteStatus": {
    "doc": "`++`\n*/\nOpIncrement;\n\n/**\n`--`\n*/\nOpDecrement;\n\n/**\n`!`\n*/\nOpNot;\n\n/**\n`-`\n*/\nOpNeg;\n\n/**\n`~`\n*/\nOpNegBits;\n\n/**\n`...`\n*/\nOpSpread;\n}\n\nenum EFieldKind {\nNormal;\nSafe;\n}\n\n/**\nRepresents a node in the AST.\n@see https://haxe.org/manual/macro-reification-expression.html\n*/\ntypedef Expr = {\n/**\nThe expression kind.\n*/\nvar expr:ExprDef;\n\n/**\nThe position of the expression.\n*/\nvar pos:Position;\n}\n\n/**\nRepresents a AST node identical to `Expr`, but it allows constraining the\ntype of accepted expressions.\n@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\nRepresents a switch case.\n@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n/**\nThe value expressions of the case.\n*/\nvar values:Array<Expr>;\n\n/**\nThe optional guard expressions of the case, if available.\n*/\nvar ?guard:Expr;\n\n/**\nThe expression of the case, if available.\n*/\nvar ?expr:Expr;\n}\n\n/**\nRepresents a variable in the AST.\n@see https://haxe.org/manual/expression-var.html\n*/\ntypedef Var = {\n/**\nThe name of the variable.\n*/\nvar name:String;\n\n/**\nThe position of the variable name.\n*/\nvar ?namePos:Position;\n\n/**\nThe type-hint of the variable, if available.\n*/\nvar ?type:ComplexType;\n\n/**\nThe expression of the variable, if available.\n*/\nvar ?expr:Expr;\n\n/**\nWhether or not the variable can be assigned to.\n*/\nvar ?isFinal:Bool;\n\n/**\nWhether or not the variable is static.\n*/\nvar ?isStatic:Bool;\n\n/**\nMetadata associated with the variable, if available.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a catch in the AST.\n@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n/**\nThe name of the catch variable.\n*/\nvar name:String;\n\n/**\nThe type of the catch.\n*/\nvar ?type:ComplexType;\n\n/**\nThe expression of the catch.\n*/\nvar expr:Expr;\n}\n\n/**\nRepresents the way something is quoted.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "pos": "The position of the expression.\n",
      "values": "Represents a AST node identical to `Expr`, but it allows constraining the\ntype of accepted expressions.\n@see https://haxe.org/manual/macro-ExprOf.html\n*/\ntypedef ExprOf<T> = Expr;\n\n/**\nRepresents a switch case.\n@see https://haxe.org/manual/expression-switch.html\n*/\ntypedef Case = {\n/**\nThe value expressions of the case.\n",
      "name": "The position of the variable name.\n*/\nvar ?namePos:Position;\n\n/**\nThe type-hint of the variable, if available.\n*/\nvar ?type:ComplexType;\n\n/**\nThe expression of the variable, if available.\n*/\nvar ?expr:Expr;\n\n/**\nWhether or not the variable can be assigned to.\n*/\nvar ?isFinal:Bool;\n\n/**\nWhether or not the variable is static.\n*/\nvar ?isStatic:Bool;\n\n/**\nMetadata associated with the variable, if available.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a catch in the AST.\n@see https://haxe.org/manual/expression-try-catch.html\n*/\ntypedef Catch = {\n/**\nThe name of the catch variable.\n",
      "expr": "The type of the catch.\n*/\nvar ?type:ComplexType;\n\n/**\nThe expression of the catch.\n",
      "field": "Represents the way something is quoted.\n*/\nenum QuoteStatus {\n/**\nNo quotes\n*/\nUnquoted;\n\n/**\nDouble quotes `\"`\n*/\nQuoted;\n}\n\n/**\nRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n/**\nThe name of the field.\n"
    }
  },
  "haxe.macro.FunctionKind": {
    "doc": "No quotes\n*/\nUnquoted;\n\n/**\nDouble quotes `\"`\n*/\nQuoted;\n}\n\n/**\nRepresents the field of an object declaration.\n*/\ntypedef ObjectField = {\n/**\nThe name of the field.\n*/\nvar field:String;\n\n/**\nThe field expression.\n*/\nvar expr:Expr;\n\n/**\nHow the field name is quoted.\n*/\nvar ?quotes:QuoteStatus;\n}\n\n/**\nRepresents function kind in the AST\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "expr": "The field expression.\n",
      "pack": "How the field name is quoted.\n*/\nvar ?quotes:QuoteStatus;\n}\n\n/**\nRepresents function kind in the AST\n*/\nenum FunctionKind {\n/**\nAnonymous function\n*/\nFAnonymous;\n\n/**\nNamed function\n*/\nFNamed(name:String, ?inlined:Bool);\n\n/**\nArrow function\n*/\nFArrow;\n}\n\n/**\nRepresents the kind of a node in the AST.\n*/\nenum ExprDef {\n/**\nA constant.\n*/\nEConst(c:Constant);\n\n/**\nArray access `e1[e2]`.\n*/\nEArray(e1:Expr, e2:Expr);\n\n/**\nBinary operator `e1 op e2`.\n*/\nEBinop(op:Binop, e1:Expr, e2:Expr);\n\n/**\nField access on `e.field`.\n\nIf `kind` is null, it is equal to Normal.\n*/\nEField(e:Expr, field:String, ?kind:EFieldKind);\n\n/**\nParentheses `(e)`.\n*/\nEParenthesis(e:Expr);\n\n/**\nAn object declaration.\n*/\nEObjectDecl(fields:Array<ObjectField>);\n\n/**\nAn array declaration `[el]`.\n*/\nEArrayDecl(values:Array<Expr>);\n\n/**\nA call `e(params)`.\n*/\nECall(e:Expr, params:Array<Expr>);\n\n/**\nA constructor call `new t(params)`.\n*/\nENew(t:TypePath, params:Array<Expr>);\n\n/**\nAn unary operator `op` on `e`:\n\n- `e++` (`op = OpIncrement, postFix = true`)\n- `e--` (`op = OpDecrement, postFix = true`)\n- `++e` (`op = OpIncrement, postFix = false`)\n- `--e` (`op = OpDecrement, postFix = false`)\n- `-e` (`op = OpNeg, postFix = false`)\n- `!e` (`op = OpNot, postFix = false`)\n- `~e` (`op = OpNegBits, postFix = false`)\n*/\nEUnop(op:Unop, postFix:Bool, e:Expr);\n\n/**\nVariable declarations.\n*/\nEVars(vars:Array<Var>);\n\n/**\nA function declaration.\n*/\nEFunction(kind:Null<FunctionKind>, f:Function);\n\n/**\nA block of expressions `{exprs}`.\n*/\nEBlock(exprs:Array<Expr>);\n\n/**\nA `for` expression.\n*/\nEFor(it:Expr, expr:Expr);\n\n/**\nAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\nEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n/**\nRepresents a `while` expression.\n\nWhen `normalWhile` is `true` it is `while (...)`.\n\nWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n/**\nRepresents a `switch` expression with related cases and an optional.\n`default` case if `edef != null`.\n*/\nESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n/**\nRepresents a `try`-expression with related catches.\n*/\nETry(e:Expr, catches:Array<Catch>);\n\n/**\nA `return` or `return e` expression.\n*/\nEReturn(?e:Expr);\n\n/**\nA `break` expression.\n*/\nEBreak;\n\n/**\nA `continue` expression.\n*/\nEContinue;\n\n/**\nAn `untyped e` source code.\n*/\nEUntyped(e:Expr);\n\n/**\nA `throw e` expression.\n*/\nEThrow(e:Expr);\n\n/**\nA `cast e` or `cast (e, m)` expression.\n*/\nECast(e:Expr, t:Null<ComplexType>);\n\n/**\nUsed internally to provide completion.\n*/\nEDisplay(e:Expr, displayKind:DisplayKind);\n\n/**\nA `(econd) ? eif : eelse` expression.\n*/\nETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n/**\nA `(e:t)` expression.\n*/\nECheckType(e:Expr, t:ComplexType);\n\n/**\nA `@m e` expression.\n*/\nEMeta(s:MetadataEntry, e:Expr);\n\n/**\nAn `expr is Type` expression.\n*/\nEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\nDKCall;\nDKDot;\nDKStructure;\nDKMarked;\nDKPattern(outermost:Bool);\n}\n\n/**\nRepresents a type syntax in the AST.\n*/\nenum ComplexType {\n/**\nRepresents the type path.\n*/\nTPath(p:TypePath);\n\n/**\nRepresents a function type.\n@see https://haxe.org/manual/types-function.html\n*/\nTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n/**\nRepresents an anonymous structure type.\n@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(fields:Array<Field>);\n\n/**\nRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n`(Int -> Void) -> String`.\n*/\nTParent(t:ComplexType);\n\n/**\nRepresents typedef extensions `> Iterable<T>`.\nThe array `p` holds the type paths to the given types.\n@see https://haxe.org/manual/type-system-extensions.html\n*/\nTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n/**\nRepresents an optional type.\n*/\nTOptional(t:ComplexType);\n\n/**\nRepresents a type with a name.\n*/\nTNamed(n:String, t:ComplexType);\n\n/**\nRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\nTIntersection(tl:Array<ComplexType>);\n}\n\n/**\nRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n/**\nRepresents the package of the type path.\n"
    }
  },
  "haxe.macro.ExprDef": {
    "doc": "Anonymous function\n*/\nFAnonymous;\n\n/**\nNamed function\n*/\nFNamed(name:String, ?inlined:Bool);\n\n/**\nArrow function\n*/\nFArrow;\n}\n\n/**\nRepresents the kind of a node in the AST.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ComplexType": {
    "doc": "A constant.\n*/\nEConst(c:Constant);\n\n/**\nArray access `e1[e2]`.\n*/\nEArray(e1:Expr, e2:Expr);\n\n/**\nBinary operator `e1 op e2`.\n*/\nEBinop(op:Binop, e1:Expr, e2:Expr);\n\n/**\nField access on `e.field`.\n\nIf `kind` is null, it is equal to Normal.\n*/\nEField(e:Expr, field:String, ?kind:EFieldKind);\n\n/**\nParentheses `(e)`.\n*/\nEParenthesis(e:Expr);\n\n/**\nAn object declaration.\n*/\nEObjectDecl(fields:Array<ObjectField>);\n\n/**\nAn array declaration `[el]`.\n*/\nEArrayDecl(values:Array<Expr>);\n\n/**\nA call `e(params)`.\n*/\nECall(e:Expr, params:Array<Expr>);\n\n/**\nA constructor call `new t(params)`.\n*/\nENew(t:TypePath, params:Array<Expr>);\n\n/**\nAn unary operator `op` on `e`:\n\n- `e++` (`op = OpIncrement, postFix = true`)\n- `e--` (`op = OpDecrement, postFix = true`)\n- `++e` (`op = OpIncrement, postFix = false`)\n- `--e` (`op = OpDecrement, postFix = false`)\n- `-e` (`op = OpNeg, postFix = false`)\n- `!e` (`op = OpNot, postFix = false`)\n- `~e` (`op = OpNegBits, postFix = false`)\n*/\nEUnop(op:Unop, postFix:Bool, e:Expr);\n\n/**\nVariable declarations.\n*/\nEVars(vars:Array<Var>);\n\n/**\nA function declaration.\n*/\nEFunction(kind:Null<FunctionKind>, f:Function);\n\n/**\nA block of expressions `{exprs}`.\n*/\nEBlock(exprs:Array<Expr>);\n\n/**\nA `for` expression.\n*/\nEFor(it:Expr, expr:Expr);\n\n/**\nAn `if (econd) eif` or `if (econd) eif else eelse` expression.\n*/\nEIf(econd:Expr, eif:Expr, eelse:Null<Expr>);\n\n/**\nRepresents a `while` expression.\n\nWhen `normalWhile` is `true` it is `while (...)`.\n\nWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nEWhile(econd:Expr, e:Expr, normalWhile:Bool);\n\n/**\nRepresents a `switch` expression with related cases and an optional.\n`default` case if `edef != null`.\n*/\nESwitch(e:Expr, cases:Array<Case>, edef:Null<Expr>);\n\n/**\nRepresents a `try`-expression with related catches.\n*/\nETry(e:Expr, catches:Array<Catch>);\n\n/**\nA `return` or `return e` expression.\n*/\nEReturn(?e:Expr);\n\n/**\nA `break` expression.\n*/\nEBreak;\n\n/**\nA `continue` expression.\n*/\nEContinue;\n\n/**\nAn `untyped e` source code.\n*/\nEUntyped(e:Expr);\n\n/**\nA `throw e` expression.\n*/\nEThrow(e:Expr);\n\n/**\nA `cast e` or `cast (e, m)` expression.\n*/\nECast(e:Expr, t:Null<ComplexType>);\n\n/**\nUsed internally to provide completion.\n*/\nEDisplay(e:Expr, displayKind:DisplayKind);\n\n/**\nA `(econd) ? eif : eelse` expression.\n*/\nETernary(econd:Expr, eif:Expr, eelse:Expr);\n\n/**\nA `(e:t)` expression.\n*/\nECheckType(e:Expr, t:ComplexType);\n\n/**\nA `@m e` expression.\n*/\nEMeta(s:MetadataEntry, e:Expr);\n\n/**\nAn `expr is Type` expression.\n*/\nEIs(e:Expr, t:ComplexType);\n}\n\nenum DisplayKind {\nDKCall;\nDKDot;\nDKStructure;\nDKMarked;\nDKPattern(outermost:Bool);\n}\n\n/**\nRepresents a type syntax in the AST.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeParam": {
    "doc": "Represents the type path.\n*/\nTPath(p:TypePath);\n\n/**\nRepresents a function type.\n@see https://haxe.org/manual/types-function.html\n*/\nTFunction(args:Array<ComplexType>, ret:ComplexType);\n\n/**\nRepresents an anonymous structure type.\n@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(fields:Array<Field>);\n\n/**\nRepresents parentheses around a type, e.g. the `(Int -> Void)` part in\n`(Int -> Void) -> String`.\n*/\nTParent(t:ComplexType);\n\n/**\nRepresents typedef extensions `> Iterable<T>`.\nThe array `p` holds the type paths to the given types.\n@see https://haxe.org/manual/type-system-extensions.html\n*/\nTExtend(p:Array<TypePath>, fields:Array<Field>);\n\n/**\nRepresents an optional type.\n*/\nTOptional(t:ComplexType);\n\n/**\nRepresents a type with a name.\n*/\nTNamed(n:String, t:ComplexType);\n\n/**\nRepresents an intersection type `T1 & T2 & ... & TN`.\n*/\nTIntersection(tl:Array<ComplexType>);\n}\n\n/**\nRepresents a type path in the AST.\n*/\ntypedef TypePath = {\n/**\nRepresents the package of the type path.\n*/\nvar pack:Array<String>;\n\n/**\nThe name of the type path.\n*/\nvar name:String;\n\n/**\nOptional parameters of the type path.\n*/\nvar ?params:Array<TypeParam>;\n\n/**\nSub is set on module sub-type access:\n`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\nvar ?sub:String;\n\n/**\nThe full position of the type path, including type parameters.\n*/\nvar ?pos:Position;\n\n/**\nThe position of the dot-path itself, without type parameters.\n*/\nvar ?posPath:Position;\n}\n\n/**\nRepresents a concrete type parameter in the AST.\n\nHaxe allows expressions in concrete type parameters, e.g.\n`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\nin the normal case it's `TPType`.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "Optional parameters of the type path.\n*/\nvar ?params:Array<TypeParam>;\n\n/**\nSub is set on module sub-type access:\n`pack.Module.Type` has `name = \"Module\"`, `sub = \"Type\"`, if available.\n*/\nvar ?sub:String;\n\n/**\nThe full position of the type path, including type parameters.\n*/\nvar ?pos:Position;\n\n/**\nThe position of the dot-path itself, without type parameters.\n*/\nvar ?posPath:Position;\n}\n\n/**\nRepresents a concrete type parameter in the AST.\n\nHaxe allows expressions in concrete type parameters, e.g.\n`new YourType<[\"hello\", \"world\"]>`. In that case the value is `TPExpr` while\nin the normal case it's `TPType`.\n*/\nenum TypeParam {\nTPType(t:ComplexType);\nTPExpr(e:Expr);\n}\n\n/**\nRepresents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n/**\nThe name of the type parameter.\n"
    }
  },
  "haxe.macro.Access": {
    "doc": "Represents a type parameter declaration in the AST.\n*/\ntypedef TypeParamDecl = {\n/**\nThe name of the type parameter.\n*/\nvar name:String;\n\n/**\nThe optional constraints of the type parameter.\n*/\nvar ?constraints:Array<ComplexType>;\n\n/**\nThe optional default type of the type parameter.\n*/\nvar ?defaultType:Null<ComplexType>;\n\n/**\nThe optional parameters of the type parameter.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\nThe metadata of the type parameter.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a function in the AST.\n*/\ntypedef Function = {\n/**\nA list of function arguments.\n*/\nvar args:Array<FunctionArg>;\n\n/**\nThe return type-hint of the function, if available.\n*/\nvar ?ret:ComplexType;\n\n/**\nThe expression of the function body, if available.\n*/\nvar ?expr:Expr;\n\n/**\nAn optional list of function parameter type declarations.\n*/\nvar ?params:Array<TypeParamDecl>;\n}\n\n/**\nRepresents a function argument in the AST.\n*/\ntypedef FunctionArg = {\n/**\nThe name of the function argument.\n*/\nvar name:String;\n\n/**\nWhether or not the function argument is optional.\n*/\nvar ?opt:Bool;\n\n/**\nThe type-hint of the function argument, if available.\n*/\nvar ?type:ComplexType;\n\n/**\nThe optional value of the function argument, if available.\n*/\nvar ?value:Expr;\n\n/**\nThe metadata of the function argument.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a metadata entry in the AST.\n*/\ntypedef MetadataEntry = {\n/**\nThe name of the metadata entry.\n*/\nvar name:String;\n\n/**\nThe optional parameters of the metadata entry.\n*/\nvar ?params:Array<Expr>;\n\n/**\nThe position of the metadata entry.\n*/\nvar pos:Position;\n}\n\n/**\nRepresents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\nRepresents a field in the AST.\n*/\ntypedef Field = {\n/**\nThe name of the field.\n*/\nvar name:String;\n\n/**\nThe documentation of the field, if available. If the field has no\ndocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\nThe access modifiers of the field. By default fields have private access.\n@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nvar ?access:Array<Access>;\n\n/**\nThe kind of the field.\n*/\nvar kind:FieldType;\n\n/**\nThe position of the field.\n*/\nvar pos:Position;\n\n/**\nThe optional metadata of the field.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents an access modifier.\n@see https://haxe.org/manual/class-field-access-modifier.html\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "args": "The optional constraints of the type parameter.\n*/\nvar ?constraints:Array<ComplexType>;\n\n/**\nThe optional default type of the type parameter.\n*/\nvar ?defaultType:Null<ComplexType>;\n\n/**\nThe optional parameters of the type parameter.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\nThe metadata of the type parameter.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents a function in the AST.\n*/\ntypedef Function = {\n/**\nA list of function arguments.\n",
      "name": "Represents metadata in the AST.\n*/\ntypedef Metadata = Array<MetadataEntry>;\n\n/**\nRepresents a field in the AST.\n*/\ntypedef Field = {\n/**\nThe name of the field.\n",
      "pos": "The position of the field.\n",
      "kind": "The documentation of the field, if available. If the field has no\ndocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\nThe access modifiers of the field. By default fields have private access.\n@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nvar ?access:Array<Access>;\n\n/**\nThe kind of the field.\n",
      "pack": "The optional metadata of the field.\n*/\nvar ?meta:Metadata;\n}\n\n/**\nRepresents an access modifier.\n@see https://haxe.org/manual/class-field-access-modifier.html\n*/\nenum Access {\n/**\nPublic access modifier, grants access from anywhere.\n@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPublic;\n\n/**\nPrivate access modifier, grants access to class and its sub-classes\nonly.\n@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPrivate;\n\n/**\nStatic access modifier.\n*/\nAStatic;\n\n/**\nOverride access modifier.\n@see https://haxe.org/manual/class-field-override.html\n*/\nAOverride;\n\n/**\nDynamic (re-)bindable access modifier.\n@see https://haxe.org/manual/class-field-dynamic.html\n*/\nADynamic;\n\n/**\nInline access modifier. Allows expressions to be directly inserted in\nplace of calls to them.\n@see https://haxe.org/manual/class-field-inline.html\n*/\nAInline;\n\n/**\nMacro access modifier. Allows expression macro functions. These are\nnormal functions which are executed as soon as they are typed.\n*/\nAMacro;\n\n/**\nFinal access modifier. For functions, they can not be overridden. For\nvariables, it means they can be assigned to only once.\n*/\nAFinal;\n\n/**\nExtern access modifier.\n*/\nAExtern;\n\n/**\nAbstract access modifier.\n*/\nAAbstract;\n\n/**\nOverload access modifier.\n*/\nAOverload;\n\n/**\nEnum access modifier.\n*/\nAEnum;\n}\n\n/**\nRepresents the field type in the AST.\n*/\nenum FieldType {\n/**\nRepresents a variable field type.\n*/\nFVar(t:Null<ComplexType>, ?e:Expr);\n\n/**\nRepresents a function field type.\n*/\nFFun(f:Function);\n\n/**\nRepresents a property with getter and setter field type.\n*/\nFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\nRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n/**\nThe package of the type definition.\n"
    }
  },
  "haxe.macro.FieldType": {
    "doc": "Public access modifier, grants access from anywhere.\n@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPublic;\n\n/**\nPrivate access modifier, grants access to class and its sub-classes\nonly.\n@see https://haxe.org/manual/class-field-visibility.html\n*/\nAPrivate;\n\n/**\nStatic access modifier.\n*/\nAStatic;\n\n/**\nOverride access modifier.\n@see https://haxe.org/manual/class-field-override.html\n*/\nAOverride;\n\n/**\nDynamic (re-)bindable access modifier.\n@see https://haxe.org/manual/class-field-dynamic.html\n*/\nADynamic;\n\n/**\nInline access modifier. Allows expressions to be directly inserted in\nplace of calls to them.\n@see https://haxe.org/manual/class-field-inline.html\n*/\nAInline;\n\n/**\nMacro access modifier. Allows expression macro functions. These are\nnormal functions which are executed as soon as they are typed.\n*/\nAMacro;\n\n/**\nFinal access modifier. For functions, they can not be overridden. For\nvariables, it means they can be assigned to only once.\n*/\nAFinal;\n\n/**\nExtern access modifier.\n*/\nAExtern;\n\n/**\nAbstract access modifier.\n*/\nAAbstract;\n\n/**\nOverload access modifier.\n*/\nAOverload;\n\n/**\nEnum access modifier.\n*/\nAEnum;\n}\n\n/**\nRepresents the field type in the AST.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TypeDefKind": {
    "doc": "Represents a variable field type.\n*/\nFVar(t:Null<ComplexType>, ?e:Expr);\n\n/**\nRepresents a function field type.\n*/\nFFun(f:Function);\n\n/**\nRepresents a property with getter and setter field type.\n*/\nFProp(get:String, set:String, ?t:ComplexType, ?e:Expr);\n}\n\n/**\nRepresents a type definition.\n*/\ntypedef TypeDefinition = {\n/**\nThe package of the type definition.\n*/\nvar pack:Array<String>;\n\n/**\nThe name of the type definition.\n*/\nvar name:String;\n\n/**\nThe documentation of the type, if available. If the type has no\ndocumentation, the value is `null`.\n*/\nvar ?doc:String;\n\n/**\nThe position to the type definition.\n*/\nvar pos:Position;\n\n/**\nThe optional metadata of the type definition.\n*/\nvar ?meta:Metadata;\n\n/**\nThe parameter type declarations of the type definition.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\nWhether or not the type is extern.\n*/\nvar ?isExtern:Bool;\n\n/**\nThe kind of the type definition.\n*/\nvar kind:TypeDefKind;\n\n/**\nThe fields of the type definition.\n*/\nvar fields:Array<Field>;\n}\n\n/**\nRepresents a type definition kind.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "name": "The name of the type definition.\n",
      "pos": "Represents a type definition kind.\n*/\nenum TypeDefKind {\n/**\nRepresents an enum kind.\n*/\nTDEnum;\n\n/**\nRepresents a structure kind.\n*/\nTDStructure;\n\n/**\nRepresents a class kind.\n*/\nTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n/**\nRepresents an alias/typedef kind.\n*/\nTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n/**\nRepresents an abstract kind.\n*/\nTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n/**\nRepresents a module-level field.\n*/\nTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\nRepresents an abstract flag.\n*/\nenum AbstractFlag {\n/**\nIndicates that this abstract is an `enum abstract`\n*/\nAbEnum;\n\n/**\nIndicates that this abstract can be assigned from `ct`.\nThis flag can be added several times to add multiple \"from\" types.\n*/\nAbFrom(ct:ComplexType);\n\n/**\nIndicates that this abstract can be assigned to `ct`.\nThis flag can be added several times to add multiple \"to\" types.\n*/\nAbTo(ct:ComplexType);\n}\n\n/**\nThis error can be used to handle or produce compilation errors in macros.\n*/\nclass Error extends Exception {\n/**\nThe position of the error.\n",
      "kind": "The optional metadata of the type definition.\n*/\nvar ?meta:Metadata;\n\n/**\nThe parameter type declarations of the type definition.\n*/\nvar ?params:Array<TypeParamDecl>;\n\n/**\nWhether or not the type is extern.\n*/\nvar ?isExtern:Bool;\n\n/**\nThe kind of the type definition.\n",
      "fields": "The fields of the type definition.\n"
    }
  },
  "haxe.macro.AbstractFlag": {
    "doc": "Represents an enum kind.\n*/\nTDEnum;\n\n/**\nRepresents a structure kind.\n*/\nTDStructure;\n\n/**\nRepresents a class kind.\n*/\nTDClass(?superClass:TypePath, ?interfaces:Array<TypePath>, ?isInterface:Bool, ?isFinal:Bool, ?isAbstract:Bool);\n\n/**\nRepresents an alias/typedef kind.\n*/\nTDAlias(t:ComplexType); // ignore TypeDefinition.fields\n\n/**\nRepresents an abstract kind.\n*/\nTDAbstract(tthis:Null<ComplexType>, ?flags:Array<AbstractFlag>, ?from:Array<ComplexType>, ?to:Array<ComplexType>);\n\n/**\nRepresents a module-level field.\n*/\nTDField(kind:FieldType, ?access:Array<Access>); // ignore TypeDefinition.fields\n\n}\n\n/**\nRepresents an abstract flag.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Error": {
    "doc": "Indicates that this abstract is an `enum abstract`\n*/\nAbEnum;\n\n/**\nIndicates that this abstract can be assigned from `ct`.\nThis flag can be added several times to add multiple \"from\" types.\n*/\nAbFrom(ct:ComplexType);\n\n/**\nIndicates that this abstract can be assigned to `ct`.\nThis flag can be added several times to add multiple \"to\" types.\n*/\nAbTo(ct:ComplexType);\n}\n\n/**\nThis error can be used to handle or produce compilation errors in macros.\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ImportMode": {
    "doc": "The position of the error.\n*/\npublic var pos:Position;\n\n/**\nChild error messages, if any.\n*/\nprivate var childErrors:Array<Error>;\n\n/**\nInstantiates an error with given message and position.\n*/\npublic function new(message:String, pos:Position, ?previous:Exception) {\nsuper(message, previous);\nthis.pos = pos;\n}\n}\n\n/**\nRepresents the import mode.\n@see https://haxe.org/manual/type-system-import.html\n",
    "path": "haxe\\std\\haxe\\macro\\Expr.hx",
    "functions": {},
    "fields": {
      "childErrors": "Child error messages, if any.\n",
      "path": "Instantiates an error with given message and position.\n*/\npublic function new(message:String, pos:Position, ?previous:Exception) {\nsuper(message, previous);\nthis.pos = pos;\n}\n}\n\n/**\nRepresents the import mode.\n@see https://haxe.org/manual/type-system-import.html\n*/\nenum ImportMode {\n/**\nRepresents a default import `import c`.\n*/\nINormal;\n\n/**\nRepresents the alias import `import c as alias`.\n*/\nIAsName(alias:String);\n\n/**\nRepresents the wildcard import `import *`.\n*/\nIAll;\n}\n\n/**\nRepresents the import expression.\n*/\ntypedef ImportExpr = {\n/**\nThe path to the import expression.\n",
      "mode": "The mode of the import expression.\n"
    }
  },
  "haxe.macro.ExprTools": {
    "doc": "This class provides some utility methods to work with expressions. It is\nbest used through 'using haxe.macro.ExprTools' syntax and then provides\nadditional methods on haxe.macro.Expr instances.\n\nWhile mainly intended to be used in macros, it works in non-macro code as\nwell.\n",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ExprArrayTools": {
    "doc": "Converts expression `e` to a human-readable String representation.\n\nThe result is guaranteed to be valid Haxe code, but there may be\ndifferences from the original lexical syntax.\n*/\nstatic public function toString(e:Expr):String\nreturn new Printer().printExpr(e);\n\n/**\nCalls function `f` on each sub-expression of `e`.\n\nIf `e` has no sub-expressions, this operation has no effect.\n\nOtherwise `f` is called once per sub-expression of `e`, with the\nsub-expression as argument. These calls are done in order of the\nsub-expression declarations.\n\nThis method does not call itself recursively. It should instead be used\nin a recursive function which handles the expression nodes of interest.\n\nUsage example:\n```haxe\nfunction findStrings(e:Expr) {\nswitch(e.expr) {\ncase EConst(CString(s)):\n// handle s\ncase _:\nExprTools.iter(e, findStrings);\n}\n}\n```\n*/\nstatic public function iter(e:Expr, f:Expr->Void):Void {\nswitch (e.expr) {\ncase EConst(_), EContinue, EBreak:\ncase EField(e, _), EParenthesis(e), EUntyped(e), EThrow(e), EDisplay(e, _), ECheckType(e, _), EUnop(_, _, e), ECast(e, _), EIs(e, _) | EMeta(_, e):\nf(e);\ncase EArray(e1, e2), EWhile(e1, e2, _), EBinop(_, e1, e2), EFor(e1, e2):\nf(e1);\nf(e2);\ncase EVars(vl):\nfor (v in vl)\nopt2(v.expr, f);\ncase ETry(e, cl):\nf(e);\nfor (c in cl)\nf(c.expr);\ncase ETernary(e1, e2, e3) | EIf(e1, e2, e3):\nf(e1);\nf(e2);\nopt2(e3, f);\ncase EArrayDecl(el), ENew(_, el), EBlock(el):\nExprArrayTools.iter(el, f);\ncase EObjectDecl(fl):\nfor (fd in fl)\nf(fd.expr);\ncase ECall(e, el):\nf(e);\nExprArrayTools.iter(el, f);\ncase EReturn(e):\nopt2(e, f);\ncase EFunction(_, func):\nfor (arg in func.args)\nopt2(arg.value, f);\nopt2(func.expr, f);\ncase ESwitch(e, cl, edef):\nf(e);\nfor (c in cl) {\nExprArrayTools.iter(c.values, f);\nopt2(c.guard, f);\nopt2(c.expr, f);\n}\nif (edef != null && edef.expr != null)\nf(edef);\n}\n}\n\n/**\nTransforms the sub-expressions of `e` by calling `f` on each of them.\n\nIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\nOtherwise `f` is called once per sub-expression of `e`, with the\nsub-expression as argument. These calls are done in order of the\nsub-expression declarations.\n\nThis method does not call itself recursively. It should instead be used\nin a recursive function which handles the expression nodes of interest.\n\nUsage example:\n```haxe\nfunction capitalizeStrings(e:Expr) {\nreturn switch(e.expr) {\ncase EConst(CString(s)):\n{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\ncase _:\nExprTools.map(e, capitalizeStrings);\n}\n}\n```\n*/\nstatic public function map(e:Expr, f:Expr->Expr):Expr {\nreturn {\npos: e.pos,\nexpr: switch (e.expr) {\ncase EConst(_): e.expr;\ncase EArray(e1, e2): EArray(f(e1), f(e2));\ncase EBinop(op, e1, e2): EBinop(op, f(e1), f(e2));\ncase EField(e, field, kind): EField(f(e), field, kind);\ncase EParenthesis(e): EParenthesis(f(e));\ncase EObjectDecl(fields):\nvar ret = [];\nfor (field in fields)\nret.push({field: field.field, expr: f(field.expr), quotes: field.quotes});\nEObjectDecl(ret);\ncase EArrayDecl(el): EArrayDecl(ExprArrayTools.map(el, f));\ncase ECall(e, params): ECall(f(e), ExprArrayTools.map(params, f));\ncase ENew(tp, params): ENew(tp, ExprArrayTools.map(params, f));\ncase EUnop(op, postFix, e): EUnop(op, postFix, f(e));\ncase EVars(vars):\nvar ret = [];\nfor (v in vars) {\nvar v2:Var = {name: v.name, type: v.type, expr: opt(v.expr, f)};\nif (v.isFinal != null)\nv2.isFinal = v.isFinal;\nif (v.isStatic != null)\nv2.isStatic = v.isStatic;\nret.push(v2);\n}\nEVars(ret);\ncase EBlock(el): EBlock(ExprArrayTools.map(el, f));\ncase EFor(it, expr): EFor(f(it), f(expr));\ncase EIf(econd, eif, eelse): EIf(f(econd), f(eif), opt(eelse, f));\ncase EWhile(econd, e, normalWhile): EWhile(f(econd), f(e), normalWhile);\ncase EReturn(e): EReturn(opt(e, f));\ncase EUntyped(e): EUntyped(f(e));\ncase EThrow(e): EThrow(f(e));\ncase ECast(e, t): ECast(f(e), t);\ncase EIs(e, t): EIs(f(e), t);\ncase EDisplay(e, dk): EDisplay(f(e), dk);\ncase ETernary(econd, eif, eelse): ETernary(f(econd), f(eif), f(eelse));\ncase ECheckType(e, t): ECheckType(f(e), t);\ncase EContinue, EBreak:\ne.expr;\ncase ETry(e, catches):\nvar ret = [];\nfor (c in catches)\nret.push({name: c.name, type: c.type, expr: f(c.expr)});\nETry(f(e), ret);\ncase ESwitch(e, cases, edef):\nvar ret = [];\nfor (c in cases)\nret.push({expr: opt(c.expr, f), guard: opt(c.guard, f), values: ExprArrayTools.map(c.values, f)});\nESwitch(f(e), ret, edef == null || edef.expr == null ? edef : f(edef));\ncase EFunction(kind, func):\nvar ret = [];\nfor (arg in func.args)\nret.push({\nname: arg.name,\nopt: arg.opt,\ntype: arg.type,\nvalue: opt(arg.value, f)\n});\nEFunction(kind, {\nargs: ret,\nret: func.ret,\nparams: func.params,\nexpr: f(func.expr)\n});\ncase EMeta(m, e): EMeta(m, f(e));\n}\n};\n}\n\n/**\nReturns the value `e` represents.\n\nSupported expressions are:\n\n- `Int`, `Float` and `String` literals\n- identifiers `true`, `false` and `null`\n- structure declarations if all their fields are values\n- array declarations if all their elements are values\n- unary operators `-`, `!` and `~` if the operand is a value\n- binary operators except `=>`, `...` and assignments\n\nParentheses, metadata and the `untyped` keyword are ignored.\n\nIf any non-value is encountered, an exception of type `String` is\nthrown.\n\nIf `e` is null, the result is unspecified.\n*/\nstatic public function getValue(e:Expr):Dynamic {\nreturn switch (e.expr) {\ncase EConst(CInt(v)): Std.parseInt(v);\ncase EConst(CFloat(v)): Std.parseFloat(v);\ncase EConst(CString(s)): s;\ncase EConst(CIdent(\"true\")): true;\ncase EConst(CIdent(\"false\")): false;\ncase EConst(CIdent(\"null\")): null;\ncase EParenthesis(e1) | EUntyped(e1) | EMeta(_, e1): getValue(e1);\ncase EObjectDecl(fields):\nvar obj = {};\nfor (field in fields) {\nReflect.setField(obj, field.field, getValue(field.expr));\n}\nobj;\ncase EArrayDecl(el): el.map(getValue);\ncase EIf(econd, eif, eelse) | ETernary(econd, eif, eelse):\nif (eelse == null) {\nthrow \"If statements only have a value if the else clause is defined\";\n} else {\nvar econd:Dynamic = getValue(econd);\necond ? getValue(eif) : getValue(eelse);\n}\ncase EUnop(op, false, e1):\nvar e1:Dynamic = getValue(e1);\nswitch (op) {\ncase OpNot: !e1;\ncase OpNeg: -e1;\ncase OpNegBits: ~e1;\ncase _: throw 'Unsupported expression: $e';\n}\ncase EBinop(op, e1, e2):\nvar e1:Dynamic = getValue(e1);\nvar e2:Dynamic = getValue(e2);\nswitch (op) {\ncase OpAdd: e1 + e2;\ncase OpSub: e1 - e2;\ncase OpMult: e1 * e2;\ncase OpDiv: e1 / e2;\ncase OpMod: e1 % e2;\ncase OpEq: e1 == e2;\ncase OpNotEq: e1 != e2;\ncase OpLt: e1 < e2;\ncase OpLte: e1 <= e2;\ncase OpGt: e1 > e2;\ncase OpGte: e1 >= e2;\ncase OpOr: e1 | e2;\ncase OpAnd: e1 & e2;\ncase OpXor: e1 ^ e2;\ncase OpBoolAnd: e1 && e2;\ncase OpBoolOr: e1 || e2;\ncase OpShl: e1 << e2;\ncase OpShr: e1 >> e2;\ncase OpUShr: e1 >>> e2;\ncase _: throw 'Unsupported expression: $e';\n}\ncase _: throw 'Unsupported expression: $e';\n}\n}\n\nstatic inline function opt(e:Null<Expr>, f:Expr->Expr):Expr\nreturn e == null ? null : f(e);\n\nstatic inline function opt2(e:Null<Expr>, f:Expr->Void):Void\nif (e != null)\nf(e);\n}\n\n/**\nThis class provides functions on expression arrays for convenience. For a\ndetailed reference on each method, see the documentation of ExprTools.\n",
    "path": "haxe\\std\\haxe\\macro\\ExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\nIf `e` has no sub-expressions, this operation has no effect.\n\nOtherwise `f` is called once per sub-expression of `e`, with the\nsub-expression as argument. These calls are done in order of the\nsub-expression declarations.\n\nThis method does not call itself recursively. It should instead be used\nin a recursive function which handles the expression nodes of interest.\n\nUsage example:\n```haxe\nfunction findStrings(e:Expr) {\nswitch(e.expr) {\ncase EConst(CString(s)):\n// handle s\ncase _:\nExprTools.iter(e, findStrings);\n}\n}\n```\n",
      "map": "Transforms the sub-expressions of `e` by calling `f` on each of them.\n\nIf `e` has no sub-expressions, this operation returns `e` unchanged.\n\nOtherwise `f` is called once per sub-expression of `e`, with the\nsub-expression as argument. These calls are done in order of the\nsub-expression declarations.\n\nThis method does not call itself recursively. It should instead be used\nin a recursive function which handles the expression nodes of interest.\n\nUsage example:\n```haxe\nfunction capitalizeStrings(e:Expr) {\nreturn switch(e.expr) {\ncase EConst(CString(s)):\n{ expr: EConst(CString(s.toUpperCase())), pos: e.pos };\ncase _:\nExprTools.map(e, capitalizeStrings);\n}\n}\n```\n",
      "getValue": "Returns the value `e` represents.\n\nSupported expressions are:\n\n- `Int`, `Float` and `String` literals\n- identifiers `true`, `false` and `null`\n- structure declarations if all their fields are values\n- array declarations if all their elements are values\n- unary operators `-`, `!` and `~` if the operand is a value\n- binary operators except `=>`, `...` and assignments\n\nParentheses, metadata and the `untyped` keyword are ignored.\n\nIf any non-value is encountered, an exception of type `String` is\nthrown.\n\nIf `e` is null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "haxe.macro.Format": {
    "doc": "The actual macro implemented for Std.format\n",
    "path": "haxe\\std\\haxe\\macro\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MacroStringTools": {
    "doc": "This class provides some utility methods to work with strings in macro\ncontext.\n",
    "path": "haxe\\std\\haxe\\macro\\MacroStringTools.hx",
    "functions": {
      "isFormatExpr": "Tells if `e` is a format string, i.e. uses single quotes `'` as\ndelimiters.\n",
      "toFieldExpr": "Converts an array of Strings `sl` to a field expression.\n\nIf `sl` has no elements, the result is null.\n\nIf `sl` has one element, the result is `EConst(CIdent(sl[0])`.\n\nOtherwise the result is a chain of `EField` nodes.\n\nIf `sl` is null, the result is unspecified.\n",
      "toDotPath": "Converts a path given by package `pack` and name `name` to a `String`\nseparated by dots.\n\nIf `pack` has no elements, the result is `name`.\n\nIf `pack` is null, the result is unspecified.\n\nOtherwise the elements of `pack` are joined with a separating dot, with\nan appended dot separating the result from `name`.\n"
    },
    "fields": {}
  },
  "haxe.macro.MacroType": {
    "doc": "This type is meant to be used to generate custom types using a macro.\nFor instance by doing MacroType<[my.Class.myMacro(55)]>\n",
    "path": "haxe\\std\\haxe\\macro\\MacroType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Printer": {
    "doc": "This class provides some utility methods to convert elements from the\nmacro context to a human-readable String representation.\n\nThis is only guaranteed to work with data that corresponds to valid Haxe\nsyntax.",
    "path": "haxe\\std\\haxe\\macro\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.Type": {
    "doc": "Represents a reference to internal compiler structure. It exists to avoid\nexpensive encoding if it is not required and to ensure that physical\nequality remains intact.\n\nA structure is only encoded when user requests it through `ref.get()`.\n/\ntypedef Ref<T> = {\npublic function get():T;\npublic function toString():String;\n}\n\n/**\nRepresents a type.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.AnonStatus": {
    "doc": "Represents a monomorph.\n\n@see https://haxe.org/manual/types-monomorph.html\n*/\nTMono(t:Ref<Null<Type>>);\n\n/**\nRepresents an enum instance.\n\n@see https://haxe.org/manual/types-enum-instance.html\n*/\nTEnum(t:Ref<EnumType>, params:Array<Type>);\n\n/**\nRepresents a class instance.\n\n@see https://haxe.org/manual/types-class-instance.html\n*/\nTInst(t:Ref<ClassType>, params:Array<Type>);\n\n/**\nRepresents a typedef.\n\n@see https://haxe.org/manual/type-system-typedef.html\n*/\nTType(t:Ref<DefType>, params:Array<Type>);\n\n/**\nRepresents a function type.\n\n@see https://haxe.org/manual/types-function.html\n*/\nTFun(args:Array<{name:String, opt:Bool, t:Type}>, ret:Type);\n\n/**\nRepresents an anonymous structure type.\n\n@see https://haxe.org/manual/types-anonymous-structure.html\n*/\nTAnonymous(a:Ref<AnonType>);\n\n/**\nRepresents Dynamic.\n\n@see https://haxe.org/manual/types-dynamic.html\n*/\nTDynamic(t:Null<Type>);\n\n/**\nUsed internally by the compiler to delay some typing.\n*/\nTLazy(f:Void->Type);\n\n/**\nRepresents an abstract type.\n\n@see https://haxe.org/manual/types-abstract.html\n*/\nTAbstract(t:Ref<AbstractType>, params:Array<Type>);\n}\n\n/**\nRepresents information for anonymous structure types.\n/\ntypedef AnonType = {\n/**\nThe class fields of the structure.\n*/\nvar fields:Array<ClassField>;\n\n/**\nThe status/kind of the structure.\n*/\nvar status:AnonStatus;\n}\n\n/**\nRepresents the kind of the anonymous structure type.\n",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "status": "The status/kind of the structure.\n",
      "name": "Represents the kind of the anonymous structure type.\n*/\nenum AnonStatus {\n/**\nA closed structure is considered complete. That is, no further fields\ncan be added to it.\n*/\nAClosed;\n\n/**\nAn open structure allows having additional fields added to it, which is\nused during type inference. It is closed upon unification.\n*/\nAOpened;\n\n/**\nA const structure is one that appears directly in syntax. It cannot be\nassigned to a smaller structure type (that is, it does not allow\nstructural sub-typing).\n*/\nAConst;\n\n/**\nRepresents a structure which extends one or multiple structures defined\nin `tl`.\n\n@see https://haxe.org/manual/type-system-extensions.html\n*/\nAExtend(tl:Ref<Array<Type>>);\n\n/**\nA structure that represents the static fields of a class.\n*/\nAClassStatics(t:Ref<ClassType>);\n\n/**\nA structure that represents the constructors of an enum.\n*/\nAEnumStatics(t:Ref<EnumType>);\n\n/**\nA structure that represents the static fields of an abstract.\n*/\nAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\nRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n/**\nThe name of the type parameter.\n"
    }
  },
  "haxe.macro.ClassKind": {
    "doc": "A closed structure is considered complete. That is, no further fields\ncan be added to it.\n*/\nAClosed;\n\n/**\nAn open structure allows having additional fields added to it, which is\nused during type inference. It is closed upon unification.\n*/\nAOpened;\n\n/**\nA const structure is one that appears directly in syntax. It cannot be\nassigned to a smaller structure type (that is, it does not allow\nstructural sub-typing).\n*/\nAConst;\n\n/**\nRepresents a structure which extends one or multiple structures defined\nin `tl`.\n\n@see https://haxe.org/manual/type-system-extensions.html\n*/\nAExtend(tl:Ref<Array<Type>>);\n\n/**\nA structure that represents the static fields of a class.\n*/\nAClassStatics(t:Ref<ClassType>);\n\n/**\nA structure that represents the constructors of an enum.\n*/\nAEnumStatics(t:Ref<EnumType>);\n\n/**\nA structure that represents the static fields of an abstract.\n*/\nAAbstractStatics(t:Ref<AbstractType>);\n}\n\n/**\nRepresents the declaration of type parameters.\n/\ntypedef TypeParameter = {\n/**\nThe name of the type parameter.\n*/\nvar name:String;\n\n/**\nThe type of the type parameter. It is guaranteed to be a `TInst` with a\n`KTypeParameter` kind.\n*/\nvar t:Type;\n\n/**\nThe default type for this type parameter.\n*/\nvar ?defaultType:Null<Type>;\n}\n\n/**\nRepresents a class field.\n/\ntypedef ClassField = {\n/**\nThe name of the class field.\n*/\nvar name:String;\n\n/**\nThe type of the class field.\n*/\nvar type:Type;\n\n/**\nWhether or not the class field is public.\n*/\nvar isPublic:Bool;\n\n/**\nWhether or not the class field is extern.\n*/\nvar isExtern:Bool;\n\n/**\nWhether or not the class field is final.\n*/\nvar isFinal:Bool;\n\n/**\nWhether or not the class field is abstract.\n*/\nvar isAbstract:Bool;\n\n/**\nThe type parameters of the class field.\n*/\nvar params:Array<TypeParameter>;\n\n/**\nThe metadata of the class field.\n*/\nvar meta:MetaAccess;\n\n/**\nThe class field kind.\n*/\nvar kind:FieldKind;\n\n/**\nReturns the typed expression of the class field.\n*/\nfunction expr():Null<TypedExpr>;\n\n/**\nThe position of the class field.\n*/\nvar pos:Expr.Position;\n\n/**\nThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\nThe overload fields of the class field.\n*/\nvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\nRepresents an enum constructor.\n/\ntypedef EnumField = {\n/**\nThe name of the enum constructor.\n*/\nvar name:String;\n\n/**\nThe type of the enum constructor.\n*/\nvar type:Type;\n\n/**\nThe position of the enum constructor.\n*/\nvar pos:Expr.Position;\n\n/**\nThe metadata of the enum constructor.\n*/\nvar meta:MetaAccess;\n\n/**\nThe index of the enum constructor, i.e. in which position it appears\nin the syntax.\n*/\nvar index:Int;\n\n/**\nThe associated documentation of the enum constructor.\n*/\nvar doc:Null<String>;\n\n/**\nThe type parameters of the enum constructor.\n*/\nvar params:Array<TypeParameter>;\n}\n\n/**\nRepresents the kind of a class.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "exclude": "The position of the class field.\n*/\nvar pos:Expr.Position;\n\n/**\nThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\nThe overload fields of the class field.\n*/\nvar overloads:Ref<Array<ClassField>>;\n}\n\n/**\nRepresents an enum constructor.\n/\ntypedef EnumField = {\n/**\nThe name of the enum constructor.\n*/\nvar name:String;\n\n/**\nThe type of the enum constructor.\n*/\nvar type:Type;\n\n/**\nThe position of the enum constructor.\n*/\nvar pos:Expr.Position;\n\n/**\nThe metadata of the enum constructor.\n*/\nvar meta:MetaAccess;\n\n/**\nThe index of the enum constructor, i.e. in which position it appears\nin the syntax.\n*/\nvar index:Int;\n\n/**\nThe associated documentation of the enum constructor.\n*/\nvar doc:Null<String>;\n\n/**\nThe type parameters of the enum constructor.\n*/\nvar params:Array<TypeParameter>;\n}\n\n/**\nRepresents the kind of a class.\n/\nenum ClassKind {\n/**\nA normal class.\n*/\nKNormal;\n\n/**\nA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\nA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\nA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\nA `@:generic` base class.\n*/\nKGeneric;\n\n/**\nA concrete `@:generic` instance, referencing the original class and the\napplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\nA special class for `haxe.macro.MacroType`.\n\n@deprecated\n*/\nKMacroType;\n\n/**\nAn implementation class of an abstract, i.e. where all its run-time code\nis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\nA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\nThe package of the type.\n*/\nvar pack:Array<String>;\n\n/**\nThe name of the type.\n*/\nvar name:String;\n\n/**\nThe module name of the type, which might be different.\n*/\nvar module:String;\n\n/**\nThe position of the type.\n*/\nvar pos:Expr.Position;\n\n/**\nWhether or not the type is private.\n*/\nvar isPrivate:Bool;\n\n/**\nWhether or not the type is extern.\n*/\nvar isExtern:Bool;\n\n/**\nThe type parameters of the type.\n*/\nvar params:Array<TypeParameter>;\n\n/**\nThe metadata of the type.\n*/\nvar meta:MetaAccess;\n\n/**\nThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\nAllows excluding the type from compilation.\n"
    },
    "fields": {
      "t": "The type of the type parameter. It is guaranteed to be a `TInst` with a\n`KTypeParameter` kind.\n",
      "name": "Represents an enum constructor.\n/\ntypedef EnumField = {\n/**\nThe name of the enum constructor.\n",
      "type": "The type of the enum constructor.\n",
      "isPublic": "Whether or not the class field is public.\n",
      "isExtern": "Whether or not the class field is extern.\n",
      "isFinal": "Whether or not the class field is final.\n",
      "isAbstract": "Whether or not the class field is abstract.\n",
      "params": "The type parameters of the enum constructor.\n",
      "meta": "The metadata of the enum constructor.\n",
      "kind": "The class field kind.\n",
      "pos": "The position of the enum constructor.\n",
      "doc": "The associated documentation of the enum constructor.\n",
      "overloads": "The overload fields of the class field.\n",
      "index": "The index of the enum constructor, i.e. in which position it appears\nin the syntax.\n",
      "pack": "Represents the kind of a class.\n/\nenum ClassKind {\n/**\nA normal class.\n*/\nKNormal;\n\n/**\nA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\nA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\nA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\nA `@:generic` base class.\n*/\nKGeneric;\n\n/**\nA concrete `@:generic` instance, referencing the original class and the\napplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\nA special class for `haxe.macro.MacroType`.\n\n@deprecated\n*/\nKMacroType;\n\n/**\nAn implementation class of an abstract, i.e. where all its run-time code\nis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\nA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\nThe package of the type.\n"
    }
  },
  "haxe.macro.FieldKind": {
    "doc": "A normal class.\n*/\nKNormal;\n\n/**\nA type parameter class with a set of constraints.\n*/\nKTypeParameter(constraints:Array<Type>);\n\n/**\nA class containing module fields.\n*/\nKModuleFields(module:String);\n\n/**\nA special kind of class to encode expressions into type parameters.\n*/\nKExpr(expr:Expr);\n\n/**\nA `@:generic` base class.\n*/\nKGeneric;\n\n/**\nA concrete `@:generic` instance, referencing the original class and the\napplied type parameters.\n*/\nKGenericInstance(cl:Ref<ClassType>, params:Array<Type>);\n\n/**\nA special class for `haxe.macro.MacroType`.\n\n@deprecated\n*/\nKMacroType;\n\n/**\nAn implementation class of an abstract, i.e. where all its run-time code\nis.\n*/\nKAbstractImpl(a:Ref<AbstractType>);\n\n/**\nA `@:genericBuild` class\n*/\nKGenericBuild;\n}\n\n/**\nThe information that all types (`ClassType`, `EnumType`, `DefType`,\n`AbstractType`) have in common.\n*/\ntypedef BaseType = {\n/**\nThe package of the type.\n*/\nvar pack:Array<String>;\n\n/**\nThe name of the type.\n*/\nvar name:String;\n\n/**\nThe module name of the type, which might be different.\n*/\nvar module:String;\n\n/**\nThe position of the type.\n*/\nvar pos:Expr.Position;\n\n/**\nWhether or not the type is private.\n*/\nvar isPrivate:Bool;\n\n/**\nWhether or not the type is extern.\n*/\nvar isExtern:Bool;\n\n/**\nThe type parameters of the type.\n*/\nvar params:Array<TypeParameter>;\n\n/**\nThe metadata of the type.\n*/\nvar meta:MetaAccess;\n\n/**\nThe associated documentation of the class field.\n*/\nvar doc:Null<String>;\n\n/**\nAllows excluding the type from compilation.\n*/\nfunction exclude():Void;\n}\n\n/**\nRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\nThe kind of the class.\n*/\nvar kind:ClassKind;\n\n/**\nIf true the type is an interface, otherwise it is a class.\n*/\nvar isInterface:Bool;\n\n/**\nIf true the class is final and cannot be extended.\n*/\nvar isFinal:Bool;\n\n/**\nIf true the class is abstract and cannot be instantiated directly.\n*/\nvar isAbstract:Bool;\n\n/**\nThe parent class and its type parameters, if available.\n*/\nvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\nThe implemented interfaces and their type parameters.\n*/\nvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\nThe member fields of the class.\n*/\nvar fields:Ref<Array<ClassField>>;\n\n/**\nThe static fields of the class.\n*/\nvar statics:Ref<Array<ClassField>>;\n\n// var dynamic : Null<Type>;\n// var arrayAccess : Null<Type>;\n\n/**\nThe constructor of the class, if available.\n*/\nvar constructor:Null<Ref<ClassField>>;\n\n/**\nThe `__init__` expression of the class, if available.\n*/\nvar init:Null<TypedExpr>;\n\n/**\nThe list of fields that have override status.\n*/\nvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\nRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\nThe available enum constructors.\n*/\nvar constructs:Map<String, EnumField>;\n\n/**\nAn ordered list of enum constructor names.\n*/\nvar names:Array<String>;\n}\n\n/**\nRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n/**\nThe target type of the typedef.\n*/\nvar type:Type;\n}\n\n/**\nRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\nThe underlying type of the abstract.\n*/\nvar type:Type;\n\n/**\nThe implementation class of the abstract, if available.\n*/\nvar impl:Null<Ref<ClassType>>;\n\n/**\nThe defined binary operators of the abstract.\n*/\nvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n/**\nThe defined unary operators of the abstract.\n*/\nvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n/**\nThe available implicit from-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\nThe available implicit to-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\nThe defined array-access fields of the abstract.\n*/\nvar array:Array<ClassField>;\n\n/**\nThe method used for resolving unknown field access, if available.\n*/\nvar resolve:Null<ClassField>;\n\n/**\nThe method used for resolving unknown field access, if available.\n*/\nvar resolveWrite:Null<ClassField>;\n\n/**\nThe expression given as a default value for this abstract, if available.\n*/\nvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\nMetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\nReturn the wrapped `Metadata` array.\n\nModifying this array has no effect on the origin of `this` MetaAccess.\nThe `add` and `remove` methods can be used for that.\n*/\nfunction get():Expr.Metadata;\n\n/**\nExtract metadata entries by given `name`.\n\nIf there's no metadata with such name, empty array `[]` is returned.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n/**\nAdds the metadata specified by `name`, `params` and `pos` to the origin\nof `this` MetaAccess.\n\nMetadata names are not unique during compilation, so this method never\noverwrites a previous metadata.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `add` has no effect on that array.\n\nIf any argument is null, compilation fails with an error.\n*/\nfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n/**\nRemoves all `name` metadata entries from the origin of `this`\nMetaAccess.\n\nThis method might clear several metadata entries of the same name.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `remove` has no effect on that array.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction remove(name:String):Void;\n\n/**\nTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction has(name:String):Bool;\n}\n\n/**\nRepresents a field kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {
      "get": "Represents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\nThe kind of the class.\n*/\nvar kind:ClassKind;\n\n/**\nIf true the type is an interface, otherwise it is a class.\n*/\nvar isInterface:Bool;\n\n/**\nIf true the class is final and cannot be extended.\n*/\nvar isFinal:Bool;\n\n/**\nIf true the class is abstract and cannot be instantiated directly.\n*/\nvar isAbstract:Bool;\n\n/**\nThe parent class and its type parameters, if available.\n*/\nvar superClass:Null<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\nThe implemented interfaces and their type parameters.\n*/\nvar interfaces:Array<{t:Ref<ClassType>, params:Array<Type>}>;\n\n/**\nThe member fields of the class.\n*/\nvar fields:Ref<Array<ClassField>>;\n\n/**\nThe static fields of the class.\n*/\nvar statics:Ref<Array<ClassField>>;\n\n// var dynamic : Null<Type>;\n// var arrayAccess : Null<Type>;\n\n/**\nThe constructor of the class, if available.\n*/\nvar constructor:Null<Ref<ClassField>>;\n\n/**\nThe `__init__` expression of the class, if available.\n*/\nvar init:Null<TypedExpr>;\n\n/**\nThe list of fields that have override status.\n*/\nvar overrides:Array<Ref<ClassField>>;\n}\n\n/**\nRepresents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\nThe available enum constructors.\n*/\nvar constructs:Map<String, EnumField>;\n\n/**\nAn ordered list of enum constructor names.\n*/\nvar names:Array<String>;\n}\n\n/**\nRepresents a typedef.\n/\ntypedef DefType = BaseType & {\n/**\nThe target type of the typedef.\n*/\nvar type:Type;\n}\n\n/**\nRepresents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\nThe underlying type of the abstract.\n*/\nvar type:Type;\n\n/**\nThe implementation class of the abstract, if available.\n*/\nvar impl:Null<Ref<ClassType>>;\n\n/**\nThe defined binary operators of the abstract.\n*/\nvar binops:Array<{op:Expr.Binop, field:ClassField}>;\n\n/**\nThe defined unary operators of the abstract.\n*/\nvar unops:Array<{op:Expr.Unop, postFix:Bool, field:ClassField}>;\n\n/**\nThe available implicit from-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar from:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\nThe available implicit to-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n*/\nvar to:Array<{t:Type, field:Null<ClassField>}>;\n\n/**\nThe defined array-access fields of the abstract.\n*/\nvar array:Array<ClassField>;\n\n/**\nThe method used for resolving unknown field access, if available.\n*/\nvar resolve:Null<ClassField>;\n\n/**\nThe method used for resolving unknown field access, if available.\n*/\nvar resolveWrite:Null<ClassField>;\n\n/**\nThe expression given as a default value for this abstract, if available.\n*/\nvar defaultValue:Null<Ref<TypedExpr>>;\n}\n\n/**\nMetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\nReturn the wrapped `Metadata` array.\n\nModifying this array has no effect on the origin of `this` MetaAccess.\nThe `add` and `remove` methods can be used for that.\n",
      "extract": "Extract metadata entries by given `name`.\n\nIf there's no metadata with such name, empty array `[]` is returned.\n\nIf `name` is null, compilation fails with an error.\n",
      "add": "Adds the metadata specified by `name`, `params` and `pos` to the origin\nof `this` MetaAccess.\n\nMetadata names are not unique during compilation, so this method never\noverwrites a previous metadata.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `add` has no effect on that array.\n\nIf any argument is null, compilation fails with an error.\n",
      "remove": "Removes all `name` metadata entries from the origin of `this`\nMetaAccess.\n\nThis method might clear several metadata entries of the same name.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `remove` has no effect on that array.\n\nIf `name` is null, compilation fails with an error.\n",
      "has": "Tells if the origin of `this` MetaAccess has a `name` metadata entry.\n\nIf `name` is null, compilation fails with an error.\n"
    },
    "fields": {
      "name": "The name of the type.\n",
      "module": "The module name of the type, which might be different.\n",
      "pos": "The position of the type.\n",
      "isPrivate": "Whether or not the type is private.\n",
      "isExtern": "Whether or not the type is extern.\n",
      "params": "The type parameters of the type.\n",
      "meta": "The metadata of the type.\n",
      "doc": "The associated documentation of the class field.\n",
      "kind": "Allows excluding the type from compilation.\n*/\nfunction exclude():Void;\n}\n\n/**\nRepresents a class type.\n/\ntypedef ClassType = BaseType & {\n/**\nThe kind of the class.\n",
      "isInterface": "If true the type is an interface, otherwise it is a class.\n",
      "isFinal": "If true the class is final and cannot be extended.\n",
      "isAbstract": "If true the class is abstract and cannot be instantiated directly.\n",
      "superClass": "The parent class and its type parameters, if available.\n",
      "interfaces": "The implemented interfaces and their type parameters.\n",
      "fields": "The member fields of the class.\n",
      "statics": "The static fields of the class.\n",
      "constructor": "The constructor of the class, if available.\n",
      "init": "The `__init__` expression of the class, if available.\n",
      "overrides": "The list of fields that have override status.\n",
      "constructs": "Represents an enum type.\n/\ntypedef EnumType = BaseType & {\n/**\nThe available enum constructors.\n",
      "names": "An ordered list of enum constructor names.\n",
      "type": "Represents an abstract type.\n/\ntypedef AbstractType = BaseType & {\n/**\nThe underlying type of the abstract.\n",
      "impl": "The implementation class of the abstract, if available.\n",
      "binops": "The defined binary operators of the abstract.\n",
      "unops": "The defined unary operators of the abstract.\n",
      "from": "The available implicit from-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n",
      "to": "The available implicit to-casts of the abstract.\n\n@see https://haxe.org/manual/types-abstract-implicit-casts.html\n",
      "array": "The defined array-access fields of the abstract.\n",
      "resolve": "The method used for resolving unknown field access, if available.\n",
      "resolveWrite": "The method used for resolving unknown field access, if available.\n",
      "defaultValue": "The expression given as a default value for this abstract, if available.\n",
      "args": "MetaAccess is a wrapper for the `Metadata` array. It can be used to add\nmetadata to and remove metadata from its origin.\n*/\ntypedef MetaAccess = {\n/**\nReturn the wrapped `Metadata` array.\n\nModifying this array has no effect on the origin of `this` MetaAccess.\nThe `add` and `remove` methods can be used for that.\n*/\nfunction get():Expr.Metadata;\n\n/**\nExtract metadata entries by given `name`.\n\nIf there's no metadata with such name, empty array `[]` is returned.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction extract(name:String):Array<Expr.MetadataEntry>;\n\n/**\nAdds the metadata specified by `name`, `params` and `pos` to the origin\nof `this` MetaAccess.\n\nMetadata names are not unique during compilation, so this method never\noverwrites a previous metadata.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `add` has no effect on that array.\n\nIf any argument is null, compilation fails with an error.\n*/\nfunction add(name:String, params:Array<Expr>, pos:Expr.Position):Void;\n\n/**\nRemoves all `name` metadata entries from the origin of `this`\nMetaAccess.\n\nThis method might clear several metadata entries of the same name.\n\nIf a `Metadata` array is obtained through a call to `get`, a subsequent\ncall to `remove` has no effect on that array.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction remove(name:String):Void;\n\n/**\nTells if the origin of `this` MetaAccess has a `name` metadata entry.\n\nIf `name` is null, compilation fails with an error.\n*/\nfunction has(name:String):Bool;\n}\n\n/**\nRepresents a field kind.\n/\nenum FieldKind {\n/**\nA variable or property, depending on the `read` and `write` values.\n*/\nFVar(read:VarAccess, write:VarAccess);\n\n/**\nA method\n*/\nFMethod(k:MethodKind);\n}\n\n/**\nRepresents the variable accessor.\n/\nenum VarAccess {\n/**\nNormal access (`default`).\n*/\nAccNormal;\n\n/**\nPrivate access (`null`).\n*/\nAccNo;\n\n/**\nNo access (`never`).\n*/\nAccNever;\n\n/**\nUnused.\n*/\nAccResolve;\n\n/**\nAccess through accessor function (`get`, `set`, `dynamic`).\n*/\nAccCall;\n\n/**\nAccess through private accessor function (`private get`, `private set`).\n*/\nAccPrivateCall;\n\n/**\nInline access (`inline`).\n*/\nAccInline;\n\n/**\nFailed access due to a `@:require` metadata.\n*/\nAccRequire(r:String, ?msg:String);\n\n/**\nAccess is only allowed from the constructor.\n*/\nAccCtor;\n}\n\n/**\nRepresents the method kind.\n/\nenum MethodKind {\n/**\nA normal method.\n*/\nMethNormal;\n\n/**\nAn inline method.\n\n@see https://haxe.org/manual/class-field-inline.html\n*/\nMethInline;\n\n/**\nA dynamic, rebindable method.\n\n@see https://haxe.org/manual/class-field-dynamic.html\n*/\nMethDynamic;\n\n/**\nA macro method.\n*/\nMethMacro;\n}\n\n/**\nRepresents typed constant.\n/\nenum TConstant {\n/**\nAn `Int` literal.\n*/\nTInt(i:Int);\n\n/**\nA `Float` literal, represented as String to avoid precision loss.\n*/\nTFloat(s:String);\n\n/**\nA `String` literal.\n*/\nTString(s:String);\n\n/**\nA `Bool` literal.\n*/\nTBool(b:Bool);\n\n/**\nThe constant `null`.\n*/\nTNull;\n\n/**\nThe constant `this`.\n*/\nTThis;\n\n/**\nThe constant `super`.\n*/\nTSuper;\n}\n\n/**\nRepresents a module type. These are the types that can be declared in a Haxe\nmodule and which are passed to the generators (except `TTypeDecl`).\n/\nenum ModuleType {\n/**\nA class.\n*/\nTClassDecl(c:Ref<ClassType>);\n\n/**\nAn enum.\n*/\nTEnumDecl(e:Ref<EnumType>);\n\n/**\nA typedef.\n*/\nTTypeDecl(t:Ref<DefType>);\n\n/**\nAn abstract.\n*/\nTAbstract(a:Ref<AbstractType>);\n}\n\n/**\nRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n/**\nA list of function arguments identified by an argument variable `v` and\nan optional initialization `value`.\n"
    }
  },
  "haxe.macro.VarAccess": {
    "doc": "A variable or property, depending on the `read` and `write` values.\n*/\nFVar(read:VarAccess, write:VarAccess);\n\n/**\nA method\n*/\nFMethod(k:MethodKind);\n}\n\n/**\nRepresents the variable accessor.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.MethodKind": {
    "doc": "Normal access (`default`).\n*/\nAccNormal;\n\n/**\nPrivate access (`null`).\n*/\nAccNo;\n\n/**\nNo access (`never`).\n*/\nAccNever;\n\n/**\nUnused.\n*/\nAccResolve;\n\n/**\nAccess through accessor function (`get`, `set`, `dynamic`).\n*/\nAccCall;\n\n/**\nAccess through private accessor function (`private get`, `private set`).\n*/\nAccPrivateCall;\n\n/**\nInline access (`inline`).\n*/\nAccInline;\n\n/**\nFailed access due to a `@:require` metadata.\n*/\nAccRequire(r:String, ?msg:String);\n\n/**\nAccess is only allowed from the constructor.\n*/\nAccCtor;\n}\n\n/**\nRepresents the method kind.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.TConstant": {
    "doc": "A normal method.\n*/\nMethNormal;\n\n/**\nAn inline method.\n\n@see https://haxe.org/manual/class-field-inline.html\n*/\nMethInline;\n\n/**\nA dynamic, rebindable method.\n\n@see https://haxe.org/manual/class-field-dynamic.html\n*/\nMethDynamic;\n\n/**\nA macro method.\n*/\nMethMacro;\n}\n\n/**\nRepresents typed constant.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.ModuleType": {
    "doc": "An `Int` literal.\n*/\nTInt(i:Int);\n\n/**\nA `Float` literal, represented as String to avoid precision loss.\n*/\nTFloat(s:String);\n\n/**\nA `String` literal.\n*/\nTString(s:String);\n\n/**\nA `Bool` literal.\n*/\nTBool(b:Bool);\n\n/**\nThe constant `null`.\n*/\nTNull;\n\n/**\nThe constant `this`.\n*/\nTThis;\n\n/**\nThe constant `super`.\n*/\nTSuper;\n}\n\n/**\nRepresents a module type. These are the types that can be declared in a Haxe\nmodule and which are passed to the generators (except `TTypeDecl`).",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.macro.FieldAccess": {
    "doc": "A class.\n*/\nTClassDecl(c:Ref<ClassType>);\n\n/**\nAn enum.\n*/\nTEnumDecl(e:Ref<EnumType>);\n\n/**\nA typedef.\n*/\nTTypeDecl(t:Ref<DefType>);\n\n/**\nAn abstract.\n*/\nTAbstract(a:Ref<AbstractType>);\n}\n\n/**\nRepresents a function in the typed AST.\n/\ntypedef TFunc = {\n/**\nA list of function arguments identified by an argument variable `v` and\nan optional initialization `value`.\n*/\nvar args:Array<{v:TVar, value:Null<TypedExpr>}>;\n\n/**\nThe return type of the function.\n*/\nvar t:Type;\n\n/**\nThe expression of the function body.\n*/\nvar expr:TypedExpr;\n}\n\n/**\nRepresents the kind of field access in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "t": "The return type of the function.\n",
      "expr": "The expression of the function body.\n",
      "id": "Represents the kind of field access in the typed AST.\n/\nenum FieldAccess {\n/**\nAccess of field `cf` on a class instance `c` with type parameters\n`params`.\n*/\nFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n/**\nStatic access of a field `cf` on a class `c`.\n*/\nFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n/**\nAccess of field `cf` on an anonymous structure.\n*/\nFAnon(cf:Ref<ClassField>);\n\n/**\nDynamic field access of a field named `s`.\n*/\nFDynamic(s:String);\n\n/**\nClosure field access of field `cf` on a class instance `c` with type\nparameters `params`.\n*/\nFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n/**\nField access to an enum constructor `ef` of enum `e`.\n*/\nFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\nRepresents kind of a node in the typed AST.\n/\nenum TypedExprDef {\n/**\nA constant.\n*/\nTConst(c:TConstant);\n\n/**\nReference to a local variable `v`.\n*/\nTLocal(v:TVar);\n\n/**\nArray access `e1[e2]`.\n*/\nTArray(e1:TypedExpr, e2:TypedExpr);\n\n/**\nBinary operator `e1 op e2`.\n*/\nTBinop(op:Expr.Binop, e1:TypedExpr, e2:TypedExpr);\n\n/**\nField access on `e` according to `fa`.\n*/\nTField(e:TypedExpr, fa:FieldAccess);\n\n/**\nReference to a module type `m`.\n*/\nTTypeExpr(m:ModuleType);\n\n/**\nParentheses `(e)`.\n*/\nTParenthesis(e:TypedExpr);\n\n/**\nAn object declaration.\n*/\nTObjectDecl(fields:Array<{name:String, expr:TypedExpr}>);\n\n/**\nAn array declaration `[el]`.\n*/\nTArrayDecl(el:Array<TypedExpr>);\n\n/**\nA call `e(el)`.\n*/\nTCall(e:TypedExpr, el:Array<TypedExpr>);\n\n/**\nA constructor call `new c<params>(el)`.\n*/\nTNew(c:Ref<ClassType>, params:Array<Type>, el:Array<TypedExpr>);\n\n/**\nAn unary operator `op` on `e`:\n\ne++ (op = OpIncrement, postFix = true)\ne-- (op = OpDecrement, postFix = true)\n++e (op = OpIncrement, postFix = false)\n--e (op = OpDecrement, postFix = false)\n-e (op = OpNeg, postFix = false)\n!e (op = OpNot, postFix = false)\n~e (op = OpNegBits, postFix = false)\n*/\nTUnop(op:Expr.Unop, postFix:Bool, e:TypedExpr);\n\n/**\nA function declaration.\n*/\nTFunction(tfunc:TFunc);\n\n/**\nA variable declaration `var v` or `var v = expr`.\n*/\nTVar(v:TVar, expr:Null<TypedExpr>);\n\n/**\nA block declaration `{el}`.\n*/\nTBlock(el:Array<TypedExpr>);\n\n/**\nA `for` expression.\n*/\nTFor(v:TVar, e1:TypedExpr, e2:TypedExpr);\n\n/**\nAn `if(econd) eif` or `if(econd) eif else eelse` expression.\n*/\nTIf(econd:TypedExpr, eif:TypedExpr, eelse:Null<TypedExpr>);\n\n/**\nRepresents a `while` expression.\nWhen `normalWhile` is `true` it is `while (...)`.\nWhen `normalWhile` is `false` it is `do {...} while (...)`.\n*/\nTWhile(econd:TypedExpr, e:TypedExpr, normalWhile:Bool);\n\n/**\nRepresents a `switch` expression with related cases and an optional\n`default` case if edef != null.\n*/\nTSwitch(e:TypedExpr, cases:Array<{values:Array<TypedExpr>, expr:TypedExpr}>, edef:Null<TypedExpr>);\n\n/**\nRepresents a `try`-expression with related catches.\n*/\nTTry(e:TypedExpr, catches:Array<{v:TVar, expr:TypedExpr}>);\n\n/**\nA `return` or `return e` expression.\n*/\nTReturn(e:Null<TypedExpr>);\n\n/**\nA `break` expression.\n*/\nTBreak;\n\n/**\nA `continue` expression.\n*/\nTContinue;\n\n/**\nA `throw e` expression.\n*/\nTThrow(e:TypedExpr);\n\n/**\nA `cast e` or `cast (e, m)` expression.\n*/\nTCast(e:TypedExpr, m:Null<ModuleType>);\n\n/**\nA `@m e1` expression.\n*/\nTMeta(m:Expr.MetadataEntry, e1:TypedExpr);\n\n/**\nAccess to an enum parameter (generated by the pattern matcher).\n*/\nTEnumParameter(e1:TypedExpr, ef:EnumField, index:Int);\n\n/**\nAccess to an enum index (generated by the pattern matcher).\n*/\nTEnumIndex(e1:TypedExpr);\n\n/**\nAn unknown identifier.\n*/\nTIdent(s:String);\n}\n\n/**\nRepresents a variable in the typed AST.\n/\ntypedef TVar = {\n/**\nThe unique ID of the variable.\n"
    }
  },
  "haxe.macro.TypedExprDef": {
    "doc": "Access of field `cf` on a class instance `c` with type parameters\n`params`.\n*/\nFInstance(c:Ref<ClassType>, params:Array<Type>, cf:Ref<ClassField>);\n\n/**\nStatic access of a field `cf` on a class `c`.\n*/\nFStatic(c:Ref<ClassType>, cf:Ref<ClassField>);\n\n/**\nAccess of field `cf` on an anonymous structure.\n*/\nFAnon(cf:Ref<ClassField>);\n\n/**\nDynamic field access of a field named `s`.\n*/\nFDynamic(s:String);\n\n/**\nClosure field access of field `cf` on a class instance `c` with type\nparameters `params`.\n*/\nFClosure(c:Null<{c:Ref<ClassType>, params:Array<Type>}>, cf:Ref<ClassField>);\n\n/**\nField access to an enum constructor `ef` of enum `e`.\n*/\nFEnum(e:Ref<EnumType>, ef:EnumField);\n}\n\n/**\nRepresents kind of a node in the typed AST.",
    "path": "haxe\\std\\haxe\\macro\\Type.hx",
    "functions": {},
    "fields": {
      "name": "The name of the variable.\n",
      "t": "The type of the expression.\n",
      "capture": "Whether or not the variable has been captured by a closure.\n",
      "extra": "Special information which is internally used to keep track of closure.\ninformation\n",
      "meta": "The metadata of the variable.\n",
      "isStatic": "Whether the variable is a local static variable\n",
      "expr": "Represents a typed AST node.\n/\ntypedef TypedExpr = {\n/**\nThe expression kind.\n",
      "pos": "The position of the expression.\n"
    }
  },
  "haxe.macro.TypedExprTools": {
    "doc": "This class provides some utility methods to work with typed expressions.\nIt is best used through 'using haxe.macro.TypedExprTools' syntax and then\nprovides additional methods on `haxe.macro.TypedExpr` instances.\n",
    "path": "haxe\\std\\haxe\\macro\\TypedExprTools.hx",
    "functions": {
      "iter": "Calls function `f` on each sub-expression of `e`.\n\nSee `haxe.macro.ExprTools.iter` for details on iterating expressions in\ngeneral. This function works the same way, but with a different data\nstructure.\n",
      "mapWithType": "Transforms the sub-expressions of `e` by calling `f` on each of them.\nAdditionally, types are mapped using `ft` and variables are mapped using\n`fv`.\n\nSee `haxe.macro.ExprTools.map` for details on expression mapping in\ngeneral. This function works the same way, but with a different data\nstructure.\n"
    },
    "fields": {}
  },
  "haxe.macro.TypeTools": {
    "doc": "This class provides some utility methods to work with types. It is\nbest used through 'using haxe.macro.TypeTools' syntax and then provides\nadditional methods on haxe.macro.Type instances.\n",
    "path": "haxe\\std\\haxe\\macro\\TypeTools.hx",
    "functions": {
      "follow": "Follows all typedefs of `t` to reach the actual type.\n\nIf `once` is true, this function does not call itself recursively,\notherwise it does. This can be useful in cases where intermediate\ntypedefs might be of interest.\n\nAffected types are monomorphs `TMono` and typedefs `TType(t,pl)`.\n\nIf `t` is null, an internal exception is thrown.\n\nUsage example with monomorphs:\nvar t = Context.typeof(macro null); // TMono(<mono>)\nvar ts = Context.typeof(macro \"foo\"); //TInst(String,[])\nContext.unify(t, ts);\ntrace(t); // TMono(<mono>)\ntrace(t.follow()); //TInst(String,[])\n\nUsage example with typedefs:\nvar t = Context.typeof(macro (\"foo\" :MyString)); // typedef MyString = String\ntrace(t); // TType(MyString,[])\ntrace(t.follow()); //TInst(String,[])\n",
      "followWithAbstracts": "Like `follow`, follows all typedefs of `t` to reach the actual type.\n\nWill however follow also abstracts to their underlying implementation,\nif they are not a @:coreType abstract\n\nIf `t` is null, an internal exception is thrown.\n\nUsage example:\nvar t = Context.typeof(macro new Map<String, String>());\ntrace(t); // TAbstract(Map,[TInst(String,[]),TInst(String,[])])\ntrace(t.followWithAbstracts()); // TInst(haxe.ds.StringMap, [TInst(String,[])])\n",
      "unify": "Returns true if `t1` and `t2` unify, false otherwise.\n",
      "getClass": "Tries to extract the class instance stored inside `t`.\n\nIf `t` is a class instance `TInst(c,pl)`, c is returned.\n\nIf `t` is of a different type, an exception of type String is thrown.\n\nIf `t` is null, the result is null.\n",
      "getEnum": "Tries to extract the enum instance stored inside `t`.\n\nIf `t` is an enum instance `TEnum(e,pl)`, e is returned.\n\nIf `t` is of a different type, an exception of type String is thrown.\n\nIf `t` is null, the result is null.\n",
      "applyTypeParameters": "Applies the type parameters `typeParameters` to type `t` with the given\ntypes `concreteTypes`.\n\nThis function replaces occurrences of type parameters in `t` if they are\npart of `typeParameters`. The array index of such a type parameter is\nthen used to lookup the concrete type in `concreteTypes`.\n\nIf `typeParameters.length` is not equal to `concreteTypes.length`, an\nexception of type `String` is thrown.\n\nIf `typeParameters.length` is 0, `t` is returned unchanged.\n\nIf either argument is `null`, the result is unspecified.\n",
      "map": "Transforms `t` by calling `f` on each of its subtypes.\n\nIf `t` is a compound type, `f` is called on each of its components.\n\nOtherwise `t` is returned unchanged.\n\nThe following types are considered compound:\n- TInst, TEnum, TType and TAbstract with type parameters\n- TFun\n- TAnonymous\n\nIf `t` or `f` are null, the result is unspecified.\n",
      "iter": "Calls function `f` on each component of type `t`.\n\nIf `t` is not a compound type, this operation has no effect.\n\nThe following types are considered compound:\n- TInst, TEnum, TType and TAbstract with type parameters\n- TFun\n- TAnonymous\n\nIf `t` or `f` are null, the result is unspecified.\n",
      "toString": "Converts type `t` to a human-readable String representation.\n",
      "setVarName": "Changes the name of the variable in the typed expression.\n",
      "toModuleType": "Converts type `t` to `haxe.macro.Type.ModuleType`.\n",
      "fromModuleType": "Creates a type from the `haxe.macro.Type.ModuleType` argument.\n",
      "toBaseType": "Converts type `t` to `haxe.macro.Type.BaseType`.\n",
      "resolveTypeParameters": "Calls `f` for each missing `TypeParameter` within Type `type`.\nThe `Type` returned from `f` fills the vacant parameter in a\ncopy returned by the function.\n\nIf `type` does not use type parameters, or all of the type\nparameters are defined, `type` is returned unchanged.\n\nExcessive type parameters are truncated.\n\nIf `recursive` is true, all subtypes are resolved.\n\nThe parameters provided to `f` are:\n- The `TypeParameter` being resolved.\n- The `Type` missing a type parameter.\n- The `Int` index of type parameter being resolved.\n\nMissing type parameters may cause fatal compiler errors.\nTherefore, this function should be called on user generated\n`Type`s prior to passing to macro API functions such as\n`Context.follow` or `Context.unify`.\n",
      "findField": "Resolves the field named `name` on class `c`.\n\nIf `isStatic` is true, the classes' static fields are checked. Otherwise\nthe classes' member fields are checked.\n\nIf the field is found, it is returned. Otherwise if `c` has a super\nclass, `findField` recursively checks that super class. Otherwise null\nis returned.\n\nIf any argument is null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntArithmetic": {
    "doc": "A collection of static helper functions for performing arithmetic\non `BigInt_` objects.\n",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntArithmetic.hx",
    "functions": {
      "compare": "Compare two big integers.\n\nReturns -1 if `a < b`; otherwise\nreturns 1 if `a > b`; otherwise\nreturns 0 (`a == b`).\n",
      "negate": "Perform the unary negation of big integer `operand` and put\nthe result into big integer `result`.\n\nOk for `result` and `operand` to be the same object.\n",
      "add": "Add big integer `operand2` to big integer `operand1` and put\nthe result into big integer `result`.\n\nOk for `result`, `operand1`, and `operand2` to be the same object.\n",
      "addInt": "Add integer `operand2` to big integer `operand1` and put the\nresult into big integer `result`.\n\nOk for `result` and `operand1` to be the same object.\n",
      "subtract": "Subtract big integer `operand2` from big integer `operand1`\nand put the result into big integer `result`.\n\nOk for `result`, `operand1`, and `operand2` to be the same object.\n",
      "subtractInt": "Subtract integer `operand2` from big integer `operand1` and\nput the result into big integer `result`.\n\nOk for `result` and `operand1` to be the same object.\n",
      "multiplyInt": "Multiply big integer `operand1` by integer `operand2` and put\nthe result into `result`.\n\n`result` may not refer the same object as either `operand1`\nor `operand2`; however, `operand1` and `operand2` may be the\nsame object.\n",
      "multiplyTraditional": "Multiply big integer `operand1` by big integer `operand2` and\nput the result into `result`.\n\n`result` may not refer the same object as either `operand1`\nor `operand2`; however, `operand1` and `operand2` may be the\nsame object.\n",
      "divideInt": "Divide the big integer `dividend` by the integer `divisor`.\nThe quotient of the division is put into `quotientOut`;\nthe remainder is the return value.\n\n`quotientOut` may refer to `dividend`.\n\n`work`, if supplied, must not refer to any of the inputs.\n",
      "divide": "Divide the big integer `dividend` by the big integer `divisor`.\nThe quotient of the division is put into `quotientOut`;\nthe remainder is put into `remainderOut`.\n\n`remainderOut` may be `null` if the remainder value is not\nneeded.\n\n`dividend` and `divisor` may refer to the same object.\n\n`quotientOut` and `remainderOut` must not refer to the same\nobject; but either may refer to the inputs.\n\n`work`, if supplied, must not refer to any of the inputs.\n",
      "arithmeticShiftLeft": "Shift big integer `operand1` to the left by `operand2` bits\nand put the result into big integer `result`.\n\nOk for `result` and `operand1` to be the same object.\n",
      "arithmeticShiftRight": "Shift big integer `operand1` to the right by `operand2` bits\nand put the result into big integer `result`.\n\nOk for `result` and `operand1` to be the same object.\n",
      "getBit": "Returns the value, 0 or 1, of the bit at 2^`index` place.\n",
      "bitwiseAndInt": "Returns the bitwise AND of `operand1` with `operand2`.\n",
      "bitwiseAnd": "Returns the bitwise AND of two big integers.\n@return A new `BigInt_` holding the result.\n",
      "bitwiseOr": "Returns the bitwise OR of `operand1` with `operand2`.\n",
      "bitwiseXor": "Returns the bitwise XOR of two big integers.\n@return A new `BigInt_` holding the result.\n",
      "bitwiseNot": "Returns the bitwise NOT (inversion) of a big integer.\n@return A new `BigInt_` holding the result.\n",
      "floorLog2": "Returns `floor(log2(input))`.\n@param input The `BigInt_` operand.\n@return The integer base-2 logarithm.\n",
      "square": "Squaring operation using power-of-two splitting.\n@param result The output BigInt for the square\n@param operand The operand to square\n"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntException": {
    "doc": "An exception thrown for errors during `BigInt` operations.\nIt wraps a `BigIntError` value to provide specific details.\n",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntException.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.math.bigint.BigIntHelper": {
    "doc": "A collection of low-level, static Int manipulation helper functions.\n",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntHelper.hx",
    "functions": {
      "bitLen": "Calculates the bit length of a signed 32-bit integer.\n@param x The integer value.\n@return The number of bits required to represent `x`.\n",
      "clp2": "\"Ceiling power of two\" -- round up to the least power of two\ngreater than or equal to input `x`, which is interpreted as\nunsigned.\n",
      "u32gtu32": "Unsigned greater than comparison.\n\nReturns `true` if `a > b` when both `a` and `b` are\ninterpreted as unsigned integers; `false` otherwise.\n",
      "u32divu16": "Integer division of unsigned 32-bit integer by unsigned 16-bit integer.\n\nResult is undefined when `divisor` <= 0 or `divisor` >= 2^16.\n",
      "u32geu32": "Unsigned greater than or equal comparison.\nReturns `true` if `a >= b` when both `a` and `b` are\ninterpreted as unsigned integers; `false` otherwise.\n",
      "ntz": "Number of trailing zeros - return the number of trailing\n0-value bits\n"
    },
    "fields": {}
  },
  "haxe.math.bigint.BigIntTools": {
    "doc": "A collection of high-level static utility functions for `BigInt`.\n",
    "path": "haxe\\std\\haxe\\math\\bigint\\BigIntTools.hx",
    "functions": {
      "isBigInt": "Checks if a dynamic value is a `BigInt`.\n@param value The value to check.\n@return `true` if the value is of type `BigInt`.\n",
      "castFrom": "Casts a dynamic value to a `BigInt`.\n@param value The value to cast.\n@return The value as a `BigInt`.\n",
      "parseValueUnsigned": "Parses a dynamic value into an unsigned `BigInt`.\nSupports `String`, `Int`, and other `BigInt` types.\n@param value The value to parse.\n@return A new `BigInt` instance.\n",
      "parseStringUnsigned": "Parses a string representing an unsigned integer into a `BigInt`.\nThis internal helper handles decimal strings, and hexadecimal strings\nthat are prefixed with \"0x\".\n@param value The string to be parsed.\n@return A new `BigInt` instance representing the unsigned value.\n"
    },
    "fields": {}
  },
  "haxe.rtti.CType": {
    "doc": "The (dot-)path of the runtime type.\n*/\ntypedef Path = String;\n\n/**\nA list of strings representing the targets where the type is available.\n*/\ntypedef Platforms = Array<String>;\n\n/**\nThe function argument runtime type information.\n*/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\nThe runtime member types.\n",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.Rights": {
    "doc": "The type parameters in the runtime type information.\n*/\ntypedef PathParams = {\n/**\nThe path of the type.\n*/\nvar path:Path;\n\n/**\nThe array of parameters types.\n*/\nvar params:Array<CType>;\n};\n\n/**\nAn array of strings representing the names of the type parameters the type\nhas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\nRepresents the runtime rights of a type.\n",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "params": "The array of parameters types.\n",
      "name": "An array of strings representing the names of the type parameters the type\nhas. As of Haxe 3.2.0, this does not include the constraints.\n*/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\nRepresents the runtime rights of a type.\n*/\nenum Rights {\nRNormal;\nRNo;\nRCall(m:String);\nRMethod;\nRDynamic;\nRInline;\n}\n\n/**\nThe list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\nThe runtime class field information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n/**\nThe name of the field.\n"
    }
  },
  "haxe.rtti.TypeTree": {
    "doc": "The list of runtime metadata.\n*/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\nThe runtime class field information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n*/\ntypedef ClassField = {\n/**\nThe name of the field.\n*/\nvar name:String;\n\n/**\nThe type of the field.\n*/\nvar type:CType;\n\n/**\nWhether or not the field is `public`.\n*/\nvar isPublic:Bool;\n\n/**\nWhether or not the field is `final`.\n*/\nvar isFinal:Bool;\n\n/**\nWhether or not the field overrides another field.\n*/\nvar isOverride:Bool;\n\n/**\nThe documentation of the field. This information is only available\nif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\nif the field has no documentation, the value is `null`.\n*/\nvar doc:Null<String>;\n\n/**\nThe [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\nbehavior of the field.\n*/\nvar get:Rights;\n\n/**\nThe [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\nbehavior of the field.\n*/\nvar set:Rights;\n\n/**\nAn array of strings representing the names of the type parameters\nthe field has.\n*/\nvar params:TypeParams;\n\n/**\nA list of strings representing the targets where the field is available.\n*/\nvar platforms:Platforms;\n\n/**\nThe meta data the field was annotated with.\n*/\nvar meta:MetaData;\n\n/**\nThe line number where the field is defined. This information is only\navailable if the field has an expression.\nOtherwise the value is `null`.\n*/\nvar line:Null<Int>;\n\n/**\nThe list of available overloads for the fields or `null` if no overloads\nexists.\n*/\nvar overloads:Null<Array<ClassField>>;\n\n/**\nThe actual expression of the field or `null` if there is no expression.\n*/\nvar expr:Null<String>;\n};\n\n/**\nThe general runtime type information.\n*/\ntypedef TypeInfos = {\n/**\nThe type path of the type.\n*/\nvar path:Path;\n\n/**\nThe type path of the module containing the type.\n*/\nvar module:Path;\n\n/**\nThe full slash path of the .hx file containing the type.\nThis might be `null` in case there is no such file, e.g. if the\ntype is defined through a macro.\n*/\nvar file:Null<String>;\n\n/**\nAn array of strings representing the names of the type parameters the\ntype has.\n*/\nvar params:TypeParams;\n\n/**\nThe documentation of the type. This information is only available\nif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\nthe constructor has no documentation, the value is `null`.\n*/\nvar doc:Null<String>;\n\n/**\nWhether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n*/\nvar isPrivate:Bool;\n\n/**\nA list of strings representing the targets where the type is available.\n*/\nvar platforms:Platforms;\n\n/**\nThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\nannotated with.\n*/\nvar meta:MetaData;\n};\n\n/**\nThe runtime class definition information.\n*/\ntypedef Classdef = TypeInfos & {\n/**\nWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n*/\nvar isExtern:Bool;\n\n/**\nWhether or not the class is `final`.\n*/\nvar isFinal:Bool;\n\n/**\nWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n*/\nvar isInterface:Bool;\n\n/**\nThe class' parent class defined by its type path and list of type\nparameters.\n*/\nvar superClass:Null<PathParams>;\n\n/**\nThe list of interfaces defined by their type path and list of type\nparameters.\n*/\nvar interfaces:Array<PathParams>;\n\n/**\nThe list of member [class fields](https://haxe.org/manual/class-field.html).\n*/\nvar fields:Array<ClassField>;\n\n/**\nThe list of static class fields.\n*/\nvar statics:Array<ClassField>;\n\n/**\nThe type which is dynamically implemented by the class or `null` if no\nsuch type exists.\n*/\nvar tdynamic:Null<CType>;\n};\n\n/**\nThe runtime enum constructor information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n/**\nThe name of the constructor.\n*/\nvar name:String;\n\n/**\nThe list of arguments the constructor has or `null` if no arguments are\navailable.\n*/\nvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n/**\nThe documentation of the constructor. This information is only available\nif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\nthe constructor has no documentation, the value is `null`.\n*/\nvar doc:String;\n\n/**\nA list of strings representing the targets where the constructor is\navailable.\n*/\nvar platforms:Platforms;\n\n/**\nThe meta data the constructor was annotated with.\n*/\nvar meta:MetaData;\n};\n\n/**\nThe enum runtime type information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n/**\nWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n*/\nvar isExtern:Bool;\n\n/**\nThe list of enum constructors.\n*/\nvar constructors:Array<EnumField>;\n};\n\n/**\nThe typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n/**\nThe type of the typedef.\n*/\nvar type:CType;\n\n/**\nThe types of the typedef, by platform.\n*/\nvar types:Map<String, CType>; // by platform\n\n};\n\n/**\nThe abstract type runtime information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n*/\ntypedef Abstractdef = TypeInfos & {\nvar to:Array<{t:CType, field:Null<String>}>;\nvar from:Array<{t:CType, field:Null<String>}>;\nvar impl:Classdef;\nvar athis:CType;\n};\n\n/**\nThe tree types of the runtime type.\n",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {
      "type": "The typedef runtime information.\n*/\ntypedef Typedef = TypeInfos & {\n/**\nThe type of the typedef.\n",
      "isPublic": "Whether or not the field is `public`.\n",
      "isFinal": "Whether or not the class is `final`.\n",
      "isOverride": "Whether or not the field overrides another field.\n",
      "doc": "The documentation of the constructor. This information is only available\nif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\nthe constructor has no documentation, the value is `null`.\n",
      "get": "The [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\nbehavior of the field.\n",
      "set": "The [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\nbehavior of the field.\n",
      "params": "An array of strings representing the names of the type parameters the\ntype has.\n",
      "platforms": "A list of strings representing the targets where the constructor is\navailable.\n",
      "meta": "The meta data the constructor was annotated with.\n",
      "line": "The line number where the field is defined. This information is only\navailable if the field has an expression.\nOtherwise the value is `null`.\n",
      "overloads": "The list of available overloads for the fields or `null` if no overloads\nexists.\n",
      "expr": "The actual expression of the field or `null` if there is no expression.\n",
      "path": "The general runtime type information.\n*/\ntypedef TypeInfos = {\n/**\nThe type path of the type.\n",
      "module": "The type path of the module containing the type.\n",
      "file": "The full slash path of the .hx file containing the type.\nThis might be `null` in case there is no such file, e.g. if the\ntype is defined through a macro.\n",
      "isPrivate": "Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n",
      "isExtern": "The enum runtime type information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n*/\ntypedef Enumdef = TypeInfos & {\n/**\nWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n",
      "isInterface": "Whether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n",
      "superClass": "The class' parent class defined by its type path and list of type\nparameters.\n",
      "interfaces": "The list of interfaces defined by their type path and list of type\nparameters.\n",
      "fields": "The list of member [class fields](https://haxe.org/manual/class-field.html).\n",
      "statics": "The list of static class fields.\n",
      "tdynamic": "The type which is dynamically implemented by the class or `null` if no\nsuch type exists.\n",
      "name": "The runtime enum constructor information.\n\n@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n*/\ntypedef EnumField = {\n/**\nThe name of the constructor.\n",
      "args": "The list of arguments the constructor has or `null` if no arguments are\navailable.\n",
      "constructors": "The list of enum constructors.\n",
      "types": "The types of the typedef, by platform.\n"
    }
  },
  "haxe.rtti.TypeApi": {
    "doc": "Array of `TypeTree`.\n*/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\nContains type and equality checks functionalities for RTTI.\n",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.rtti.CTypeTools": {
    "doc": "Returns `true` if the given `CType` is a variable or `false` if it is a\nfunction.\n*/\npublic static function isVar(t:CType) {\nreturn switch (t) {\ncase CFunction(_, _): false;\ndefault: true;\n}\n}\n\nstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\nvar it = l2.iterator();\nfor (e1 in l1) {\nif (!it.hasNext())\nreturn false;\nvar e2 = it.next();\nif (!f(e1, e2))\nreturn false;\n}\nif (it.hasNext())\nreturn false;\nreturn true;\n}\n\n/**\nUnlike `r1 == r2`, this function performs a deep equality check on\nthe given `Rights` instances.\n\nIf `r1` or `r2` are `null`, the result is unspecified.\n*/\npublic static function rightsEq(r1:Rights, r2:Rights) {\nif (r1 == r2)\nreturn true;\nswitch (r1) {\ncase RCall(m1):\nswitch (r2) {\ncase RCall(m2):\nreturn m1 == m2;\ndefault:\n}\ndefault:\n}\nreturn false;\n}\n\n/**\nUnlike `t1 == t2`, this function performs a deep equality check on\nthe given `CType` instances.\n\nIf `t1` or `t2` are `null`, the result is unspecified.\n*/\npublic static function typeEq(t1:CType, t2:CType) {\nswitch (t1) {\ncase CUnknown:\nreturn t2 == CUnknown;\ncase CEnum(name, params):\nswitch (t2) {\ncase CEnum(name2, params2):\nreturn name == name2 && leq(typeEq, params, params2);\ndefault:\n}\ncase CClass(name, params):\nswitch (t2) {\ncase CClass(name2, params2):\nreturn name == name2 && leq(typeEq, params, params2);\ndefault:\n}\ncase CAbstract(name, params):\nswitch (t2) {\ncase CAbstract(name2, params2):\nreturn name == name2 && leq(typeEq, params, params2);\ndefault:\n}\ncase CTypedef(name, params):\nswitch (t2) {\ncase CTypedef(name2, params2):\nreturn name == name2 && leq(typeEq, params, params2);\ndefault:\n}\ncase CFunction(args, ret):\nswitch (t2) {\ncase CFunction(args2, ret2):\nreturn leq(function(a:FunctionArgument, b:FunctionArgument) {\nreturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n}, args, args2) && typeEq(ret, ret2);\ndefault:\n}\ncase CAnonymous(fields):\nswitch (t2) {\ncase CAnonymous(fields2):\nreturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\ndefault:\n}\ncase CDynamic(t):\nswitch (t2) {\ncase CDynamic(t2):\nif ((t == null) != (t2 == null))\nreturn false;\nreturn t == null || typeEq(t, t2);\ndefault:\n}\n}\nreturn false;\n}\n\n/**\nUnlike `f1 == f2`, this function performs a deep equality check on\nthe given `ClassField` instances.\n\nIf `f1` or `f2` are `null`, the result is unspecified.\n*/\npublic static function fieldEq(f1:ClassField, f2:ClassField) {\nif (f1.name != f2.name)\nreturn false;\nif (!typeEq(f1.type, f2.type))\nreturn false;\nif (f1.isPublic != f2.isPublic)\nreturn false;\nif (f1.doc != f2.doc)\nreturn false;\nif (!rightsEq(f1.get, f2.get))\nreturn false;\nif (!rightsEq(f1.set, f2.set))\nreturn false;\nif ((f1.params == null) != (f2.params == null))\nreturn false;\nif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\nreturn false;\nreturn true;\n}\n\n/**\nUnlike `c1 == c2`, this function performs a deep equality check on\nthe arguments of the enum constructors, if exists.\n\nIf `c1` or `c2` are `null`, the result is unspecified.\n*/\npublic static function constructorEq(c1:EnumField, c2:EnumField) {\nif (c1.name != c2.name)\nreturn false;\nif (c1.doc != c2.doc)\nreturn false;\nif ((c1.args == null) != (c2.args == null))\nreturn false;\nif (c1.args != null && !leq(function(a, b) {\nreturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n}, c1.args, c2.args))\nreturn false;\nreturn true;\n}\n}\n\n/**\nThe `CTypeTools` class contains some extra functionalities for handling\n`CType` instances.\n",
    "path": "haxe\\std\\haxe\\rtti\\CType.hx",
    "functions": {
      "rightsEq": "Unlike `r1 == r2`, this function performs a deep equality check on\nthe given `Rights` instances.\n\nIf `r1` or `r2` are `null`, the result is unspecified.\n",
      "typeEq": "Unlike `t1 == t2`, this function performs a deep equality check on\nthe given `CType` instances.\n\nIf `t1` or `t2` are `null`, the result is unspecified.\n",
      "fieldEq": "Unlike `f1 == f2`, this function performs a deep equality check on\nthe given `ClassField` instances.\n\nIf `f1` or `f2` are `null`, the result is unspecified.\n",
      "constructorEq": "Unlike `c1 == c2`, this function performs a deep equality check on\nthe arguments of the enum constructors, if exists.\n\nIf `c1` or `c2` are `null`, the result is unspecified.\n",
      "toString": "The `CTypeTools` class contains some extra functionalities for handling\n`CType` instances.\n*/\nclass CTypeTools {\n/**\nGet the string representation of `CType`.\n"
    },
    "fields": {}
  },
  "haxe.rtti.Meta": {
    "doc": "An API to access classes and enums metadata at runtime.\n\n@see <https://haxe.org/manual/cr-rtti.html>\n",
    "path": "haxe\\std\\haxe\\rtti\\Meta.hx",
    "functions": {
      "getStatics": "Returns the metadata that were declared for the given class static fields\n",
      "getFields": "Returns the metadata that were declared for the given class fields or enum constructors\n"
    },
    "fields": {}
  },
  "haxe.rtti.Rtti": {
    "doc": "Rtti is a helper class which supplements the `@:rtti` metadata.\n\n@see <https://haxe.org/manual/cr-rtti.html>\n",
    "path": "haxe\\std\\haxe\\rtti\\Rtti.hx",
    "functions": {
      "hasRtti": "Tells if `c` has runtime type information.\n\nIf `c` is `null`, the result is unspecified.\n"
    },
    "fields": {}
  },
  "haxe.rtti.XmlParser": {
    "doc": "XmlParser processes the runtime type information (RTTI) which\nis stored as a XML string in a static field `__rtti`.\n\n@see <https://haxe.org/manual/cr-rtti.html>\n",
    "path": "haxe\\std\\haxe\\rtti\\XmlParser.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.xml.Access": {
    "doc": "The `haxe.xml.Access` API helps providing a fast dot-syntax access to the\nmost common `Xml` methods.\n",
    "path": "haxe\\std\\haxe\\xml\\Access.hx",
    "functions": {},
    "fields": {
      "innerData": "The inner PCDATA or CDATA of the node.\n\nAn exception is thrown if there is no data or if there not only data\nbut also other nodes.\n",
      "innerHTML": "The XML string built with all the sub nodes, excluding the current one.\n",
      "node": "Access to the first sub element with the given name.\n\nAn exception is thrown if the element doesn't exists.\nUse `hasNode` to check the existence of a node.\n\n```haxe\nvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\nvar user = access.node.user;\nvar name = user.node.name;\ntrace(name.innerData); // John\n\n// Uncaught Error: Document is missing element password\nvar password = user.node.password;\n```\n",
      "nodes": "Access to the List of elements with the given name.\n```haxe\nvar fast = new haxe.xml.Access(Xml.parse(\"\n<users>\n<user name='John'/>\n<user name='Andy'/>\n<user name='Dan'/>\n</users>\"\n));\n\nvar users = fast.node.users;\nfor (user in users.nodes.user) {\ntrace(user.att.name);\n}\n```\n",
      "att": "Access to a given attribute.\n\nAn exception is thrown if the attribute doesn't exists.\nUse `has` to check the existence of an attribute.\n\n```haxe\nvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\nvar user = f.node.user;\nif (user.has.name) {\ntrace(user.att.name); // Mark\n}\n```\n",
      "has": "Check the existence of an attribute with the given name.\n",
      "hasNode": "Check the existence of a sub node with the given name.\n\n```haxe\nvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\nvar user = f.node.user;\nif (user.hasNode.age) {\ntrace(user.node.age.innerData); // 31\n}\n```\n",
      "elements": "The list of all sub-elements which are the nodes with type `Xml.Element`.\n"
    }
  },
  "haxe.xml.Printer": {
    "doc": "This class provides utility methods to convert Xml instances to\nString representation.\n",
    "path": "haxe\\std\\haxe\\xml\\Printer.hx",
    "functions": {},
    "fields": {}
  },
  "haxe.zip.InflateImpl": {
    "doc": "A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.\n",
    "path": "haxe\\std\\haxe\\zip\\InflateImpl.hx",
    "functions": {},
    "fields": {}
  },
  "hl.CArray": {
    "doc": "CArray is a compact array where all objects are memory aligned and stored as a single GC block.\nYou must hold a reference to the CArray while any of the objects it contains is still referenced somewhere.\n",
    "path": "haxe\\std\\hl\\CArray.hx",
    "functions": {},
    "fields": {}
  },
  "hl.Format": {
    "doc": "These are some bindings for the HL `fmt.hdll` library, which contains various low level formats handling.\n",
    "path": "haxe\\std\\hl\\Format.hx",
    "functions": {},
    "fields": {}
  },
  "hl.UI": {
    "doc": "These are the bindings for the HL `ui.hdll` library, which contains some low level system access.\n",
    "path": "haxe\\std\\hl\\UI.hx",
    "functions": {},
    "fields": {}
  },
  "js.Lib": {
    "doc": "Platform-specific JavaScript Library. Provides some platform-specific functions\nfor the JavaScript target.\n",
    "path": "haxe\\std\\js\\Lib.hx",
    "functions": {
      "dynamicImport": "Inserts an `import` expression that loads JavaScript object from\na module or file specified in the `module` argument.\n",
      "alert": "Display an alert message box containing the given message.\n@deprecated Use Browser.alert() instead.\n",
      "getOriginalException": "Inserts a `require` expression that loads JavaScript object from\na module or file specified in the `module` argument.\n\nThis is only supported in environments where `require` function\nis available, such as Node.js or RequireJS.\n*/\nextern public static inline function require(module:String):Dynamic {\nreturn js.Syntax.code(\"require\")(module);\n}\n\n/**\nNative JavaScript `parseInt` function.\n\nIts specification is different from `Std.parseInt`, so one\nmight want to access the native one.\n*/\npublic static var parseInt(get, never):(string:String, ?radix:Int) -> Float;\n\nextern static inline function get_parseInt():(string:String, ?radix:Int) -> Float {\nreturn js.Syntax.code(\"parseInt\");\n}\n\n/**\nReturns JavaScript `undefined` value.\n\nNote that this is only needed in very rare cases when working with external JavaScript code.\n\nIn Haxe, `null` is used to represent the absence of a value.\n*/\npublic static var undefined(get, never):Dynamic;\n\nstatic inline function get_undefined():Dynamic {\nreturn js.Syntax.code(\"undefined\");\n}\n\n/**\n`nativeThis` is the JavaScript `this`, which is semantically different\nfrom the Haxe `this`. Use `nativeThis` only when working with external\nJavaScript code.\n\nIn Haxe, `this` is always bound to a class instance.\nIn JavaScript, `this` in a function can be bound to an arbitrary\nvariable when the function is called using `func.call(thisObj, ...)` or\n`func.apply(thisObj, [...])`.\n\nRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n*/\npublic static var nativeThis(get, never):Dynamic;\n\nextern static inline function get_nativeThis():Dynamic {\nreturn js.Syntax.code(\"this\");\n}\n\n/**\nCall JavaScript `typeof` operator on the `o` value\nand return a string representing the JavaScript type of a value.\n\nRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\nextern public static inline function typeof(o:Dynamic):String {\nreturn js.Syntax.typeof(o);\n}\n\n/**\nAn alias of the JS \"global\" object.\n\nConcretely, it is set as the first defined value in the list of\n`window`, `global`, `self`, and `this` in the top-level of the compiled output.\n*/\npublic static var global(get, never):Dynamic;\n\nextern static inline function get_global():Dynamic {\nreturn untyped __define_feature__(\"js.Lib.global\", js.Syntax.code(\"$global\")); // $global is generated by the compiler\n}\n\n/**\nRe-throw last caught exception, preserving original stack information.\n\nCalling this is only possible inside a catch statement.\n*/\n@:pure(false) public static function rethrow() {\n// function is implemented in the compiler\n}\n\n/**\nGet original caught exception object, before unwrapping the `js.Boot.HaxeError`.\n\nCan be useful if we want to redirect the original error into some external API (e.g. Promise or node.js callbacks).\n\nCalling this is only possible inside a catch statement.\n",
      "getNextHaxeUID": "Generate next unique id\n"
    },
    "fields": {
      "undefined": "Returns JavaScript `undefined` value.\n\nNote that this is only needed in very rare cases when working with external JavaScript code.\n\nIn Haxe, `null` is used to represent the absence of a value.\n",
      "nativeThis": "`nativeThis` is the JavaScript `this`, which is semantically different\nfrom the Haxe `this`. Use `nativeThis` only when working with external\nJavaScript code.\n\nIn Haxe, `this` is always bound to a class instance.\nIn JavaScript, `this` in a function can be bound to an arbitrary\nvariable when the function is called using `func.call(thisObj, ...)` or\n`func.apply(thisObj, [...])`.\n\nRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n",
      "global": "Call JavaScript `typeof` operator on the `o` value\nand return a string representing the JavaScript type of a value.\n\nRead more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n*/\nextern public static inline function typeof(o:Dynamic):String {\nreturn js.Syntax.typeof(o);\n}\n\n/**\nAn alias of the JS \"global\" object.\n\nConcretely, it is set as the first defined value in the list of\n`window`, `global`, `self`, and `this` in the top-level of the compiled output.\n"
    }
  },
  "js.html.ConsoleInstance": {
    "doc": "The `Console` object provides access to the browser's debugging console (e.g. the Web Console in Firefox). The specifics of how it works varies from browser to browser, but there is a de facto set of features that are typically provided.\n\nDocumentation [Console](https://developer.mozilla.org/en-US/docs/Web/API/Console) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/Console$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/Console>\n",
    "path": "haxe\\std\\js\\html\\ConsoleInstance.hx",
    "functions": {
      "clear": "Clear the console.\n",
      "count": "Log the number of times this line has been called with the given label.\n",
      "countReset": "Resets the value of the counter with the given label.\n",
      "debug": "Outputs a message to the console with the log level `\"debug\"`.\nNote: Starting with Chromium 58 this method only appears in Chromium browser consoles when level \"Verbose\" is selected.\n\n",
      "error": "Outputs an error message. You may use string substitution and additional arguments with this method.\n",
      "info": "Informative logging of information. You may use string substitution and additional arguments with this method.\n",
      "log": "For general output of logging information. You may use string substitution and additional arguments with this method.\n",
      "table": "Displays tabular data as a table.\n",
      "trace": "Outputs a stack trace.\n",
      "warn": "Outputs a warning message. You may use string substitution and additional arguments with this method.\n",
      "dir": "Displays an interactive listing of the properties of a specified JavaScript object. This listing lets you use disclosure triangles to examine the contents of child objects.\n",
      "dirxml": "Displays an XML/HTML Element representation of the specified object if possible or the JavaScript Object view if it is not possible.\n\n",
      "group": "Creates a new inline group, indenting all following output by another level. To move back out a level, call `groupEnd()`.\n",
      "groupCollapsed": "Creates a new inline group, indenting all following output by another level. However, unlike `group()` this starts with the inline group collapsed requiring the use of a disclosure button to expand it. To move back out a level, call `groupEnd()`.\n",
      "groupEnd": "Exits the current inline group.\n",
      "time": "Starts a timer with a name specified as an input parameter. Up to 10,000 simultaneous timers can run on a given page.\n",
      "timeLog": "Logs the value of the specified timer to the console.\n",
      "timeEnd": "Stops the specified timer and logs the elapsed time in seconds since it started.\n",
      "exception": "An alias for `error()`.\n",
      "timeStamp": "Adds a marker to the browser's Timeline or Waterfall tool.\n",
      "profile": "Starts the browser's built-in profiler (for example, the Firefox performance tool). You can specify an optional name for the profile.\n",
      "profileEnd": "Stops the profiler. You can see the resulting profile in the browser's performance tool (for example, the Firefox performance tool).\n"
    },
    "fields": {}
  },
  "js.html.abstract": {
    "doc": "The `XMLHttpRequestResponseType` type is an enumerated set of strings which are used to specify the type of data contained in the `response` of an `XMLHttpRequest`.\n\nDocumentation [XMLHttpRequestResponseType](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestResponseType>\n",
    "path": "haxe\\std\\js\\html\\XMLHttpRequestResponseType.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.ArrayBufferView": {
    "doc": "`ArrayBufferView` is a helper type representing any of the following JavaScript `TypedArray` types:\n\nDocumentation [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>\n",
    "path": "haxe\\std\\js\\lib\\ArrayBufferView.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.BufferSource": {
    "doc": "`BufferSource` is a typedef used to represent objects that are either themselves an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer),\nor which are a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) providing an [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView).\n\nThis is a helper type to simplify the specification. It isn't an interface and there are no objects implementing it.\n\nDocumentation [BufferSource](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/API/BufferSource>",
    "path": "haxe\\std\\js\\lib\\BufferSource.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.HaxeIterator": {
    "doc": "`HaxeIterator` wraps a JavaScript native iterator object to enable for-in iteration in haxe.\nIt can be used directly: `new HaxeIterator(jsIterator)` or via using: `using HaxeIterator`.\n",
    "path": "haxe\\std\\js\\lib\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.KeyValue": {
    "doc": "Key/value access helper.\n",
    "path": "haxe\\std\\js\\lib\\KeyValue.hx",
    "functions": {},
    "fields": {}
  },
  "js.lib.NativeStringTools": {
    "doc": "Documentation [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n",
    "path": "haxe\\std\\js\\lib\\NativeStringTools.hx",
    "functions": {
      "localeCompare": "Returns a number indicating whether a reference string comes before or after or is\nthe same as the given string in sort order.",
      "toLocaleLowerCase": "The characters within a string are converted to lower case while respecting the current locale.\nFor most languages, this will return the same as toLowerCase().",
      "toLocaleUpperCase": "The characters within a string are converted to upper case while respecting the current locale.\nFor most languages, this will return the same as toUpperCase().",
      "charCodeAt": "The `charCodeAt()` method of String values returns an integer between 0\nand 65535 representing the UTF-16 code unit at the given index.\n\nIf `index` is out of range of `0` – `str.length - 1`, returns `NaN`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt",
      "replace": "The `replace()` method of String values returns a new string with one,\nsome, or all matches of a pattern replaced by a replacement.\n\nThe pattern can be a `String` or a `js.lib.RegExp`, and the replacement\ncan be a string or a function called for each match.\n\nIf pattern is a string, only the first occurrence will be replaced. The\noriginal string is left unchanged.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
    },
    "fields": {
      "NFD": "Normalization Form Canonical Decomposition.",
      "NFKC": "Normalization Form Compatibility Composition.",
      "NFKD": "Normalization Form Compatibility Decomposition."
    }
  },
  "js.lib.ObjectEntry": {
    "doc": "The `js.lib.Object` constructor creates an object wrapper.\n\nDocumentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Object\")\nextern class Object {\n/**\nThe Object.assign() method is used to copy the values of all enumerable\nown properties from one or more source objects to a target object. It\nwill return the target object.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n*/\nstatic function assign<TSource:{}, TDest:{}>(target:TSource, sources:Rest<{}>):TDest;\n\n/**\nThe Object.create() method create a new object, using an existing object\nto provide the newly created object's __proto__ . (see browser console\nfor visual evidence.)\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\nThe Object.defineProperties() method defines new or modifies existing\nproperties directly on an object, returning the object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\n*/\nstatic function defineProperties<T:{}>(obj:T, props:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\nThe static method Object.defineProperty() defines a new property directly\non an object, or modifies an existing property on an object, and returns\nthe object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n*/\n@:overload(function<T:{}, TProp>(obj:T, prop:Symbol, descriptor:ObjectPropertyDescriptor<TProp>):T {})\nstatic function defineProperty<T:{}, TProp>(obj:T, prop:String, descriptor:ObjectPropertyDescriptor<TProp>):T;\n\n/**\nThe Object.entries() method returns an array of a given object's own\nenumerable property [key, value] pairs, in the same order as that\nprovided by a for...in loop (the difference being that a for-in loop\nenumerates properties in the prototype chain as well).\n\nNote: this is an ES2017 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n/**\nThe Object.freeze() method freezes an object: that is, prevents new\nproperties from being added to it; prevents existing properties from\nbeing removed; and prevents existing properties, or their enumerability,\nconfigurability, or writability, from being changed, it also prevents the\nprototype from being changed.\nThe method returns the passed object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n*/\nstatic function freeze<T:{}>(obj:T):T;\n\n/**\nReturns a new object from an iterable of key-value pairs\n(reverses Object.entries).\n*/\n@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n/**\nThe Object.getOwnPropertyDescriptor() method returns a property\ndescriptor for an own property (that is, one directly present on an\nobject and not in the object's prototype chain) of a given object.\n\nIn ES5, if the first argument to this method is not an object (a\nprimitive), then it will cause a TypeError. In ES2015, a non-object\nfirst argument will be coerced to an object at first.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n/**\nThe Object.getOwnPropertyDescriptors() method returns all own property\ndescriptors of a given object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n/**\nThe Object.getOwnPropertyNames() method returns an array of all\nproperties (including non-enumerable properties except for those which\nuse Symbol) found directly upon a given object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n/**\nThe Object.getOwnPropertySymbols() method returns an array of all symbol\nproperties found directly upon a given object.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n/**\nThe Object.getPrototypeOf() method returns the prototype (i.e. the value\nof the internal [[Prototype]] property) of the specified object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n/**\nThe Object.is() method determines whether two values are the same value.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\nThe Object.is() method determines whether two values are the same value.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:deprecated(\"Use Object.isSame()\")\n@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\nThe Object.isExtensible() method determines if an object is extensible\n(whether it can have new properties added to it).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n/**\nThe Object.isFrozen() determines if an object is frozen.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n/**\nThe Object.isSealed() method determines if an object is sealed.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n/**\nThe Object.keys() method returns an array of a given object's own\nenumerable properties, in the same order as that provided by a for...in\nloop (the difference being that a for-in loop enumerates properties in\nthe prototype chain as well).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n/**\nThe Object.preventExtensions() method prevents new properties from ever\nbeing added to an object (i.e. prevents future extensions to the object).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\n*/\nstatic function preventExtensions<T:{}>(obj:T):T;\n\n/**\nThe Object.seal() method seals an object, preventing new properties from\nbeing added to it and marking all existing properties as\nnon-configurable. Values of present properties can still be changed as\nlong as they are writable.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\n*/\nstatic function seal<T:{}>(obj:T):T;\n\n/**\nThe Object.setPrototypeOf() method sets the prototype (i.e., the internal\n[[Prototype]] property) of a specified object to another object or null.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\n*/\nstatic function setPrototypeOf<T:{}, TProto:{}>(obj:T, proto:Null<TProto>):T;\n\n/**\nThe Object.values() method returns an array of a given object's own\nenumerable property values, in the same order as that provided by a\nfor...in loop (the difference being that a for-in loop enumerates\nproperties in the prototype chain as well).\n\nNote: this is an ES2017 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n*/\n@:pure static function values<T:{}>(obj:T):Array<Any>;\n\n/**\nAllows the addition of properties to all objects of type Object.\n*/\nstatic var prototype(default, never):ObjectPrototype;\n\n/**\nThe Object constructor creates an object wrapper.\n*/\n@:pure function new(?value:Any);\n}\n\n/**\nType for\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n/**\nReturns a boolean indicating whether an object contains the specified\nproperty as a direct property of that object and not inherited through\nthe prototype chain.\n*/\nvar hasOwnProperty(default, never):Function;\n\n/**\nReturns a boolean indicating whether the object this method is called\nupon is in the prototype chain of the specified object.\n*/\nvar isPrototypeOf(default, never):Function;\n\n/**\nReturns a boolean indicating if the internal enumerable attribute is set.\n*/\nvar propertyIsEnumerable(default, never):Function;\n\n/**\nCalls `toString()`.\n*/\nvar toLocaleString(default, never):Function;\n\n/**\nReturns a string representation of the object.\n*/\nvar toString(default, never):Function;\n\n/**\nReturns the primitive value of the specified object.\n*/\nvar valueOf(default, never):Function;\n}\n\n/**\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>\n*/\ntypedef ObjectPropertyDescriptor<TProp> = {\n/**\n`true` if and only if the type of this property descriptor may be\nchanged and if the property may be deleted from the corresponding object.\nDefaults to `false`.\n*/\nvar ?configurable:Bool;\n\n/**\n`true` if and only if this property shows up during enumeration of the\nproperties on the corresponding object.\nDefaults to `false`.\n*/\nvar ?enumerable:Bool;\n\n/**\nThe value associated with the property.\nCan be any valid JavaScript value (number, object, function, etc).\n*/\nvar ?value:TProp;\n\n/**\n`true` if and only if the value associated with the property may be\nchanged with an assignment operator.\nDefaults to `false`.\n*/\nvar ?writable:Bool;\n\n/**\nA function which serves as a getter for the property, or `undefined` if\nthere is no getter. When the property is accessed, this function is\ncalled without arguments and with `this` set to the object through which\nthe property is accessed (this may not be the object on which the\nproperty is defined due to inheritance).\nThe return value will be used as the value of the property.\n*/\nvar ?get:Void->TProp;\n\n/**\nA function which serves as a setter for the property, or undefined if\nthere is no setter. When the property is assigned to, this function\nis called with one argument (the value being assigned to the property)\nand with `this` set to the object through which the property is assigned.\n*/\nvar ?set:TProp->Void;\n}\n\n/**\nKey/value access helper for `js.lib.Object.entries()`.\n",
    "path": "haxe\\std\\js\\lib\\Object.hx",
    "functions": {
      "defineProperties": "The Object.create() method create a new object, using an existing object\nto provide the newly created object's __proto__ . (see browser console\nfor visual evidence.)\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n*/\n@:pure static function create<T>(proto:Null<{}>, ?propertiesObject:DynamicAccess<ObjectPropertyDescriptor<Any>>):T;\n\n/**\nThe Object.defineProperties() method defines new or modifies existing\nproperties directly on an object, returning the object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\n",
      "defineProperty": "The static method Object.defineProperty() defines a new property directly\non an object, or modifies an existing property on an object, and returns\nthe object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n",
      "freeze": "The Object.entries() method returns an array of a given object's own\nenumerable property [key, value] pairs, in the same order as that\nprovided by a for...in loop (the difference being that a for-in loop\nenumerates properties in the prototype chain as well).\n\nNote: this is an ES2017 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n*/\n@:pure static function entries<T:{}>(obj:T):Array<ObjectEntry>;\n\n/**\nThe Object.freeze() method freezes an object: that is, prevents new\nproperties from being added to it; prevents existing properties from\nbeing removed; and prevents existing properties, or their enumerability,\nconfigurability, or writability, from being changed, it also prevents the\nprototype from being changed.\nThe method returns the passed object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n",
      "preventExtensions": "Returns a new object from an iterable of key-value pairs\n(reverses Object.entries).\n*/\n@:pure static function fromEntries<T:{}>(iterable:Any):T;\n\n/**\nThe Object.getOwnPropertyDescriptor() method returns a property\ndescriptor for an own property (that is, one directly present on an\nobject and not in the object's prototype chain) of a given object.\n\nIn ES5, if the first argument to this method is not an object (a\nprimitive), then it will cause a TypeError. In ES2015, a non-object\nfirst argument will be coerced to an object at first.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n*/\n@:overload(function(obj:String, prop:Symbol):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function(obj:String, prop:String):Null<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>, propertyKey:Int):Null<ObjectPropertyDescriptor<T>> {})\n@:overload(function<T, TProp>(obj:T, prop:Symbol):Null<ObjectPropertyDescriptor<TProp>> {})\n@:pure static function getOwnPropertyDescriptor<T, TProp>(obj:T, prop:String):Null<ObjectPropertyDescriptor<TProp>>;\n\n/**\nThe Object.getOwnPropertyDescriptors() method returns all own property\ndescriptors of a given object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\n*/\n@:overload(function(target:String):DynamicAccess<ObjectPropertyDescriptor<String>> {})\n@:overload(function<T>(target:Array<T>):DynamicAccess<ObjectPropertyDescriptor<T>> {})\n@:pure static function getOwnPropertyDescriptors<T>(obj:T):DynamicAccess<ObjectPropertyDescriptor<Any>>;\n\n/**\nThe Object.getOwnPropertyNames() method returns an array of all\nproperties (including non-enumerable properties except for those which\nuse Symbol) found directly upon a given object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\n*/\n@:pure static function getOwnPropertyNames<T:{}>(obj:T):Array<String>;\n\n/**\nThe Object.getOwnPropertySymbols() method returns an array of all symbol\nproperties found directly upon a given object.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\n*/\n@:pure static function getOwnPropertySymbols<T:{}>(obj:T):Array<Symbol>;\n\n/**\nThe Object.getPrototypeOf() method returns the prototype (i.e. the value\nof the internal [[Prototype]] property) of the specified object.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n*/\n@:pure static function getPrototypeOf<T:{}, TProto>(obj:T):TProto;\n\n/**\nThe Object.is() method determines whether two values are the same value.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:native(\"is\") @:pure static function isSame<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\nThe Object.is() method determines whether two values are the same value.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n*/\n@:deprecated(\"Use Object.isSame()\")\n@:pure static function is<T:{}>(obj1:T, obj2:T):Bool;\n\n/**\nThe Object.isExtensible() method determines if an object is extensible\n(whether it can have new properties added to it).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n*/\n@:pure static function isExtensible<T:{}>(obj:T):Bool;\n\n/**\nThe Object.isFrozen() determines if an object is frozen.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n*/\n@:pure static function isFrozen<T:{}>(obj:T):Bool;\n\n/**\nThe Object.isSealed() method determines if an object is sealed.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n*/\n@:pure static function isSealed<T:{}>(obj:T):Bool;\n\n/**\nThe Object.keys() method returns an array of a given object's own\nenumerable properties, in the same order as that provided by a for...in\nloop (the difference being that a for-in loop enumerates properties in\nthe prototype chain as well).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n*/\n@:pure static function keys<T:{}>(obj:T):Array<String>;\n\n/**\nThe Object.preventExtensions() method prevents new properties from ever\nbeing added to an object (i.e. prevents future extensions to the object).\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\n",
      "seal": "The Object.seal() method seals an object, preventing new properties from\nbeing added to it and marking all existing properties as\nnon-configurable. Values of present properties can still be changed as\nlong as they are writable.\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\n",
      "setPrototypeOf": "The Object.setPrototypeOf() method sets the prototype (i.e., the internal\n[[Prototype]] property) of a specified object to another object or null.\n\nNote: this is an ES2015 feature\n\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\n"
    },
    "fields": {
      "hasOwnProperty": "The Object constructor creates an object wrapper.\n*/\n@:pure function new(?value:Any);\n}\n\n/**\nType for\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>\n*/\ntypedef ObjectPrototype = {\n/**\nReturns a boolean indicating whether an object contains the specified\nproperty as a direct property of that object and not inherited through\nthe prototype chain.\n",
      "isPrototypeOf": "Returns a boolean indicating whether the object this method is called\nupon is in the prototype chain of the specified object.\n",
      "propertyIsEnumerable": "Returns a boolean indicating if the internal enumerable attribute is set.\n",
      "toLocaleString": "Calls `toString()`.\n",
      "toString": "Returns a string representation of the object.\n",
      "valueOf": "Returns the primitive value of the specified object.\n"
    }
  },
  "js.lib.PromiseHandler": {
    "doc": "The Promise object represents the eventual completion (or failure) of an\nasynchronous operation and its resulting value.\n\nDocumentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Promise\")\nextern class Promise<T> {\n/**\nReturns a Promise object that is resolved with the given value. If the\nvalue is Thenable, the returned promise will \"follow\" that\nthenable, adopting its eventual state;\notherwise the returned promise will be fulfilled with the value.\nGenerally, when it's unknown when value is a promise or not,\nuse `Promise.resolve(value)` instead and work with the return value as\na promise.\n*/\n@:overload(function<T>(?value:T):Promise<T> {})\nstatic function resolve<T>(thenable:Thenable<T>):Promise<T>;\n\n/**\nReturns a Promise object that is rejected with the given reason.\n*/\nstatic function reject<T>(?reason:Dynamic):Promise<T>;\n\n/**\nReturns a promise that either fulfills when all of the promises in the\niterable argument have fulfilled or rejects as soon as one of the\npromises in the iterable argument rejects. If the returned promise\nfulfills, it is fulfilled with an array of the values from the\nfulfilled promises in the same order as defined in the iterable.\nIf the returned promise rejects, it is rejected with the reason from\nthe first promise in the iterable that rejected. This method can be\nuseful for aggregating results of multiple promises.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Array<Dynamic>> {})\nstatic function all<T>(iterable:Array<Promise<T>>):Promise<Array<T>>;\n\n/**\nReturns a promise that resolves after all of the given promises have either fulfilled or rejected,\nwith an array of objects that each describes the outcome of each promise.\n\nIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\nto complete successfully, or you'd always like to know the result of each promise.\n\nIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\non each other / if you'd like to immediately reject upon any of them rejecting.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Array<PromiseSettleOutcome<Dynamic>>> {})\nstatic function allSettled<T>(iterable:Array<Promise<T>>):Promise<Array<PromiseSettleOutcome<T>>>;\n\n/**\nReturns a promise that fulfills or rejects as soon as one of the\npromises in the iterable fulfills or rejects, with the value or reason\nfrom that promise.\n*/\n@:overload(function(iterable:Array<Dynamic>):Promise<Dynamic> {})\nstatic function race<T>(iterable:Array<Promise<T>>):Promise<T>;\n\n/** @throws DOMError */\nfunction new(init:(resolve:(value:T) -> Void, reject:(reason:Dynamic) -> Void) -> Void):Void;\n\n/**\nAppends fulfillment and rejection handlers to the promise and returns a\nnew promise resolving to the return value of the called handler, or to\nits original settled value if the promise was not handled\n(i.e. if the relevant handler onFulfilled or onRejected is not a function).\n*/\nfunction then<TOut>(onFulfilled:Null<PromiseHandler<T, TOut>>, ?onRejected:PromiseHandler<Dynamic, TOut>):Promise<TOut>;\n\n/**\nAppends a rejection handler callback to the promise, and returns a new\npromise resolving to the return value of the callback if it is called,\nor to its original fulfillment value if the promise is instead fulfilled.\n*/\n@:native(\"catch\")\n@:overload(function<TOut>(onRejected:PromiseHandler<Dynamic, TOut>):Promise<EitherType<T, TOut>> {})\nfunction catchError(onRejected:PromiseHandler<Dynamic, T>):Promise<T>;\n\n/**\nReturns a Promise. When the promise is settled, i.e either fulfilled or rejected,\nthe specified callback function is executed. This provides a way for code to be run\nwhether the promise was fulfilled successfully or rejected once the Promise has been dealt with.\n*/\nfunction finally(onFinally:() -> Void):Promise<T>;\n}\n\n/**\nHandler type for the Promise object.\n",
    "path": "haxe\\std\\js\\lib\\Promise.hx",
    "functions": {
      "reject": "Returns a Promise object that is rejected with the given reason.\n",
      "all": "Returns a promise that either fulfills when all of the promises in the\niterable argument have fulfilled or rejects as soon as one of the\npromises in the iterable argument rejects. If the returned promise\nfulfills, it is fulfilled with an array of the values from the\nfulfilled promises in the same order as defined in the iterable.\nIf the returned promise rejects, it is rejected with the reason from\nthe first promise in the iterable that rejected. This method can be\nuseful for aggregating results of multiple promises.\n",
      "allSettled": "Returns a promise that resolves after all of the given promises have either fulfilled or rejected,\nwith an array of objects that each describes the outcome of each promise.\n\nIt is typically used when you have multiple asynchronous tasks that are not dependent on one another\nto complete successfully, or you'd always like to know the result of each promise.\n\nIn comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent\non each other / if you'd like to immediately reject upon any of them rejecting.\n",
      "race": "Returns a promise that fulfills or rejects as soon as one of the\npromises in the iterable fulfills or rejects, with the value or reason\nfrom that promise.\n",
      "new": "@throws DOMError",
      "then": "Appends fulfillment and rejection handlers to the promise and returns a\nnew promise resolving to the return value of the called handler, or to\nits original settled value if the promise was not handled\n(i.e. if the relevant handler onFulfilled or onRejected is not a function).\n",
      "catchError": "Appends a rejection handler callback to the promise, and returns a new\npromise resolving to the return value of the callback if it is called,\nor to its original fulfillment value if the promise is instead fulfilled.\n",
      "finally": "Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,\nthe specified callback function is executed. This provides a way for code to be run\nwhether the promise was fulfilled successfully or rejected once the Promise has been dealt with.\n"
    },
    "fields": {}
  },
  "js.lib.RegExpMatch": {
    "doc": "Native JavaScript regular expressions.\n\nFor cross-platform regular expressions, use Haxe `EReg` class or\n[regexp literals](https://haxe.org/manual/std-regex.html).\n\n@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>\n*/\n@:native(\"RegExp\")\nextern class RegExp {\n/**\nIndicates whether or not the \"g\" flag is used with the regular expression.\n*/\nvar global(default, null):Bool;\n\n/**\nIndicates whether or not the \"i\" flag is used with the regular expression.\n*/\nvar ignoreCase(default, null):Bool;\n\n/**\nIndicates whether or not the \"m\" flag is used with the regular expression.\n*/\nvar multiline(default, null):Bool;\n\n/**\nThe source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.\n*/\nvar source(default, null):String;\n\n/**\nThe index at which to start the next match.\n*/\nvar lastIndex:Int;\n\n/**\nCreate a regular expression object for matching text with a pattern.\n*/\nfunction new(pattern:String, ?flags:String);\n\n/**\nExecute a search for a match in a specified string.\nReturns a result array, or null.\n*/\nfunction exec(str:String):Null<RegExpMatch>;\n\n/**\nExecute a search for a match between a regular expression and a specified string.\nReturns true or false.\n*/\nfunction test(str:String):Bool;\n\n/**\nReturn a string representing the regular expression.\n*/\nfunction toString():String;\n}\n\n/**\nA return value of the `RegExp.exec` method.\n",
    "path": "haxe\\std\\js\\lib\\RegExp.hx",
    "functions": {
      "exec": "Execute a search for a match in a specified string.\nReturns a result array, or null.\n",
      "test": "Execute a search for a match between a regular expression and a specified string.\nReturns true or false.\n",
      "toString": "Return a string representing the regular expression.\n"
    },
    "fields": {
      "ignoreCase": "Indicates whether or not the \"i\" flag is used with the regular expression.\n",
      "multiline": "Indicates whether or not the \"m\" flag is used with the regular expression.\n",
      "source": "The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.\n",
      "lastIndex": "The index at which to start the next match.\n",
      "index": "Create a regular expression object for matching text with a pattern.\n*/\nfunction new(pattern:String, ?flags:String);\n\n/**\nExecute a search for a match in a specified string.\nReturns a result array, or null.\n*/\nfunction exec(str:String):Null<RegExpMatch>;\n\n/**\nExecute a search for a match between a regular expression and a specified string.\nReturns true or false.\n*/\nfunction test(str:String):Bool;\n\n/**\nReturn a string representing the regular expression.\n*/\nfunction toString():String;\n}\n\n/**\nA return value of the `RegExp.exec` method.\n*/\nextern class RegExpMatch extends Array<String> {\n/**\nThe index of the search at which the result was found.\n",
      "input": "A copy of the search string.\n",
      "groups": "Named capturing groups or undefined if no named capturing groups were defined.\nSee [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.\n\nNote: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility).\n"
    }
  },
  "js.lib.SetKeyValueIterator": {
    "doc": "The `js.Set` object lets you store unique values of any type, whether\nprimitive values or object references.\n\nDocumentation [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n*/\n@:native(\"Set\")\nextern class Set<T> {\n/**\nThe number of values in the `js.Set` object.\n*/\nvar size(default, null):Int;\n\n/**\nIf an iterable object is passed, all of its elements will be added to\nthe new `js.Set`.\n*/\n@:pure function new(?iterable:Any);\n\n/**\nReturns a boolean asserting whether an element is present with the given\nvalue in the `js.Set` object or not.\n*/\n@:pure function has(value:T):Bool;\n\n/**\nAppends a new element with the given value to the `js.Set` object.\nReturns the `js.Set` object.\n*/\nfunction add(value:T):Set<T>;\n\n/**\nRemoves the element associated to the value and returns the value that\n`has(value)` would have previously returned.\n`has(value)` will return `false` afterwards.\n*/\nfunction delete(value:T):Bool;\n\n/**\nRemoves all elements from the `js.Set` object.\n*/\nfunction clear():Void;\n\n/**\nCalls `callback` once for each key-value pair present in the `js.Set`\nobject, in insertion order.\n\nIf a `thisArg` parameter is provided to forEach, it will be used as the\n`this` value for each callback.\n*/\nfunction forEach(callback:(value:T, key:T, set:Set<T>) -> Void, ?thisArg:Any):Void;\n\n/**\nReturns a new `js.lib.Iterator` object that contains the keys for each element\nin the `js.Set` object in insertion order.\n*/\nfunction keys():js.lib.Iterator<T>;\n\n/**\nReturns a new `js.lib.Iterator` object that contains the values for each\nelement in the `js.Set` object in insertion order.\n*/\nfunction values():js.lib.Iterator<T>;\n\n/**\nReturns a new `js.lib.Iterator` object that contains an array of\n`[value, value]` for each element in the `js.Set` object, in insertion\norder.\nThis is kept similar to the `js.Map` object, so that each entry has the\nsame value for its key and value here.\n*/\nfunction entries():js.lib.Iterator<KeyValue<T, T>>;\n\ninline function iterator():HaxeIterator<T> {\nreturn new HaxeIterator(this.values());\n}\n\ninline function keyValueIterator():SetKeyValueIterator<T> {\nreturn new SetKeyValueIterator(this);\n}\n}\n\n/**\nkey => value iterator for js.lib.Set, tracking the entry index for the key to match the behavior of haxe.ds.List\n",
    "path": "haxe\\std\\js\\lib\\Set.hx",
    "functions": {
      "delete": "Removes the element associated to the value and returns the value that\n`has(value)` would have previously returned.\n`has(value)` will return `false` afterwards.\n",
      "clear": "Removes all elements from the `js.Set` object.\n",
      "forEach": "Calls `callback` once for each key-value pair present in the `js.Set`\nobject, in insertion order.\n\nIf a `thisArg` parameter is provided to forEach, it will be used as the\n`this` value for each callback.\n",
      "keys": "Returns a new `js.lib.Iterator` object that contains the keys for each element\nin the `js.Set` object in insertion order.\n",
      "values": "Returns a new `js.lib.Iterator` object that contains the values for each\nelement in the `js.Set` object in insertion order.\n",
      "entries": "Returns a new `js.lib.Iterator` object that contains an array of\n`[value, value]` for each element in the `js.Set` object, in insertion\norder.\nThis is kept similar to the `js.Map` object, so that each entry has the\nsame value for its key and value here.\n"
    },
    "fields": {}
  },
  "lua.abstract": {
    "doc": "These are all global static methods within Lua.\n*/\n@:native(\"_G\")\nextern class Lua {\n/**\nA global variable that holds a string containing the current interpreter\nversion.\n*/\nstatic var _VERSION:String;\n\nstatic var arg:Table<Int, String>;\n\n/**\nPushes onto the stack the metatable in the registry.\n*/\nstatic function getmetatable(tbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n/**\nPops a table from the stack and sets it as the new metatable for the value\nat the given acceptable index.\n*/\nstatic function setmetatable(tbl:Table<Dynamic, Dynamic>, mtbl:Table<Dynamic, Dynamic>):Table<Dynamic, Dynamic>;\n\n/**\nPops a table from the stack and sets it as the new environment for the value\nat the given index. If the value at the given index is neither a function nor\na thread nor a userdata, lua_setfenv returns `0`.\nOtherwise it returns `1`.\n*/\nstatic function setfenv(i:Int, tbl:Table<Dynamic, Dynamic>):Void;\n\n/**\nAllows a program to traverse all fields of a table.\nIts first argument is a table and its second argument is an index in this\ntable. `next` returns the next index of the table and its associated value.\nWhen `i` is `null`, `next` returns an initial index and its associated value.\nWhen called with the last index, or with `null` in an empty table, `next`\nreturns `null`.  In particular, you can use `next(t)` to check whether a\ntable is empty.\n\nThe order in which the indices are enumerated is not specified, even for\nnumeric indices. (To traverse a table in numeric order, use a numerical for\nor the `ipairs` function).\n\nThe behavior of next is undefined if, during the traversal, any value\nto a non-existent field in the table is assigned. Existing fields may\nhowever be modified. In particular, existing fields may be cleared.\n*/\nstatic function next<K, V>(k:Table<K, V>, ?i:K):NextResult<K, V>;\n\n/**\nReceives an argument of any type and converts it to a string in a reasonable\nformat.\n\nFor complete control of how numbers are converted, use`NativeStringTools.format`.\n*/\nstatic function tostring(v:Dynamic):String;\n\nstatic function ipairs<K, V>(t:Table<K, V>):IPairsResult<K, V>;\n\nstatic function pairs<K, V>(t:Table<K, V>):PairsResult<K, V>;\n\nstatic function require(module:String):Dynamic;\n\n/**\nConverts the Lua value at the given acceptable base to `Int`.\nThe Lua value must be a number or a string convertible to a number,\notherwise `tonumber` returns `0`.\n*/\nstatic function tonumber(str:String, ?base:Int):Int;\n\n/**\nReturns the Lua type of its only argument as a string.\nThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`\n*/\nstatic function type(v:Dynamic):String;\n\n/**\nReceives any number of arguments, and prints their values to stdout,\nusing the tostring function to convert them to strings.\n`print` is not intended for formatted output, but only as a quick way to show\na value, typically for debugging.\n\nFor complete control of how numbers are converted, use `NativeStringTools.format`.\n*/\nstatic function print(v:haxe.extern.Rest<Dynamic>):Void;\n\n/**\nIf `n` is a number, returns all arguments after argument number `n`.\nOtherwise, `n` must be the string `\"#\"`, and select returns the total\nnumber of extra arguments it received.\n*/\nstatic function select(n:Dynamic, rest:Rest<Dynamic>):Dynamic;\n\n/**\nGets the real value of `table[index]`, without invoking any metamethod.\n*/\nstatic function rawget<K, V>(t:Table<K, V>, k:K):V;\n\n/**\nSets the real value of `table[index]` to value, without invoking any metamethod.\n*/\nstatic function rawset<K, V>(t:Table<K, V>, k:K, v:V):Void;\n\n/**\nThis function is a generic interface to the garbage collector.\nIt performs different functions according to its first argument.\n*/\nstatic function collectgarbage(opt:CollectGarbageOption, ?arg:Int):Int;\n\n/**\nIssues an error when the value of its argument `v` is `false` (i.e., `null`\nor `false`) otherwise, returns all its arguments. message is an error message.\nwhen absent, it defaults to \"assertion failed!\"\n*/\nstatic function assert<T>(v:T, ?message:String):T;\n\n/**\nLoads and runs the given file.\n*/\nstatic function dofile(filename:String):Void;\n\n/**\nGenerates a Lua error. The error message (which can actually be a Lua value\nof any type) must be on the stack top. This function does a long jump,\nand therefore never returns.\n*/\nstatic function error(message:String, ?level:Int):Void;\n\n/**\nCalls a function in protected mode.\n*/\nstatic function pcall(f:Function, rest:Rest<Dynamic>):PCallResult;\n\n/**\nReturns `true` if the two values in acceptable indices `v1` and `v2` are\nprimitively equal (that is, without calling metamethods).\nOtherwise returns `false`.\nAlso returns `false` if any of the indices are non valid.\n*/\nstatic function rawequal(v1:Dynamic, v2:Dynamic):Bool;\n\n/**\nThis function is similar to pcall, except that you can set a new error\nhandler.\n*/\nstatic function xpcall(f:Function, msgh:Function, rest:Rest<Dynamic>):PCallResult;\n\n/**\nLoads the chunk from file filename or from the standard input if no filename\nis given.\n*/\nstatic function loadfile(filename:String):LoadResult;\n\n/**\nLoads the chunk from given string.\n*/\nstatic function load(code:haxe.extern.EitherType<String, Void->String>):LoadResult;\n}\n\n/**\nEnum for describing garbage collection options\n",
    "path": "haxe\\std\\lua\\Lua.hx",
    "functions": {
      "setmetatable": "Pops a table from the stack and sets it as the new metatable for the value\nat the given acceptable index.\n",
      "setfenv": "Pops a table from the stack and sets it as the new environment for the value\nat the given index. If the value at the given index is neither a function nor\na thread nor a userdata, lua_setfenv returns `0`.\nOtherwise it returns `1`.\n",
      "next": "Allows a program to traverse all fields of a table.\nIts first argument is a table and its second argument is an index in this\ntable. `next` returns the next index of the table and its associated value.\nWhen `i` is `null`, `next` returns an initial index and its associated value.\nWhen called with the last index, or with `null` in an empty table, `next`\nreturns `null`.  In particular, you can use `next(t)` to check whether a\ntable is empty.\n\nThe order in which the indices are enumerated is not specified, even for\nnumeric indices. (To traverse a table in numeric order, use a numerical for\nor the `ipairs` function).\n\nThe behavior of next is undefined if, during the traversal, any value\nto a non-existent field in the table is assigned. Existing fields may\nhowever be modified. In particular, existing fields may be cleared.\n",
      "tostring": "Receives an argument of any type and converts it to a string in a reasonable\nformat.\n\nFor complete control of how numbers are converted, use`NativeStringTools.format`.\n",
      "tonumber": "Converts the Lua value at the given acceptable base to `Int`.\nThe Lua value must be a number or a string convertible to a number,\notherwise `tonumber` returns `0`.\n",
      "type": "Returns the Lua type of its only argument as a string.\nThe possible results of this function are:\n\n`\"nil\"` (a string, not the Lua value nil),\n`\"number\"`\n`\"string\"`\n`\"boolean\"`\n`\"table\"`\n`\"function\"`\n`\"thread\"`\n`\"userdata\"`\n",
      "print": "Receives any number of arguments, and prints their values to stdout,\nusing the tostring function to convert them to strings.\n`print` is not intended for formatted output, but only as a quick way to show\na value, typically for debugging.\n\nFor complete control of how numbers are converted, use `NativeStringTools.format`.\n",
      "select": "If `n` is a number, returns all arguments after argument number `n`.\nOtherwise, `n` must be the string `\"#\"`, and select returns the total\nnumber of extra arguments it received.\n",
      "rawget": "Gets the real value of `table[index]`, without invoking any metamethod.\n",
      "rawset": "Sets the real value of `table[index]` to value, without invoking any metamethod.\n",
      "collectgarbage": "This function is a generic interface to the garbage collector.\nIt performs different functions according to its first argument.\n",
      "assert": "Issues an error when the value of its argument `v` is `false` (i.e., `null`\nor `false`) otherwise, returns all its arguments. message is an error message.\nwhen absent, it defaults to \"assertion failed!\"\n",
      "dofile": "Loads and runs the given file.\n",
      "error": "Generates a Lua error. The error message (which can actually be a Lua value\nof any type) must be on the stack top. This function does a long jump,\nand therefore never returns.\n",
      "pcall": "Calls a function in protected mode.\n",
      "rawequal": "Returns `true` if the two values in acceptable indices `v1` and `v2` are\nprimitively equal (that is, without calling metamethods).\nOtherwise returns `false`.\nAlso returns `false` if any of the indices are non valid.\n",
      "xpcall": "This function is similar to pcall, except that you can set a new error\nhandler.\n",
      "loadfile": "Loads the chunk from file filename or from the standard input if no filename\nis given.\n",
      "load": "Loads the chunk from given string.\n"
    },
    "fields": {}
  },
  "lua.HaxeIterator": {
    "doc": "An implementation of the Haxe iterator data structure needed for identical\nlua iterator behavior.\n",
    "path": "haxe\\std\\lua\\HaxeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Lib": {
    "doc": "Platform-specific Lua Library. Provides some platform-specific functions\nfor the Lua target, such as conversion from Haxe types to native types\nand vice-versa.\n",
    "path": "haxe\\std\\lua\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.\n",
      "patternQuote": "Perform Lua-style pattern quoting on a given string.\n",
      "fillArray": "Fills an array with the result of a simple iterator.\n",
      "isShellAvailable": "Simple test for the presence of an available shell.\n"
    },
    "fields": {}
  },
  "lua.PairTools": {
    "doc": "A set of utility methods for working with the Lua table extern.\n",
    "path": "haxe\\std\\lua\\PairTools.hx",
    "functions": {},
    "fields": {}
  },
  "lua.Thread": {
    "doc": "The sole purpose of this extern is to provide a concrete type for\nbasic reflection purposes.\n",
    "path": "haxe\\std\\lua\\Thread.hx",
    "functions": {},
    "fields": {}
  },
  "neko.Lib": {
    "doc": "Platform-specific Neko Library. Provides some platform-specific functions\nfor the Neko target, such as conversion from Haxe types to native types\nand vice-versa.\n",
    "path": "haxe\\std\\neko\\Lib.hx",
    "functions": {
      "print": "Print the specified value on the default output.\n",
      "println": "Print the specified value on the default output followed by a newline character.\n",
      "rethrow": "Rethrow an exception. This is useful when manually filtering an exception in order\nto keep the previous exception stack.\n",
      "serialize": "Serialize using native Neko serialization. This will return a Binary string that can be\nstored for long term usage. The serialized data is optimized for speed and not for size.\n",
      "unserialize": "Unserialize a string using native Neko serialization. See `serialize`.\n",
      "localUnserialize": "Unserialize a string using native Neko serialization. See `serialize`.\nThis function assume that all the serialized data was serialized with current\nmodule, even if the module name was different. This can happen if you are unserializing\nsome data into mod_neko that was serialized on a different server using a different\nfile path.\n",
      "nekoToHaxe": "Converts a Neko value to its Haxe equivalent. Used for wrapping String and Arrays raw values into Haxe Objects.\n",
      "haxeToNeko": "Converts a Haxe value to its Neko equivalent. Used to unwrap String and Arrays Objects into raw Neko values.\n",
      "getClasses": "Returns an object containing all compiled packages and classes.\n",
      "stringReference": "Returns a string referencing the data contains in bytes.\n",
      "bytesReference": "Returns bytes referencing the content of a string.\n"
    },
    "fields": {}
  },
  "neko.Random": {
    "doc": "A seeded pseudo-random generator.\n",
    "path": "haxe\\std\\neko\\Random.hx",
    "functions": {
      "setSeed": "Set the generator seed.\n",
      "int": "Return a random integer modulo max.\n",
      "float": "Return a random float.\n"
    },
    "fields": {}
  },
  "neko.vm.Gc": {
    "doc": "Neko garbage collector utility.",
    "path": "haxe\\std\\neko\\vm\\Gc.hx",
    "functions": {
      "stats": "Return the size of the GC heap and the among of free space,\nin bytes.\n"
    },
    "fields": {}
  },
  "neko.vm.Loader": {
    "doc": "The Neko object that implements the loader.\n*/\n@:callable\n@:coreType\nabstract LoaderHandle {}\n\n/**\nLoaders can be used to dynamically load Neko primitives stored in NDLL libraries.\n\n\nLoaders can be used to dynamically load other Neko modules (.n bytecode files).\nModules are referenced by names. To lookup the corresponding bytecode file, the\ndefault loader first look in its cache, then eventually adds the .n extension\nto the name and lookup the bytecode in its path.\n\n\nLoaders can be used for sandbox security. When a Module is loaded with a given\nLoader, this loader can manager the module security by filtering which\nprimitives can be loaded by this module or by rewrapping them at loading-time\nwith custom secured versions. Loaders are inherited in loaded submodules.\n",
    "path": "haxe\\std\\neko\\vm\\Loader.hx",
    "functions": {
      "addPath": "Adds a directory to the search path. See `getPath`.\n",
      "getCache": "The default loader contains a cache of already loaded modules. It's\nensuring that the same module does not get loaded twice when circular\nreferences are occurring. The same module can eventually be loaded twice\nbut with different names, for example with two relative paths representing\nthe same file, since the cache is done on a by-name basic.\n",
      "setCache": "Set a module in the loader cache.\n",
      "backupCache": "Change the cache value and returns the old value. This can be used\nto backup the loader cache and restore it later.\n",
      "loadPrimitive": "Loads a neko primitive. By default, the name is of the form `[library@method]`.\nThe primitive might not be used directly in Haxe since some of the Neko values\nneeds an object wrapper in Haxe.\n",
      "loadModule": "Loads a Module with the given name. If `loader` is defined, this will be\nthis Module loader, else this loader will be inherited. When loaded this\nway, the module is directly executed.\n",
      "local": "Returns the local Loader. This is the loader that was used to load the\nmodule in which the code is defined.\n",
      "make": "Creates a loader using two methods. This loader will not have an accessible cache or path,\nalthough you can implement such mechanism in the methods body.\n"
    },
    "fields": {}
  },
  "neko.vm.Module": {
    "doc": "The abstract Neko module handle.\n*/\n@:callable\n@:coreType\nabstract ModuleHandle {}\n\n/**\nA Neko Module represent a execution unit for the Neko Virtual Machine.\nEach compiled `.n` bytecode file is a module once loaded by the NekoVM.\n",
    "path": "haxe\\std\\neko\\vm\\Module.hx",
    "functions": {
      "loader": "Returns the Loader that this Module was loaded with.\n",
      "codeSize": "Returns the codeSize of the Module.\n",
      "globalsCount": "Returns the number of globals in this Module global table.\n",
      "getGlobal": "Get a Module global value.\n",
      "setGlobal": "Set a Module global value.\n",
      "getExports": "Each Module has an export table which can be useful to transfer\nvalues between modules.\n",
      "exportsTable": "The raw export table.\n",
      "setExport": "Set a value in the Module export table.\n",
      "local": "Returns the local Module, which is the one in which this\nmethod is included.\n",
      "read": "Reads a module from an Input by using the given Loader.\nThe module is initialized but has not yet been executed.\n",
      "readBytes": "Reads a module from Bytes using the given Loader.\nThe module is initialized but has not yet been executed.\n",
      "readPath": "Reads a module from a name and using the specified search path and loader.\nThe module is initialized but has not yet been executed.\n",
      "readGlobalsNames": "Extract the globals names from the given module\n"
    },
    "fields": {}
  },
  "neko.vm.Ui": {
    "doc": "Core native User Interface support. This API uses native WIN32 API\non Windows, Carbon API on OSX, and GTK2 on Linux.",
    "path": "haxe\\std\\neko\\vm\\Ui.hx",
    "functions": {
      "loop": "Starts the native UI event loop. This method can only be called\nfrom the main thread.\n",
      "stopLoop": "Stop the native UI event loop. This method can only be called\nfrom the main thread.\n",
      "sync": "Queue a method call callb to be executed by the main thread while\nrunning the UI event loop. This can be used to perform UI updates\nin the UI thread using results processed by another thread.\n"
    },
    "fields": {}
  },
  "php.Lib": {
    "doc": "Platform-specific PHP Library. Provides some platform-specific functions\nfor the PHP target, such as conversion from Haxe types to native types\nand vice-versa.\n",
    "path": "haxe\\std\\php\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by\na newline character.\n",
      "dump": "Displays structured information about one or more expressions\nthat includes its type and value. Arrays and objects are\nexplored recursively with values indented to show structure.\n",
      "serialize": "Serialize using native PHP serialization. This will return a binary\n`String` that can be stored for long term usage.\n",
      "unserialize": "Unserialize a `String` using native PHP serialization. See `php.Lib.serialize()`.\n",
      "extensionLoaded": "Find out whether an extension is loaded.\n",
      "printFile": "Output file content from the given file name.\n",
      "mail": "See the documentation for the equivalent PHP function for details on usage:\n<http://php.net/manual/en/function.mail.php>\n",
      "getClasses": "Rethrows an exception.\nIf `e` is not a value caught in `try...catch` or if called outside of `catch` block, then `e` is thrown as\na new exception.\n*/\nextern public static inline function rethrow(e:Dynamic) {\nif (Syntax.code(\"isset($__hx__caught_e, $__hx__real_e)\") && e == Syntax.code(\"$__hx__real_e\")) {\nSyntax.code(\"throw $__hx__caught_e\");\n}\nthrow e;\n}\n\n/**\nTries to load all compiled php files and returns list of types.\n",
      "loadLib": "Loads types defined in the specified directory.\n"
    },
    "fields": {}
  },
  "php.Resource": {
    "doc": "PHP native `resource` type\n@see http://php.net/manual/en/language.types.resource.php\n",
    "path": "haxe\\std\\php\\Resource.hx",
    "functions": {},
    "fields": {}
  },
  "php.Session": {
    "doc": "Session consists of a way to preserve certain data across\nsubsequent accesses.",
    "path": "haxe\\std\\php\\Session.hx",
    "functions": {},
    "fields": {}
  },
  "python.KwArgs": {
    "doc": "This type represents python `**kwargs` feature, supporting\npassing named arguments to a function.\n\nExample:\n\n```haxe\nfunction f(kwargs:KwArgs<{a:Int}>) {}\nf({a: 10});\n```\n",
    "path": "haxe\\std\\python\\KwArgs.hx",
    "functions": {},
    "fields": {}
  },
  "python.Lib": {
    "doc": "Platform-specific Python Library. Provides some platform-specific functions\nfor the Python target, such as conversion from Haxe types to native types\nand vice-versa.\n",
    "path": "haxe\\std\\python\\Lib.hx",
    "functions": {
      "println": "Print the specified value on the default output followed by a newline character.\n",
      "dictToAnon": "Returns an anonymous Object which holds the same data as the Dictionary `v`.\n",
      "anonToDict": "Returns a flat copy of the underlying Dictionary of `o`.\n",
      "anonAsDict": "Returns the underlying Dictionary of the anonymous object `o`.\nModifications to this dictionary are reflected in the anonymous Object too.\n",
      "dictAsAnon": "Returns the Dictionary `d` as an anonymous Object.\nModifications to the object are reflected in the Dictionary too.\n",
      "toPythonIterable": "Return Python native iterable from Haxe iterable.\n",
      "toHaxeIterable": "Return Haxe iterable from Python native iterable.\n",
      "toHaxeIterator": "Return Haxe iterator instance from Python native iterable.\n"
    },
    "fields": {}
  },
  "python.NativeIterable": {
    "doc": "This type represents native Python iterables (objects that implement `__iter__()` method).\nIt supports Haxe iteration and conversion to `Iterable` by creating wrapper objects.\n",
    "path": "haxe\\std\\python\\NativeIterable.hx",
    "functions": {},
    "fields": {}
  },
  "python.NativeIterator": {
    "doc": "This type represents native Python iterators.\nIt supports automatic conversion to Haxe `Iterator` by creating wrapper object.\n",
    "path": "haxe\\std\\python\\NativeIterator.hx",
    "functions": {},
    "fields": {}
  },
  "python.internal.UBuiltins": {
    "doc": "This class provides unqualified access to python builtins that are safe to use in haxe/python code.\nFields listed here must be synchronized with genpy's KeywordHandler.kwds2 list to be properly escaped.\n",
    "path": "haxe\\std\\python\\internal\\UBuiltins.hx",
    "functions": {},
    "fields": {}
  },
  "sys.FileSystem": {
    "doc": "This class provides information about files and directories.\n\nIf `null` is passed as a file path to any function in this class, the\nresult is unspecified, and may differ from target to target.\n\nSee `sys.io.File` for the complementary file API.\n",
    "path": "haxe\\std\\sys\\FileSystem.hx",
    "functions": {
      "rename": "Renames/moves the file or directory specified by `path` to `newPath`.\n\nIf `path` is not a valid file system entry, or if it is not accessible,\nor if `newPath` is not accessible, an exception is thrown.\n",
      "stat": "Returns `FileStat` information for the file or directory specified by\n`path`.\n",
      "fullPath": "Returns the full path of the file or directory specified by `relPath`,\nwhich is relative to the current working directory. Symlinks will be\nfollowed and the path will be normalized.\n",
      "absolutePath": "Returns the full path of the file or directory specified by `relPath`,\nwhich is relative to the current working directory. The path doesn't\nhave to exist.\n",
      "isDirectory": "Returns `true` if the file or directory specified by `path` is a directory.\n\nIf `path` is not a valid file system entry or if its destination is not\naccessible, an exception is thrown.\n",
      "createDirectory": "Creates a directory specified by `path`.\n\nThis method is recursive: The parent directories don't have to exist.\n\nIf the directory cannot be created, an exception is thrown.\n",
      "deleteFile": "Deletes the file specified by `path`.\n\nIf `path` does not denote a valid file, or if that file cannot be\ndeleted, an exception is thrown.\n",
      "deleteDirectory": "Deletes the directory specified by `path`. Only empty directories can\nbe deleted.\n\nIf `path` does not denote a valid directory, or if that directory cannot\nbe deleted, an exception is thrown.\n",
      "readDirectory": "Returns the names of all files and directories in the directory specified\nby `path`. `\".\"` and `\"..\"` are not included in the output.\n\nIf `path` does not denote a valid directory, an exception is thrown.\n"
    },
    "fields": {}
  },
  "sys.io.File": {
    "doc": "API for reading and writing files.\n\nSee `sys.FileSystem` for the complementary file system API.\n",
    "path": "haxe\\std\\sys\\io\\File.hx",
    "functions": {
      "saveContent": "Stores `content` in the file specified by `path`.\n\nIf the file cannot be written to, an exception is thrown.\n\nIf `path` or `content` are null, the result is unspecified.\n",
      "getBytes": "Retrieves the binary content of the file specified by `path`.\n\nIf the file does not exist or can not be read, an exception is thrown.\n\n`sys.FileSystem.exists` can be used to check for existence.\n\nIf `path` is null, the result is unspecified.\n",
      "saveBytes": "Stores `bytes` in the file specified by `path` in binary mode.\n\nIf the file cannot be written to, an exception is thrown.\n\nIf `path` or `bytes` are null, the result is unspecified.\n",
      "read": "Returns an `FileInput` handle to the file specified by `path`.\n\nIf `binary` is true, the file is opened in binary mode. Otherwise it is\nopened in non-binary mode.\n\nIf the file does not exist or can not be read, an exception is thrown.\n\nOperations on the returned `FileInput` handle read on the opened file.\n\nFile handles should be closed via `FileInput.close` once the operation\nis complete.\n\nIf `path` is null, the result is unspecified.\n",
      "write": "Returns an `FileOutput` handle to the file specified by `path`.\n\nIf `binary` is true, the file is opened in binary mode. Otherwise it is\nopened in non-binary mode.\n\nIf the file cannot be written to, an exception is thrown.\n\nOperations on the returned `FileOutput` handle write to the opened file.\nIf the file existed, its previous content is overwritten.\n\nFile handles should be closed via `FileOutput.close` once the operation\nis complete.\n\nIf `path` is null, the result is unspecified.\n",
      "append": "Similar to `sys.io.File.write`, but appends to the file if it exists\ninstead of overwriting its contents.\n",
      "update": "Similar to `sys.io.File.append`. While `append` can only seek or write\nstarting from the end of the file's previous contents, `update` can\nseek to any position, so the file's previous contents can be\nselectively overwritten.\n",
      "copy": "Copies the contents of the file specified by `srcPath` to the file\nspecified by `dstPath`.\n\nIf the `srcPath` does not exist or cannot be read, or if the `dstPath`\nfile cannot be written to, an exception is thrown.\n\nIf the file at `dstPath` exists, its contents are overwritten.\n\nIf `srcPath` or `dstPath` are null, the result is unspecified.\n"
    },
    "fields": {}
  },
  "sys.io.FileInput": {
    "doc": "Use `sys.io.File.read` to create a `FileInput`.\n",
    "path": "haxe\\std\\sys\\io\\FileInput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.io.FileOutput": {
    "doc": "Use `sys.io.File.write` to create a `FileOutput`.\n",
    "path": "haxe\\std\\sys\\io\\FileOutput.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Address": {
    "doc": "An address is used to represent a port on a given host ip.\nIt is used by `sys.net.UdpSocket`.\n",
    "path": "haxe\\std\\sys\\net\\Address.hx",
    "functions": {},
    "fields": {}
  },
  "sys.net.Host": {
    "doc": "A given IP host name.\n",
    "path": "haxe\\std\\sys\\net\\Host.hx",
    "functions": {
      "toString": "Returns the IP representation of the host\n",
      "reverse": "Perform a reverse-DNS query to resolve a host name from an IP.\n",
      "localhost": "Returns the local computer host name\n"
    },
    "fields": {
      "ip": "The actual IP corresponding to the host.\n"
    }
  },
  "sys.net.Socket": {
    "doc": "A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.\n",
    "path": "haxe\\std\\sys\\net\\Socket.hx",
    "functions": {
      "close": "Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.\n",
      "read": "Read the whole data available on the socket.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`,\nas it will always throw `haxe.io.Error.Blocked`. `input` methods should be used directly instead.\n",
      "write": "Write the whole data to the socket output.\n\nNote*: this is **not** meant to be used together with `setBlocking(false)`, as\n`haxe.io.Error.Blocked` may be thrown mid-write with no indication of how many bytes have been written.\n`output.writeBytes()` should be used instead as it returns this information.\n",
      "connect": "Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.\n",
      "listen": "Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.\n",
      "shutdown": "Shutdown the socket, either for reading or writing.\n",
      "bind": "Bind the socket to the given host/port so it can afterwards listen for connections there.\n",
      "accept": "Accept a new connected client. This will return a connected socket on which you can read/write some data.\n",
      "peer": "Return the information about the other side of a connected socket.\n",
      "host": "Return the information about our side of a connected socket.\n",
      "setTimeout": "Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.\n",
      "waitForRead": "Block until some data is available for read on the socket.\n",
      "setBlocking": "Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.\n",
      "setFastSend": "Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.\n",
      "select": "Wait until one of the sockets group is ready for the given operation:\n\n- `read` contains sockets on which we want to wait for available data to be read,\n- `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,\n- `others` contains sockets on which we want to wait for exceptional conditions.\n- `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.\n\nIn case a `timeout` (in seconds) is specified, select might wait at worst until the timeout expires.\n"
    },
    "fields": {
      "output": "The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.\n",
      "custom": "A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.\n*"
    }
  },
  "sys.net.UdpSocket": {
    "doc": "A UDP socket class\n",
    "path": "haxe\\std\\sys\\net\\UdpSocket.hx",
    "functions": {
      "sendTo": "Sends data to the specified target host/port address.\n",
      "readFrom": "Reads data from any incoming address and store the receiver address into the address parameter.\n"
    },
    "fields": {}
  },
  "sys.ssl.Socket": {
    "doc": "A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.\n",
    "path": "haxe\\std\\sys\\ssl\\Socket.hx",
    "functions": {
      "setCA": "Configure the certificate chain for peer certificate verification.\n",
      "setHostname": "Configure the hostname for Server Name Indication TLS extension.\n",
      "setCertificate": "Configure own certificate and private key.\n",
      "addSNICertificate": "Configure additional certificates and private keys for Server Name Indication extension.\nThe callback may be called during handshake to determine the certificate to use.\n",
      "peerCertificate": "Return the certificate received from the other side of a connection.\n"
    },
    "fields": {}
  },
  "sys.thread.NextEventTime": {
    "doc": "When an event loop has an available event to execute.\n",
    "path": "haxe\\std\\sys\\thread\\EventLoop.hx",
    "functions": {
      "cancel": "Prevent execution of a previously scheduled event in current loop.\n",
      "promise": "Notify this loop about an upcoming event.\nThis makes the thread stay alive and wait for as many events as the number of\ntimes `.promise()` was called. These events should be added via `.runPromised()`.\n",
      "run": "Execute `event` as soon as possible.\n",
      "runPromised": "Add previously promised `event` for execution.\n",
      "progress": "Executes all pending events.\n\nThe returned time stamps can be used with `Sys.time()` for calculations.\n\nDepending on a target platform this method may be non-reentrant. It must\nnot be called from event callbacks.\n",
      "wait": "Blocks until a new event is added or `timeout` (in seconds) to expires.\n\nDepending on a target platform this method may also automatically execute arriving\nevents while waiting. However if any event is executed it will stop waiting.\n\nReturns `true` if more events are expected.\nReturns `false` if no more events expected.\n\nDepending on a target platform this method may be non-reentrant. It must\nnot be called from event callbacks.\n",
      "loop": "Execute all pending events.\nWait and execute as many events as the number of times `promise()` was called.\nRuns until all repeating events are cancelled and no more events are expected.\n\nDepending on a target platform this method may be non-reentrant. It must\nnot be called from event callbacks.\n",
      "__progress": "`.progress` implementation with a reusable array for internal usage.\nThe `nextEventAt` field of the return value denotes when the next event\nis expected to run:\n-1 - never\n-2 - now\nother values - at specified time\n"
    },
    "fields": {}
  },
  "sys.thread.IThreadPool": {
    "doc": "A thread pool interface.\n",
    "path": "haxe\\std\\sys\\thread\\IThreadPool.hx",
    "functions": {
      "shutdown": "Initiates a shutdown.\nAll previously submitted tasks will be executed, but no new tasks will\nbe accepted.\n\nMultiple calls to this method have no effect.\n"
    },
    "fields": {
      "isShutdown": "Indicates if `shutdown` method of this pool has been called."
    }
  },
  "sys.thread.Lock": {
    "doc": "A Lock allows blocking execution until it has been unlocked. It keeps track\nof how often `release` has been called, and blocks exactly as many `wait`\ncalls.\n\nThe order of the `release` and `wait` calls is irrelevant. That is, a Lock\ncan be released before anyone waits for it. In that case, the `wait` call\nwill execute immediately.\n\nUsage example:\n\n```haxe\nvar lock = new Lock();\nvar elements = [1, 2, 3];\nfor (element in elements) {\n// Create one thread per element\nnew Thread(function() {\ntrace(element);\nSys.sleep(1);\n// Release once per thread = 3 times\nlock.release();\n});\n}\nfor (_ in elements) {\n// Wait 3 times\nlock.wait();\n}\ntrace(\"All threads finished\");\n```\n",
    "path": "haxe\\std\\sys\\thread\\Lock.hx",
    "functions": {
      "wait": "Waits for the lock to be released, or `timeout` (in seconds)\nto expire. Returns `true` if the lock is released and `false`\nif a time-out occurs.\n",
      "release": "Releases the lock once.\n\nThe thread does not need to own the lock in order to release\nit. Each call to `release` allows exactly one call to `wait`\nto execute.\n"
    },
    "fields": {}
  },
  "sys.thread.Mutex": {
    "doc": "Creates a mutex, which can be used to acquire a temporary lock\nto access some resource. The main difference with a lock is\nthat a mutex must always be released by the owner thread.\n",
    "path": "haxe\\std\\sys\\thread\\Mutex.hx",
    "functions": {
      "acquire": "The current thread acquire the mutex or wait if not available.\nThe same thread can acquire several times the same mutex but\nmust release it as many times it has been acquired.\n",
      "tryAcquire": "Try to acquire the mutex, returns true if acquire or false\nif it's already locked by another thread.\n",
      "release": "Release a mutex that has been acquired by the current thread.\nThe behavior is undefined if the current thread does not own\nthe mutex.\n"
    },
    "fields": {}
  },
  "sys.thread.Tls": {
    "doc": "Creates thread local storage.\n\n(hl) Warning: At the moment `Tls` does not protect the value from being\ngarbage collected. Keep the value reachable to avoid crashes.\n",
    "path": "haxe\\std\\sys\\thread\\Tls.hx",
    "functions": {},
    "fields": {}
  }
}